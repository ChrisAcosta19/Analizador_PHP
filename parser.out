Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASYNC
    AWAIT
    BOOL
    CALLABLE
    CASE
    CATCH
    CLONE
    CONST
    DECLARE
    DEFAULT
    DIE
    DO
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FINAL
    FINALLY
    FN
    FOREACH
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    LIST
    LPAREN
    MATCH
    MIXED
    MOD
    NAMESPACE
    NULL
    OBJECT
    POP
    POWER
    PUSH
    REQUIRE
    REQUIRE_ONCE
    RPAREN
    SELF
    STATIC
    SWITCH
    THROW
    TRAIT
    TRY
    UNSET
    USE
    VAR
    VOID
    YIELD
    YIELD_FROM

Grammar

Rule 0     S' -> program
Rule 1     program -> OPEN_TAG statements CLOSE_TAG
Rule 2     statements -> statement2
Rule 3     statements -> statements statement2
Rule 4     statement2 -> statement SEMICOLON
Rule 5     statement2 -> if_statement
Rule 6     statement2 -> while_statement
Rule 7     statement2 -> for_statement
Rule 8     statement2 -> function_statement
Rule 9     statement2 -> ONE_LINE_COMMENT
Rule 10    statement2 -> MULTI_LINE_COMMENT
Rule 11    statement2 -> class_declaration
Rule 12    statement -> print_statement
Rule 13    statement -> fscanf_statement
Rule 14    statement -> fgets_statement
Rule 15    statement -> assignment_statement
Rule 16    statement -> array_declaration_statement
Rule 17    statement -> BREAK
Rule 18    statement -> CONTINUE
Rule 19    statement -> function_call
Rule 20    statement -> return_statement
Rule 21    function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
Rule 22    function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
Rule 23    lambda_function -> LAMBDA arguments COLON expression
Rule 24    arrow_function -> ARROW arguments ARROW expression
Rule 25    return_statement -> RETURN arguments
Rule 26    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 27    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 28    variable_list -> variable
Rule 29    variable_list -> variable_list COMMA variable
Rule 30    variable -> ID
Rule 31    assignment_statement -> variable CALL NAME assignment_operator argument
Rule 32    assignment_statement -> variable assignment_operator argument
Rule 33    assignment_statement -> variable PLUS_PLUS
Rule 34    assignment_statement -> variable MINUS_MINUS
Rule 35    assignment_operator -> EQUALS
Rule 36    assignment_operator -> PLUS_EQUALS
Rule 37    assignment_operator -> MINUS_EQUALS
Rule 38    assignment_operator -> TIMES_EQUALS
Rule 39    assignment_operator -> DIVIDE_EQUALS
Rule 40    assignment_operator -> MOD_EQUALS
Rule 41    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 42    print_statement -> print_function arguments
Rule 43    print_function -> PRINT
Rule 44    print_function -> ECHO
Rule 45    arguments -> argument
Rule 46    arguments -> arguments DOT argument
Rule 47    arguments -> arguments COMMA argument
Rule 48    argument -> STRING
Rule 49    argument -> expression
Rule 50    argument -> assignment_statement
Rule 51    argument -> variable CALL NAME
Rule 52    argument -> variable CALL function_call
Rule 53    argument -> array
Rule 54    argument -> function_call
Rule 55    argument -> fgets_statement
Rule 56    argument -> array_indexing
Rule 57    argument -> casting argument
Rule 58    argument -> object_creation
Rule 59    expression -> expression PLUS term
Rule 60    expression -> expression MINUS term
Rule 61    expression -> term
Rule 62    term -> term TIMES factor
Rule 63    term -> term DIVIDE factor
Rule 64    term -> factor
Rule 65    factor -> INTEGER
Rule 66    factor -> FLOAT
Rule 67    factor -> condition
Rule 68    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 69    if_statement -> IF parenthesized_condition block
Rule 70    if_statement -> IF parenthesized_condition block else_if_extended
Rule 71    if_statement -> IF parenthesized_condition block else_if_extended if_part3
Rule 72    if_statement -> IF parenthesized_condition block if_part3
Rule 73    else_if_extended -> if_part2
Rule 74    else_if_extended -> else_if_extended if_part2
Rule 75    if_part2 -> ELSEIF parenthesized_condition block
Rule 76    if_part3 -> ELSE block
Rule 77    while_statement -> WHILE parenthesized_condition block
Rule 78    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 79    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 80    for_statement -> for_part1 condition for_part3
Rule 81    for_statement -> for_part1 for_part3
Rule 82    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 83    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 84    for_part4 -> block
Rule 85    for_part4 -> SEMICOLON
Rule 86    assignment_list -> assignment_statement
Rule 87    assignment_list -> assignment_list COMMA assignment_statement
Rule 88    statement_list -> statement
Rule 89    statement_list -> statement_list COMMA statement
Rule 90    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 91    block -> LEFT_BRACE RIGHT_BRACE
Rule 92    condition -> simple_condition
Rule 93    condition -> negated_condition
Rule 94    condition -> complex_condition
Rule 95    condition -> parenthesized_condition
Rule 96    simple_condition -> TRUE
Rule 97    simple_condition -> FALSE
Rule 98    simple_condition -> variable
Rule 99    simple_condition -> relational_expression
Rule 100   negated_condition -> LOGICAL_NOT condition
Rule 101   complex_condition -> condition logical_operator condition
Rule 102   parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 103   relational_expression -> expression relational_operator expression
Rule 104   relational_operator -> EQUAL_TO
Rule 105   relational_operator -> NOT_EQUAL_TO
Rule 106   relational_operator -> LESS_THAN
Rule 107   relational_operator -> GREATER_THAN
Rule 108   relational_operator -> LESS_EQUAL
Rule 109   relational_operator -> GREATER_EQUAL
Rule 110   relational_operator -> IDENTICAL_TO
Rule 111   relational_operator -> NOT_IDENTICAL_TO
Rule 112   relational_operator -> DIFFERENT
Rule 113   logical_operator -> LOGICAL_AND
Rule 114   logical_operator -> LOGICAL_OR
Rule 115   logical_operator -> LOGICAL_XOR
Rule 116   casting -> LEFT_PAREN casting_type RIGHT_PAREN
Rule 117   casting_type -> INT_TYPE
Rule 118   casting_type -> FLOAT_TYPE
Rule 119   function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN
Rule 120   function_call -> NAME LEFT_PAREN RIGHT_PAREN
Rule 121   array_declaration_statement -> variable EQUALS array
Rule 122   array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 123   array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 124   array_elements -> array_argument
Rule 125   array_elements -> array_elements COMMA array_argument
Rule 126   array_argument -> argument
Rule 127   array_argument -> clave KEY_VALUE argument
Rule 128   clave -> STRING
Rule 129   clave -> INTEGER
Rule 130   array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET
Rule 131   class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
Rule 132   class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE
Rule 133   class_statements -> class_statement
Rule 134   class_statements -> class_statements class_statement
Rule 135   class_statement -> method_declaration
Rule 136   class_statement -> property_declaration
Rule 137   class_statement -> ONE_LINE_COMMENT
Rule 138   class_statement -> MULTI_LINE_COMMENT
Rule 139   method_declaration -> visibility_operator function_statement
Rule 140   property_declaration -> visibility_operator variable SEMICOLON
Rule 141   visibility_operator -> PUBLIC
Rule 142   visibility_operator -> PRIVATE
Rule 143   visibility_operator -> PROTECTED
Rule 144   object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN
Rule 145   object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN

Terminals, with rules where they appear

ABSTRACT             : 
ARRAY                : 122
ARROW                : 24 24
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 17
CALL                 : 31 51 52
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 131 132
CLONE                : 
CLOSE_TAG            : 1
COLON                : 23
COMMA                : 27 27 29 47 87 89 125
CONST                : 
CONTINUE             : 18
DECLARE              : 
DEFAULT              : 
DIE                  : 
DIFFERENT            : 112
DIVIDE               : 63
DIVIDE_EQUALS        : 39
DO                   : 
DOT                  : 46
ECHO                 : 44
ELSE                 : 76
ELSEIF               : 75
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENUM                 : 
EQUALS               : 35 121
EQUAL_TO             : 104
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 97
FGETS                : 26
FINAL                : 
FINALLY              : 
FLOAT                : 66
FLOAT_TYPE           : 118
FN                   : 
FOR                  : 78 79
FOREACH              : 
FSCANF               : 27
FUNCTION             : 21 22
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 109
GREATER_THAN         : 107
HALT_COMPILER        : 
ID                   : 30
IDENTICAL_TO         : 110
IF                   : 69 70 71 72
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 65 129 130
INTERFACE            : 
INT_TYPE             : 117
ISSET                : 
ITERABLE             : 
KEY_VALUE            : 127
LAMBDA               : 23
LEFT_BRACE           : 90 91 131 132
LEFT_BRACKET         : 123 130
LEFT_PAREN           : 21 22 26 27 41 68 78 79 102 116 119 120 122 144 145
LESS_EQUAL           : 108
LESS_THAN            : 106
LIST                 : 
LOGICAL_AND          : 113
LOGICAL_NOT          : 100
LOGICAL_OR           : 114
LOGICAL_XOR          : 115
LPAREN               : 
MATCH                : 
MINUS                : 60
MINUS_EQUALS         : 37
MINUS_MINUS          : 34
MIXED                : 
MOD                  : 
MOD_EQUALS           : 40
MULTI_LINE_COMMENT   : 10 138
NAME                 : 21 22 31 51 119 120 131 132 144 145
NAMESPACE            : 
NEW                  : 144 145
NOT_EQUAL_TO         : 105
NOT_IDENTICAL_TO     : 111
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 9 137
OPEN_TAG             : 1
PLUS                 : 59
PLUS_EQUALS          : 36
PLUS_PLUS            : 33
POP                  : 
POWER                : 
PRINT                : 43
PRIVATE              : 142
PROTECTED            : 143
PUBLIC               : 141
PUSH                 : 
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 25
RIGHT_BRACE          : 90 91 131 132
RIGHT_BRACKET        : 123 130
RIGHT_PAREN          : 21 22 26 27 41 68 82 83 102 116 119 120 122 144 145
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 78 79 82 83 85 140
STATIC               : 
STDIN                : 26 27
STRING               : 27 48 128
SWITCH               : 
THROW                : 
TIMES                : 62
TIMES_EQUALS         : 38
TRAIT                : 
TRUE                 : 96
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
VOID                 : 
WHILE                : 77
YIELD                : 
YIELD_FROM           : 
error                : 

Nonterminals, with rules where they appear

argument             : 31 32 45 46 47 57 126 127
arguments            : 23 24 25 41 42 46 47 119 145
array                : 53 121
array_argument       : 124 125
array_declaration_statement : 16
array_elements       : 21 122 123 125
array_indexing       : 56
arrow_function       : 
assignment_list      : 78 87
assignment_operator  : 31 32
assignment_statement : 15 50 86 87
block                : 21 22 69 70 71 72 75 76 77 84
casting              : 57
casting_type         : 116
class_declaration    : 11
class_statement      : 133 134
class_statements     : 131 134
clave                : 127
complex_condition    : 94
condition            : 67 80 100 101 101 102
else_if_extended     : 70 71 74
expression           : 23 24 49 59 60 68 103 103
factor               : 62 63 64
fgets_statement      : 14 55
for_part1            : 80 81
for_part3            : 80 81
for_part4            : 82 83
for_statement        : 7
fscanf_statement     : 13
function_call        : 19 52 54
function_statement   : 8 139
if_part2             : 73 74
if_part3             : 71 72
if_statement         : 5
lambda_function      : 
logical_operator     : 101
method_declaration   : 135
negated_condition    : 93
object_creation      : 58
parenthesized_condition : 69 70 71 72 75 77 95
print_function       : 41 42
print_statement      : 12
program              : 0
property_declaration : 136
relational_expression : 99
relational_operator  : 103
return_statement     : 20
simple_condition     : 92
statement            : 4 88 89
statement2           : 2 3
statement_list       : 82 89
statements           : 1 3 90
term                 : 59 60 61 62 63
variable             : 28 29 31 32 33 34 51 52 98 121 130 140
variable_list        : 27 29
visibility_operator  : 139 140
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . OPEN_TAG statements CLOSE_TAG

    OPEN_TAG        shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> OPEN_TAG . statements CLOSE_TAG
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (69) if_statement -> . IF parenthesized_condition block
    (70) if_statement -> . IF parenthesized_condition block else_if_extended
    (71) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (72) if_statement -> . IF parenthesized_condition block if_part3
    (77) while_statement -> . WHILE parenthesized_condition block
    (80) for_statement -> . for_part1 condition for_part3
    (81) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (131) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (132) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (41) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> . print_function arguments
    (27) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (121) array_declaration_statement -> . variable EQUALS array
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (25) return_statement -> . RETURN arguments
    (78) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (79) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (43) print_function -> . PRINT
    (44) print_function -> . ECHO
    (30) variable -> . ID

    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FUNCTION        shift and go to state 25
    CLASS           shift and go to state 27
    FSCANF          shift and go to state 29
    FGETS           shift and go to state 30
    NAME            shift and go to state 26
    RETURN          shift and go to state 32
    FOR             shift and go to state 33
    PRINT           shift and go to state 34
    ECHO            shift and go to state 35
    ID              shift and go to state 36

    statements                     shift and go to state 3
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    for_part1                      shift and go to state 24
    print_function                 shift and go to state 28
    variable                       shift and go to state 31

state 3

    (1) program -> OPEN_TAG statements . CLOSE_TAG
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (69) if_statement -> . IF parenthesized_condition block
    (70) if_statement -> . IF parenthesized_condition block else_if_extended
    (71) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (72) if_statement -> . IF parenthesized_condition block if_part3
    (77) while_statement -> . WHILE parenthesized_condition block
    (80) for_statement -> . for_part1 condition for_part3
    (81) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (131) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (132) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (41) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> . print_function arguments
    (27) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (121) array_declaration_statement -> . variable EQUALS array
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (25) return_statement -> . RETURN arguments
    (78) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (79) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (43) print_function -> . PRINT
    (44) print_function -> . ECHO
    (30) variable -> . ID

    CLOSE_TAG       shift and go to state 37
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FUNCTION        shift and go to state 25
    CLASS           shift and go to state 27
    FSCANF          shift and go to state 29
    FGETS           shift and go to state 30
    NAME            shift and go to state 26
    RETURN          shift and go to state 32
    FOR             shift and go to state 33
    PRINT           shift and go to state 34
    ECHO            shift and go to state 35
    ID              shift and go to state 36

    statement2                     shift and go to state 38
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    for_part1                      shift and go to state 24
    print_function                 shift and go to state 28
    variable                       shift and go to state 31

state 4

    (2) statements -> statement2 .

    CLOSE_TAG       reduce using rule 2 (statements -> statement2 .)
    ONE_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    MULTI_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    BREAK           reduce using rule 2 (statements -> statement2 .)
    CONTINUE        reduce using rule 2 (statements -> statement2 .)
    IF              reduce using rule 2 (statements -> statement2 .)
    WHILE           reduce using rule 2 (statements -> statement2 .)
    FUNCTION        reduce using rule 2 (statements -> statement2 .)
    CLASS           reduce using rule 2 (statements -> statement2 .)
    FSCANF          reduce using rule 2 (statements -> statement2 .)
    FGETS           reduce using rule 2 (statements -> statement2 .)
    NAME            reduce using rule 2 (statements -> statement2 .)
    RETURN          reduce using rule 2 (statements -> statement2 .)
    FOR             reduce using rule 2 (statements -> statement2 .)
    PRINT           reduce using rule 2 (statements -> statement2 .)
    ECHO            reduce using rule 2 (statements -> statement2 .)
    ID              reduce using rule 2 (statements -> statement2 .)
    RIGHT_BRACE     reduce using rule 2 (statements -> statement2 .)


state 5

    (4) statement2 -> statement . SEMICOLON

    SEMICOLON       shift and go to state 39


state 6

    (5) statement2 -> if_statement .

    CLOSE_TAG       reduce using rule 5 (statement2 -> if_statement .)
    ONE_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    MULTI_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    BREAK           reduce using rule 5 (statement2 -> if_statement .)
    CONTINUE        reduce using rule 5 (statement2 -> if_statement .)
    IF              reduce using rule 5 (statement2 -> if_statement .)
    WHILE           reduce using rule 5 (statement2 -> if_statement .)
    FUNCTION        reduce using rule 5 (statement2 -> if_statement .)
    CLASS           reduce using rule 5 (statement2 -> if_statement .)
    FSCANF          reduce using rule 5 (statement2 -> if_statement .)
    FGETS           reduce using rule 5 (statement2 -> if_statement .)
    NAME            reduce using rule 5 (statement2 -> if_statement .)
    RETURN          reduce using rule 5 (statement2 -> if_statement .)
    FOR             reduce using rule 5 (statement2 -> if_statement .)
    PRINT           reduce using rule 5 (statement2 -> if_statement .)
    ECHO            reduce using rule 5 (statement2 -> if_statement .)
    ID              reduce using rule 5 (statement2 -> if_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement2 -> if_statement .)


state 7

    (6) statement2 -> while_statement .

    CLOSE_TAG       reduce using rule 6 (statement2 -> while_statement .)
    ONE_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    MULTI_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    BREAK           reduce using rule 6 (statement2 -> while_statement .)
    CONTINUE        reduce using rule 6 (statement2 -> while_statement .)
    IF              reduce using rule 6 (statement2 -> while_statement .)
    WHILE           reduce using rule 6 (statement2 -> while_statement .)
    FUNCTION        reduce using rule 6 (statement2 -> while_statement .)
    CLASS           reduce using rule 6 (statement2 -> while_statement .)
    FSCANF          reduce using rule 6 (statement2 -> while_statement .)
    FGETS           reduce using rule 6 (statement2 -> while_statement .)
    NAME            reduce using rule 6 (statement2 -> while_statement .)
    RETURN          reduce using rule 6 (statement2 -> while_statement .)
    FOR             reduce using rule 6 (statement2 -> while_statement .)
    PRINT           reduce using rule 6 (statement2 -> while_statement .)
    ECHO            reduce using rule 6 (statement2 -> while_statement .)
    ID              reduce using rule 6 (statement2 -> while_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement2 -> while_statement .)


state 8

    (7) statement2 -> for_statement .

    CLOSE_TAG       reduce using rule 7 (statement2 -> for_statement .)
    ONE_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    MULTI_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    BREAK           reduce using rule 7 (statement2 -> for_statement .)
    CONTINUE        reduce using rule 7 (statement2 -> for_statement .)
    IF              reduce using rule 7 (statement2 -> for_statement .)
    WHILE           reduce using rule 7 (statement2 -> for_statement .)
    FUNCTION        reduce using rule 7 (statement2 -> for_statement .)
    CLASS           reduce using rule 7 (statement2 -> for_statement .)
    FSCANF          reduce using rule 7 (statement2 -> for_statement .)
    FGETS           reduce using rule 7 (statement2 -> for_statement .)
    NAME            reduce using rule 7 (statement2 -> for_statement .)
    RETURN          reduce using rule 7 (statement2 -> for_statement .)
    FOR             reduce using rule 7 (statement2 -> for_statement .)
    PRINT           reduce using rule 7 (statement2 -> for_statement .)
    ECHO            reduce using rule 7 (statement2 -> for_statement .)
    ID              reduce using rule 7 (statement2 -> for_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement2 -> for_statement .)


state 9

    (8) statement2 -> function_statement .

    CLOSE_TAG       reduce using rule 8 (statement2 -> function_statement .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    BREAK           reduce using rule 8 (statement2 -> function_statement .)
    CONTINUE        reduce using rule 8 (statement2 -> function_statement .)
    IF              reduce using rule 8 (statement2 -> function_statement .)
    WHILE           reduce using rule 8 (statement2 -> function_statement .)
    FUNCTION        reduce using rule 8 (statement2 -> function_statement .)
    CLASS           reduce using rule 8 (statement2 -> function_statement .)
    FSCANF          reduce using rule 8 (statement2 -> function_statement .)
    FGETS           reduce using rule 8 (statement2 -> function_statement .)
    NAME            reduce using rule 8 (statement2 -> function_statement .)
    RETURN          reduce using rule 8 (statement2 -> function_statement .)
    FOR             reduce using rule 8 (statement2 -> function_statement .)
    PRINT           reduce using rule 8 (statement2 -> function_statement .)
    ECHO            reduce using rule 8 (statement2 -> function_statement .)
    ID              reduce using rule 8 (statement2 -> function_statement .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> function_statement .)


state 10

    (9) statement2 -> ONE_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FUNCTION        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CLASS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    NAME            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RETURN          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)


state 11

    (10) statement2 -> MULTI_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FUNCTION        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CLASS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    NAME            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RETURN          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)


state 12

    (11) statement2 -> class_declaration .

    CLOSE_TAG       reduce using rule 11 (statement2 -> class_declaration .)
    ONE_LINE_COMMENT reduce using rule 11 (statement2 -> class_declaration .)
    MULTI_LINE_COMMENT reduce using rule 11 (statement2 -> class_declaration .)
    BREAK           reduce using rule 11 (statement2 -> class_declaration .)
    CONTINUE        reduce using rule 11 (statement2 -> class_declaration .)
    IF              reduce using rule 11 (statement2 -> class_declaration .)
    WHILE           reduce using rule 11 (statement2 -> class_declaration .)
    FUNCTION        reduce using rule 11 (statement2 -> class_declaration .)
    CLASS           reduce using rule 11 (statement2 -> class_declaration .)
    FSCANF          reduce using rule 11 (statement2 -> class_declaration .)
    FGETS           reduce using rule 11 (statement2 -> class_declaration .)
    NAME            reduce using rule 11 (statement2 -> class_declaration .)
    RETURN          reduce using rule 11 (statement2 -> class_declaration .)
    FOR             reduce using rule 11 (statement2 -> class_declaration .)
    PRINT           reduce using rule 11 (statement2 -> class_declaration .)
    ECHO            reduce using rule 11 (statement2 -> class_declaration .)
    ID              reduce using rule 11 (statement2 -> class_declaration .)
    RIGHT_BRACE     reduce using rule 11 (statement2 -> class_declaration .)


state 13

    (12) statement -> print_statement .

    SEMICOLON       reduce using rule 12 (statement -> print_statement .)
    RIGHT_PAREN     reduce using rule 12 (statement -> print_statement .)
    COMMA           reduce using rule 12 (statement -> print_statement .)


state 14

    (13) statement -> fscanf_statement .

    SEMICOLON       reduce using rule 13 (statement -> fscanf_statement .)
    RIGHT_PAREN     reduce using rule 13 (statement -> fscanf_statement .)
    COMMA           reduce using rule 13 (statement -> fscanf_statement .)


state 15

    (14) statement -> fgets_statement .

    SEMICOLON       reduce using rule 14 (statement -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 14 (statement -> fgets_statement .)
    COMMA           reduce using rule 14 (statement -> fgets_statement .)


state 16

    (15) statement -> assignment_statement .

    SEMICOLON       reduce using rule 15 (statement -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 15 (statement -> assignment_statement .)
    COMMA           reduce using rule 15 (statement -> assignment_statement .)


state 17

    (16) statement -> array_declaration_statement .

    SEMICOLON       reduce using rule 16 (statement -> array_declaration_statement .)
    RIGHT_PAREN     reduce using rule 16 (statement -> array_declaration_statement .)
    COMMA           reduce using rule 16 (statement -> array_declaration_statement .)


state 18

    (17) statement -> BREAK .

    SEMICOLON       reduce using rule 17 (statement -> BREAK .)
    RIGHT_PAREN     reduce using rule 17 (statement -> BREAK .)
    COMMA           reduce using rule 17 (statement -> BREAK .)


state 19

    (18) statement -> CONTINUE .

    SEMICOLON       reduce using rule 18 (statement -> CONTINUE .)
    RIGHT_PAREN     reduce using rule 18 (statement -> CONTINUE .)
    COMMA           reduce using rule 18 (statement -> CONTINUE .)


state 20

    (19) statement -> function_call .

    SEMICOLON       reduce using rule 19 (statement -> function_call .)
    RIGHT_PAREN     reduce using rule 19 (statement -> function_call .)
    COMMA           reduce using rule 19 (statement -> function_call .)


state 21

    (20) statement -> return_statement .

    SEMICOLON       reduce using rule 20 (statement -> return_statement .)
    RIGHT_PAREN     reduce using rule 20 (statement -> return_statement .)
    COMMA           reduce using rule 20 (statement -> return_statement .)


state 22

    (69) if_statement -> IF . parenthesized_condition block
    (70) if_statement -> IF . parenthesized_condition block else_if_extended
    (71) if_statement -> IF . parenthesized_condition block else_if_extended if_part3
    (72) if_statement -> IF . parenthesized_condition block if_part3
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 41

    parenthesized_condition        shift and go to state 40

state 23

    (77) while_statement -> WHILE . parenthesized_condition block
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 41

    parenthesized_condition        shift and go to state 42

state 24

    (80) for_statement -> for_part1 . condition for_part3
    (81) for_statement -> for_part1 . for_part3
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (82) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (83) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN

    SEMICOLON       shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    ID              shift and go to state 36
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    condition                      shift and go to state 43
    for_part3                      shift and go to state 44
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53
    expression                     shift and go to state 56
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 25

    (21) function_statement -> FUNCTION . NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> FUNCTION . NAME LEFT_PAREN RIGHT_PAREN block

    NAME            shift and go to state 61


state 26

    (119) function_call -> NAME . LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> NAME . LEFT_PAREN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 62


state 27

    (131) class_declaration -> CLASS . NAME LEFT_BRACE class_statements RIGHT_BRACE
    (132) class_declaration -> CLASS . NAME LEFT_BRACE RIGHT_BRACE

    NAME            shift and go to state 63


state 28

    (41) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> print_function . arguments
    (45) arguments -> . argument
    (46) arguments -> . arguments DOT argument
    (47) arguments -> . arguments COMMA argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    LEFT_PAREN      shift and go to state 64
    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    arguments                      shift and go to state 65
    argument                       shift and go to state 66
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 29

    (27) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 81


state 30

    (26) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 82


state 31

    (31) assignment_statement -> variable . CALL NAME assignment_operator argument
    (32) assignment_statement -> variable . assignment_operator argument
    (33) assignment_statement -> variable . PLUS_PLUS
    (34) assignment_statement -> variable . MINUS_MINUS
    (121) array_declaration_statement -> variable . EQUALS array
    (35) assignment_operator -> . EQUALS
    (36) assignment_operator -> . PLUS_EQUALS
    (37) assignment_operator -> . MINUS_EQUALS
    (38) assignment_operator -> . TIMES_EQUALS
    (39) assignment_operator -> . DIVIDE_EQUALS
    (40) assignment_operator -> . MOD_EQUALS

    CALL            shift and go to state 83
    PLUS_PLUS       shift and go to state 85
    MINUS_MINUS     shift and go to state 86
    EQUALS          shift and go to state 87
    PLUS_EQUALS     shift and go to state 88
    MINUS_EQUALS    shift and go to state 89
    TIMES_EQUALS    shift and go to state 90
    DIVIDE_EQUALS   shift and go to state 91
    MOD_EQUALS      shift and go to state 92

    assignment_operator            shift and go to state 84

state 32

    (25) return_statement -> RETURN . arguments
    (45) arguments -> . argument
    (46) arguments -> . arguments DOT argument
    (47) arguments -> . arguments COMMA argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    arguments                      shift and go to state 93
    argument                       shift and go to state 66
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 33

    (78) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (79) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 95


state 34

    (43) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 43 (print_function -> PRINT .)
    STRING          reduce using rule 43 (print_function -> PRINT .)
    ID              reduce using rule 43 (print_function -> PRINT .)
    ARRAY           reduce using rule 43 (print_function -> PRINT .)
    LEFT_BRACKET    reduce using rule 43 (print_function -> PRINT .)
    NAME            reduce using rule 43 (print_function -> PRINT .)
    FGETS           reduce using rule 43 (print_function -> PRINT .)
    NEW             reduce using rule 43 (print_function -> PRINT .)
    INTEGER         reduce using rule 43 (print_function -> PRINT .)
    FLOAT           reduce using rule 43 (print_function -> PRINT .)
    TRUE            reduce using rule 43 (print_function -> PRINT .)
    FALSE           reduce using rule 43 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 43 (print_function -> PRINT .)


state 35

    (44) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 44 (print_function -> ECHO .)
    STRING          reduce using rule 44 (print_function -> ECHO .)
    ID              reduce using rule 44 (print_function -> ECHO .)
    ARRAY           reduce using rule 44 (print_function -> ECHO .)
    LEFT_BRACKET    reduce using rule 44 (print_function -> ECHO .)
    NAME            reduce using rule 44 (print_function -> ECHO .)
    FGETS           reduce using rule 44 (print_function -> ECHO .)
    NEW             reduce using rule 44 (print_function -> ECHO .)
    INTEGER         reduce using rule 44 (print_function -> ECHO .)
    FLOAT           reduce using rule 44 (print_function -> ECHO .)
    TRUE            reduce using rule 44 (print_function -> ECHO .)
    FALSE           reduce using rule 44 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 44 (print_function -> ECHO .)


state 36

    (30) variable -> ID .

    CALL            reduce using rule 30 (variable -> ID .)
    PLUS_PLUS       reduce using rule 30 (variable -> ID .)
    MINUS_MINUS     reduce using rule 30 (variable -> ID .)
    EQUALS          reduce using rule 30 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 30 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 30 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 30 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 30 (variable -> ID .)
    MOD_EQUALS      reduce using rule 30 (variable -> ID .)
    SEMICOLON       reduce using rule 30 (variable -> ID .)
    LOGICAL_AND     reduce using rule 30 (variable -> ID .)
    LOGICAL_OR      reduce using rule 30 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 30 (variable -> ID .)
    TIMES           reduce using rule 30 (variable -> ID .)
    DIVIDE          reduce using rule 30 (variable -> ID .)
    PLUS            reduce using rule 30 (variable -> ID .)
    MINUS           reduce using rule 30 (variable -> ID .)
    EQUAL_TO        reduce using rule 30 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 30 (variable -> ID .)
    LESS_THAN       reduce using rule 30 (variable -> ID .)
    GREATER_THAN    reduce using rule 30 (variable -> ID .)
    LESS_EQUAL      reduce using rule 30 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 30 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 30 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 30 (variable -> ID .)
    DIFFERENT       reduce using rule 30 (variable -> ID .)
    LEFT_BRACKET    reduce using rule 30 (variable -> ID .)
    DOT             reduce using rule 30 (variable -> ID .)
    COMMA           reduce using rule 30 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 30 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 30 (variable -> ID .)


state 37

    (1) program -> OPEN_TAG statements CLOSE_TAG .

    $end            reduce using rule 1 (program -> OPEN_TAG statements CLOSE_TAG .)


state 38

    (3) statements -> statements statement2 .

    CLOSE_TAG       reduce using rule 3 (statements -> statements statement2 .)
    ONE_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    MULTI_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    BREAK           reduce using rule 3 (statements -> statements statement2 .)
    CONTINUE        reduce using rule 3 (statements -> statements statement2 .)
    IF              reduce using rule 3 (statements -> statements statement2 .)
    WHILE           reduce using rule 3 (statements -> statements statement2 .)
    FUNCTION        reduce using rule 3 (statements -> statements statement2 .)
    CLASS           reduce using rule 3 (statements -> statements statement2 .)
    FSCANF          reduce using rule 3 (statements -> statements statement2 .)
    FGETS           reduce using rule 3 (statements -> statements statement2 .)
    NAME            reduce using rule 3 (statements -> statements statement2 .)
    RETURN          reduce using rule 3 (statements -> statements statement2 .)
    FOR             reduce using rule 3 (statements -> statements statement2 .)
    PRINT           reduce using rule 3 (statements -> statements statement2 .)
    ECHO            reduce using rule 3 (statements -> statements statement2 .)
    ID              reduce using rule 3 (statements -> statements statement2 .)
    RIGHT_BRACE     reduce using rule 3 (statements -> statements statement2 .)


state 39

    (4) statement2 -> statement SEMICOLON .

    CLOSE_TAG       reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    BREAK           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    IF              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CLASS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FSCANF          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FGETS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    NAME            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RETURN          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FOR             reduce using rule 4 (statement2 -> statement SEMICOLON .)
    PRINT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ECHO            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ID              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RIGHT_BRACE     reduce using rule 4 (statement2 -> statement SEMICOLON .)


state 40

    (69) if_statement -> IF parenthesized_condition . block
    (70) if_statement -> IF parenthesized_condition . block else_if_extended
    (71) if_statement -> IF parenthesized_condition . block else_if_extended if_part3
    (72) if_statement -> IF parenthesized_condition . block if_part3
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 97

    block                          shift and go to state 96

state 41

    (102) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    ID              shift and go to state 36
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    condition                      shift and go to state 98
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53
    expression                     shift and go to state 56
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 42

    (77) while_statement -> WHILE parenthesized_condition . block
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 97

    block                          shift and go to state 99

state 43

    (80) for_statement -> for_part1 condition . for_part3
    (101) complex_condition -> condition . logical_operator condition
    (67) factor -> condition .
    (82) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (83) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (113) logical_operator -> . LOGICAL_AND
    (114) logical_operator -> . LOGICAL_OR
    (115) logical_operator -> . LOGICAL_XOR

    TIMES           reduce using rule 67 (factor -> condition .)
    DIVIDE          reduce using rule 67 (factor -> condition .)
    PLUS            reduce using rule 67 (factor -> condition .)
    MINUS           reduce using rule 67 (factor -> condition .)
    EQUAL_TO        reduce using rule 67 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 67 (factor -> condition .)
    LESS_THAN       reduce using rule 67 (factor -> condition .)
    GREATER_THAN    reduce using rule 67 (factor -> condition .)
    LESS_EQUAL      reduce using rule 67 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 67 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 67 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 67 (factor -> condition .)
    DIFFERENT       reduce using rule 67 (factor -> condition .)
    SEMICOLON       shift and go to state 49
    LOGICAL_AND     shift and go to state 102
    LOGICAL_OR      shift and go to state 103
    LOGICAL_XOR     shift and go to state 104

    for_part3                      shift and go to state 100
    logical_operator               shift and go to state 101

state 44

    (81) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    FUNCTION        reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    CLASS           reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    NAME            reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    RETURN          reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 81 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 81 (for_statement -> for_part1 for_part3 .)


state 45

    (92) condition -> simple_condition .

    SEMICOLON       reduce using rule 92 (condition -> simple_condition .)
    LOGICAL_AND     reduce using rule 92 (condition -> simple_condition .)
    LOGICAL_OR      reduce using rule 92 (condition -> simple_condition .)
    LOGICAL_XOR     reduce using rule 92 (condition -> simple_condition .)
    TIMES           reduce using rule 92 (condition -> simple_condition .)
    DIVIDE          reduce using rule 92 (condition -> simple_condition .)
    PLUS            reduce using rule 92 (condition -> simple_condition .)
    MINUS           reduce using rule 92 (condition -> simple_condition .)
    EQUAL_TO        reduce using rule 92 (condition -> simple_condition .)
    NOT_EQUAL_TO    reduce using rule 92 (condition -> simple_condition .)
    LESS_THAN       reduce using rule 92 (condition -> simple_condition .)
    GREATER_THAN    reduce using rule 92 (condition -> simple_condition .)
    LESS_EQUAL      reduce using rule 92 (condition -> simple_condition .)
    GREATER_EQUAL   reduce using rule 92 (condition -> simple_condition .)
    IDENTICAL_TO    reduce using rule 92 (condition -> simple_condition .)
    NOT_IDENTICAL_TO reduce using rule 92 (condition -> simple_condition .)
    DIFFERENT       reduce using rule 92 (condition -> simple_condition .)
    DOT             reduce using rule 92 (condition -> simple_condition .)
    COMMA           reduce using rule 92 (condition -> simple_condition .)
    RIGHT_PAREN     reduce using rule 92 (condition -> simple_condition .)
    RIGHT_BRACKET   reduce using rule 92 (condition -> simple_condition .)


state 46

    (93) condition -> negated_condition .

    SEMICOLON       reduce using rule 93 (condition -> negated_condition .)
    LOGICAL_AND     reduce using rule 93 (condition -> negated_condition .)
    LOGICAL_OR      reduce using rule 93 (condition -> negated_condition .)
    LOGICAL_XOR     reduce using rule 93 (condition -> negated_condition .)
    TIMES           reduce using rule 93 (condition -> negated_condition .)
    DIVIDE          reduce using rule 93 (condition -> negated_condition .)
    PLUS            reduce using rule 93 (condition -> negated_condition .)
    MINUS           reduce using rule 93 (condition -> negated_condition .)
    EQUAL_TO        reduce using rule 93 (condition -> negated_condition .)
    NOT_EQUAL_TO    reduce using rule 93 (condition -> negated_condition .)
    LESS_THAN       reduce using rule 93 (condition -> negated_condition .)
    GREATER_THAN    reduce using rule 93 (condition -> negated_condition .)
    LESS_EQUAL      reduce using rule 93 (condition -> negated_condition .)
    GREATER_EQUAL   reduce using rule 93 (condition -> negated_condition .)
    IDENTICAL_TO    reduce using rule 93 (condition -> negated_condition .)
    NOT_IDENTICAL_TO reduce using rule 93 (condition -> negated_condition .)
    DIFFERENT       reduce using rule 93 (condition -> negated_condition .)
    DOT             reduce using rule 93 (condition -> negated_condition .)
    COMMA           reduce using rule 93 (condition -> negated_condition .)
    RIGHT_PAREN     reduce using rule 93 (condition -> negated_condition .)
    RIGHT_BRACKET   reduce using rule 93 (condition -> negated_condition .)


state 47

    (94) condition -> complex_condition .

    SEMICOLON       reduce using rule 94 (condition -> complex_condition .)
    LOGICAL_AND     reduce using rule 94 (condition -> complex_condition .)
    LOGICAL_OR      reduce using rule 94 (condition -> complex_condition .)
    LOGICAL_XOR     reduce using rule 94 (condition -> complex_condition .)
    TIMES           reduce using rule 94 (condition -> complex_condition .)
    DIVIDE          reduce using rule 94 (condition -> complex_condition .)
    PLUS            reduce using rule 94 (condition -> complex_condition .)
    MINUS           reduce using rule 94 (condition -> complex_condition .)
    EQUAL_TO        reduce using rule 94 (condition -> complex_condition .)
    NOT_EQUAL_TO    reduce using rule 94 (condition -> complex_condition .)
    LESS_THAN       reduce using rule 94 (condition -> complex_condition .)
    GREATER_THAN    reduce using rule 94 (condition -> complex_condition .)
    LESS_EQUAL      reduce using rule 94 (condition -> complex_condition .)
    GREATER_EQUAL   reduce using rule 94 (condition -> complex_condition .)
    IDENTICAL_TO    reduce using rule 94 (condition -> complex_condition .)
    NOT_IDENTICAL_TO reduce using rule 94 (condition -> complex_condition .)
    DIFFERENT       reduce using rule 94 (condition -> complex_condition .)
    DOT             reduce using rule 94 (condition -> complex_condition .)
    COMMA           reduce using rule 94 (condition -> complex_condition .)
    RIGHT_PAREN     reduce using rule 94 (condition -> complex_condition .)
    RIGHT_BRACKET   reduce using rule 94 (condition -> complex_condition .)


state 48

    (95) condition -> parenthesized_condition .

    SEMICOLON       reduce using rule 95 (condition -> parenthesized_condition .)
    LOGICAL_AND     reduce using rule 95 (condition -> parenthesized_condition .)
    LOGICAL_OR      reduce using rule 95 (condition -> parenthesized_condition .)
    LOGICAL_XOR     reduce using rule 95 (condition -> parenthesized_condition .)
    TIMES           reduce using rule 95 (condition -> parenthesized_condition .)
    DIVIDE          reduce using rule 95 (condition -> parenthesized_condition .)
    PLUS            reduce using rule 95 (condition -> parenthesized_condition .)
    MINUS           reduce using rule 95 (condition -> parenthesized_condition .)
    EQUAL_TO        reduce using rule 95 (condition -> parenthesized_condition .)
    NOT_EQUAL_TO    reduce using rule 95 (condition -> parenthesized_condition .)
    LESS_THAN       reduce using rule 95 (condition -> parenthesized_condition .)
    GREATER_THAN    reduce using rule 95 (condition -> parenthesized_condition .)
    LESS_EQUAL      reduce using rule 95 (condition -> parenthesized_condition .)
    GREATER_EQUAL   reduce using rule 95 (condition -> parenthesized_condition .)
    IDENTICAL_TO    reduce using rule 95 (condition -> parenthesized_condition .)
    NOT_IDENTICAL_TO reduce using rule 95 (condition -> parenthesized_condition .)
    DIFFERENT       reduce using rule 95 (condition -> parenthesized_condition .)
    DOT             reduce using rule 95 (condition -> parenthesized_condition .)
    COMMA           reduce using rule 95 (condition -> parenthesized_condition .)
    RIGHT_PAREN     reduce using rule 95 (condition -> parenthesized_condition .)
    RIGHT_BRACKET   reduce using rule 95 (condition -> parenthesized_condition .)


state 49

    (82) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (83) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (88) statement_list -> . statement
    (89) statement_list -> . statement_list COMMA statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (41) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> . print_function arguments
    (27) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (121) array_declaration_statement -> . variable EQUALS array
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (25) return_statement -> . RETURN arguments
    (43) print_function -> . PRINT
    (44) print_function -> . ECHO
    (30) variable -> . ID

    RIGHT_PAREN     shift and go to state 106
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 29
    FGETS           shift and go to state 30
    NAME            shift and go to state 26
    RETURN          shift and go to state 32
    PRINT           shift and go to state 34
    ECHO            shift and go to state 35
    ID              shift and go to state 36

    statement_list                 shift and go to state 105
    statement                      shift and go to state 107
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    print_function                 shift and go to state 28
    variable                       shift and go to state 31

state 50

    (96) simple_condition -> TRUE .

    SEMICOLON       reduce using rule 96 (simple_condition -> TRUE .)
    LOGICAL_AND     reduce using rule 96 (simple_condition -> TRUE .)
    LOGICAL_OR      reduce using rule 96 (simple_condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 96 (simple_condition -> TRUE .)
    TIMES           reduce using rule 96 (simple_condition -> TRUE .)
    DIVIDE          reduce using rule 96 (simple_condition -> TRUE .)
    PLUS            reduce using rule 96 (simple_condition -> TRUE .)
    MINUS           reduce using rule 96 (simple_condition -> TRUE .)
    EQUAL_TO        reduce using rule 96 (simple_condition -> TRUE .)
    NOT_EQUAL_TO    reduce using rule 96 (simple_condition -> TRUE .)
    LESS_THAN       reduce using rule 96 (simple_condition -> TRUE .)
    GREATER_THAN    reduce using rule 96 (simple_condition -> TRUE .)
    LESS_EQUAL      reduce using rule 96 (simple_condition -> TRUE .)
    GREATER_EQUAL   reduce using rule 96 (simple_condition -> TRUE .)
    IDENTICAL_TO    reduce using rule 96 (simple_condition -> TRUE .)
    NOT_IDENTICAL_TO reduce using rule 96 (simple_condition -> TRUE .)
    DIFFERENT       reduce using rule 96 (simple_condition -> TRUE .)
    DOT             reduce using rule 96 (simple_condition -> TRUE .)
    COMMA           reduce using rule 96 (simple_condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 96 (simple_condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 96 (simple_condition -> TRUE .)


state 51

    (97) simple_condition -> FALSE .

    SEMICOLON       reduce using rule 97 (simple_condition -> FALSE .)
    LOGICAL_AND     reduce using rule 97 (simple_condition -> FALSE .)
    LOGICAL_OR      reduce using rule 97 (simple_condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 97 (simple_condition -> FALSE .)
    TIMES           reduce using rule 97 (simple_condition -> FALSE .)
    DIVIDE          reduce using rule 97 (simple_condition -> FALSE .)
    PLUS            reduce using rule 97 (simple_condition -> FALSE .)
    MINUS           reduce using rule 97 (simple_condition -> FALSE .)
    EQUAL_TO        reduce using rule 97 (simple_condition -> FALSE .)
    NOT_EQUAL_TO    reduce using rule 97 (simple_condition -> FALSE .)
    LESS_THAN       reduce using rule 97 (simple_condition -> FALSE .)
    GREATER_THAN    reduce using rule 97 (simple_condition -> FALSE .)
    LESS_EQUAL      reduce using rule 97 (simple_condition -> FALSE .)
    GREATER_EQUAL   reduce using rule 97 (simple_condition -> FALSE .)
    IDENTICAL_TO    reduce using rule 97 (simple_condition -> FALSE .)
    NOT_IDENTICAL_TO reduce using rule 97 (simple_condition -> FALSE .)
    DIFFERENT       reduce using rule 97 (simple_condition -> FALSE .)
    DOT             reduce using rule 97 (simple_condition -> FALSE .)
    COMMA           reduce using rule 97 (simple_condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 97 (simple_condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 97 (simple_condition -> FALSE .)


state 52

    (98) simple_condition -> variable .

    SEMICOLON       reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 98 (simple_condition -> variable .)
    TIMES           reduce using rule 98 (simple_condition -> variable .)
    DIVIDE          reduce using rule 98 (simple_condition -> variable .)
    PLUS            reduce using rule 98 (simple_condition -> variable .)
    MINUS           reduce using rule 98 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 98 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 98 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 98 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 98 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 98 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 98 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 98 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 98 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 98 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 98 (simple_condition -> variable .)
    DOT             reduce using rule 98 (simple_condition -> variable .)
    COMMA           reduce using rule 98 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 98 (simple_condition -> variable .)


state 53

    (99) simple_condition -> relational_expression .

    SEMICOLON       reduce using rule 99 (simple_condition -> relational_expression .)
    LOGICAL_AND     reduce using rule 99 (simple_condition -> relational_expression .)
    LOGICAL_OR      reduce using rule 99 (simple_condition -> relational_expression .)
    LOGICAL_XOR     reduce using rule 99 (simple_condition -> relational_expression .)
    TIMES           reduce using rule 99 (simple_condition -> relational_expression .)
    DIVIDE          reduce using rule 99 (simple_condition -> relational_expression .)
    PLUS            reduce using rule 99 (simple_condition -> relational_expression .)
    MINUS           reduce using rule 99 (simple_condition -> relational_expression .)
    EQUAL_TO        reduce using rule 99 (simple_condition -> relational_expression .)
    NOT_EQUAL_TO    reduce using rule 99 (simple_condition -> relational_expression .)
    LESS_THAN       reduce using rule 99 (simple_condition -> relational_expression .)
    GREATER_THAN    reduce using rule 99 (simple_condition -> relational_expression .)
    LESS_EQUAL      reduce using rule 99 (simple_condition -> relational_expression .)
    GREATER_EQUAL   reduce using rule 99 (simple_condition -> relational_expression .)
    IDENTICAL_TO    reduce using rule 99 (simple_condition -> relational_expression .)
    NOT_IDENTICAL_TO reduce using rule 99 (simple_condition -> relational_expression .)
    DIFFERENT       reduce using rule 99 (simple_condition -> relational_expression .)
    DOT             reduce using rule 99 (simple_condition -> relational_expression .)
    COMMA           reduce using rule 99 (simple_condition -> relational_expression .)
    RIGHT_PAREN     reduce using rule 99 (simple_condition -> relational_expression .)
    RIGHT_BRACKET   reduce using rule 99 (simple_condition -> relational_expression .)


state 54

    (100) negated_condition -> LOGICAL_NOT . condition
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    ID              shift and go to state 36
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    condition                      shift and go to state 108
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53
    expression                     shift and go to state 56
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 55

    (102) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (68) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    ID              shift and go to state 36
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    condition                      shift and go to state 98
    expression                     shift and go to state 109
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    term                           shift and go to state 57
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53
    factor                         shift and go to state 58

state 56

    (103) relational_expression -> expression . relational_operator expression
    (59) expression -> expression . PLUS term
    (60) expression -> expression . MINUS term
    (104) relational_operator -> . EQUAL_TO
    (105) relational_operator -> . NOT_EQUAL_TO
    (106) relational_operator -> . LESS_THAN
    (107) relational_operator -> . GREATER_THAN
    (108) relational_operator -> . LESS_EQUAL
    (109) relational_operator -> . GREATER_EQUAL
    (110) relational_operator -> . IDENTICAL_TO
    (111) relational_operator -> . NOT_IDENTICAL_TO
    (112) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    EQUAL_TO        shift and go to state 113
    NOT_EQUAL_TO    shift and go to state 114
    LESS_THAN       shift and go to state 115
    GREATER_THAN    shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    IDENTICAL_TO    shift and go to state 119
    NOT_IDENTICAL_TO shift and go to state 120
    DIFFERENT       shift and go to state 121

    relational_operator            shift and go to state 110

state 57

    (61) expression -> term .
    (62) term -> term . TIMES factor
    (63) term -> term . DIVIDE factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 61 (expression -> term .)
    MINUS           reduce using rule 61 (expression -> term .)
    EQUAL_TO        reduce using rule 61 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 61 (expression -> term .)
    LESS_THAN       reduce using rule 61 (expression -> term .)
    GREATER_THAN    reduce using rule 61 (expression -> term .)
    LESS_EQUAL      reduce using rule 61 (expression -> term .)
    GREATER_EQUAL   reduce using rule 61 (expression -> term .)
    IDENTICAL_TO    reduce using rule 61 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 61 (expression -> term .)
    DIFFERENT       reduce using rule 61 (expression -> term .)
    DOT             reduce using rule 61 (expression -> term .)
    COMMA           reduce using rule 61 (expression -> term .)
    SEMICOLON       reduce using rule 61 (expression -> term .)
    RIGHT_PAREN     reduce using rule 61 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 61 (expression -> term .)
    LOGICAL_AND     reduce using rule 61 (expression -> term .)
    LOGICAL_OR      reduce using rule 61 (expression -> term .)
    LOGICAL_XOR     reduce using rule 61 (expression -> term .)
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123

  ! TIMES           [ reduce using rule 61 (expression -> term .) ]
  ! DIVIDE          [ reduce using rule 61 (expression -> term .) ]


state 58

    (64) term -> factor .

    TIMES           reduce using rule 64 (term -> factor .)
    DIVIDE          reduce using rule 64 (term -> factor .)
    PLUS            reduce using rule 64 (term -> factor .)
    MINUS           reduce using rule 64 (term -> factor .)
    EQUAL_TO        reduce using rule 64 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 64 (term -> factor .)
    LESS_THAN       reduce using rule 64 (term -> factor .)
    GREATER_THAN    reduce using rule 64 (term -> factor .)
    LESS_EQUAL      reduce using rule 64 (term -> factor .)
    GREATER_EQUAL   reduce using rule 64 (term -> factor .)
    IDENTICAL_TO    reduce using rule 64 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 64 (term -> factor .)
    DIFFERENT       reduce using rule 64 (term -> factor .)
    DOT             reduce using rule 64 (term -> factor .)
    COMMA           reduce using rule 64 (term -> factor .)
    SEMICOLON       reduce using rule 64 (term -> factor .)
    RIGHT_PAREN     reduce using rule 64 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 64 (term -> factor .)
    LOGICAL_AND     reduce using rule 64 (term -> factor .)
    LOGICAL_OR      reduce using rule 64 (term -> factor .)
    LOGICAL_XOR     reduce using rule 64 (term -> factor .)


state 59

    (65) factor -> INTEGER .

    TIMES           reduce using rule 65 (factor -> INTEGER .)
    DIVIDE          reduce using rule 65 (factor -> INTEGER .)
    PLUS            reduce using rule 65 (factor -> INTEGER .)
    MINUS           reduce using rule 65 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 65 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 65 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 65 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 65 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 65 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 65 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 65 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 65 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 65 (factor -> INTEGER .)
    DOT             reduce using rule 65 (factor -> INTEGER .)
    COMMA           reduce using rule 65 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 65 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 65 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 65 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 65 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 65 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 65 (factor -> INTEGER .)


state 60

    (66) factor -> FLOAT .

    TIMES           reduce using rule 66 (factor -> FLOAT .)
    DIVIDE          reduce using rule 66 (factor -> FLOAT .)
    PLUS            reduce using rule 66 (factor -> FLOAT .)
    MINUS           reduce using rule 66 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 66 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 66 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 66 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 66 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 66 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 66 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 66 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 66 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 66 (factor -> FLOAT .)
    DOT             reduce using rule 66 (factor -> FLOAT .)
    COMMA           reduce using rule 66 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 66 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 66 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 66 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 66 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 66 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 66 (factor -> FLOAT .)


state 61

    (21) function_statement -> FUNCTION NAME . LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> FUNCTION NAME . LEFT_PAREN RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 124


state 62

    (119) function_call -> NAME LEFT_PAREN . arguments RIGHT_PAREN
    (120) function_call -> NAME LEFT_PAREN . RIGHT_PAREN
    (45) arguments -> . argument
    (46) arguments -> . arguments DOT argument
    (47) arguments -> . arguments COMMA argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 126
    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    arguments                      shift and go to state 125
    argument                       shift and go to state 66
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 63

    (131) class_declaration -> CLASS NAME . LEFT_BRACE class_statements RIGHT_BRACE
    (132) class_declaration -> CLASS NAME . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 127


state 64

    (41) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (116) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (68) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (102) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (45) arguments -> . argument
    (46) arguments -> . arguments DOT argument
    (47) arguments -> . arguments COMMA argument
    (117) casting_type -> . INT_TYPE
    (118) casting_type -> . FLOAT_TYPE
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 132
    FLOAT_TYPE      shift and go to state 133
    STRING          shift and go to state 67
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 128
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    arguments                      shift and go to state 129
    casting_type                   shift and go to state 130
    expression                     shift and go to state 131
    condition                      shift and go to state 98
    argument                       shift and go to state 66
    term                           shift and go to state 57
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 134
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    factor                         shift and go to state 58
    relational_expression          shift and go to state 53

state 65

    (42) print_statement -> print_function arguments .
    (46) arguments -> arguments . DOT argument
    (47) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 42 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 42 (print_statement -> print_function arguments .)
    DOT             shift and go to state 135
    COMMA           shift and go to state 136

  ! COMMA           [ reduce using rule 42 (print_statement -> print_function arguments .) ]


state 66

    (45) arguments -> argument .

    DOT             reduce using rule 45 (arguments -> argument .)
    COMMA           reduce using rule 45 (arguments -> argument .)
    SEMICOLON       reduce using rule 45 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 45 (arguments -> argument .)


state 67

    (48) argument -> STRING .

    DOT             reduce using rule 48 (argument -> STRING .)
    COMMA           reduce using rule 48 (argument -> STRING .)
    SEMICOLON       reduce using rule 48 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 48 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 48 (argument -> STRING .)


state 68

    (49) argument -> expression .
    (59) expression -> expression . PLUS term
    (60) expression -> expression . MINUS term
    (103) relational_expression -> expression . relational_operator expression
    (104) relational_operator -> . EQUAL_TO
    (105) relational_operator -> . NOT_EQUAL_TO
    (106) relational_operator -> . LESS_THAN
    (107) relational_operator -> . GREATER_THAN
    (108) relational_operator -> . LESS_EQUAL
    (109) relational_operator -> . GREATER_EQUAL
    (110) relational_operator -> . IDENTICAL_TO
    (111) relational_operator -> . NOT_IDENTICAL_TO
    (112) relational_operator -> . DIFFERENT

    DOT             reduce using rule 49 (argument -> expression .)
    COMMA           reduce using rule 49 (argument -> expression .)
    SEMICOLON       reduce using rule 49 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 49 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 49 (argument -> expression .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    EQUAL_TO        shift and go to state 113
    NOT_EQUAL_TO    shift and go to state 114
    LESS_THAN       shift and go to state 115
    GREATER_THAN    shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    IDENTICAL_TO    shift and go to state 119
    NOT_IDENTICAL_TO shift and go to state 120
    DIFFERENT       shift and go to state 121

    relational_operator            shift and go to state 110

state 69

    (50) argument -> assignment_statement .

    DOT             reduce using rule 50 (argument -> assignment_statement .)
    COMMA           reduce using rule 50 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 50 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 50 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 50 (argument -> assignment_statement .)


state 70

    (51) argument -> variable . CALL NAME
    (52) argument -> variable . CALL function_call
    (31) assignment_statement -> variable . CALL NAME assignment_operator argument
    (32) assignment_statement -> variable . assignment_operator argument
    (33) assignment_statement -> variable . PLUS_PLUS
    (34) assignment_statement -> variable . MINUS_MINUS
    (130) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (98) simple_condition -> variable .
    (35) assignment_operator -> . EQUALS
    (36) assignment_operator -> . PLUS_EQUALS
    (37) assignment_operator -> . MINUS_EQUALS
    (38) assignment_operator -> . TIMES_EQUALS
    (39) assignment_operator -> . DIVIDE_EQUALS
    (40) assignment_operator -> . MOD_EQUALS

    CALL            shift and go to state 137
    PLUS_PLUS       shift and go to state 85
    MINUS_MINUS     shift and go to state 86
    LEFT_BRACKET    shift and go to state 138
    LOGICAL_AND     reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 98 (simple_condition -> variable .)
    TIMES           reduce using rule 98 (simple_condition -> variable .)
    DIVIDE          reduce using rule 98 (simple_condition -> variable .)
    PLUS            reduce using rule 98 (simple_condition -> variable .)
    MINUS           reduce using rule 98 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 98 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 98 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 98 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 98 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 98 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 98 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 98 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 98 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 98 (simple_condition -> variable .)
    DOT             reduce using rule 98 (simple_condition -> variable .)
    COMMA           reduce using rule 98 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 98 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 98 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 98 (simple_condition -> variable .)
    EQUALS          shift and go to state 139
    PLUS_EQUALS     shift and go to state 88
    MINUS_EQUALS    shift and go to state 89
    TIMES_EQUALS    shift and go to state 90
    DIVIDE_EQUALS   shift and go to state 91
    MOD_EQUALS      shift and go to state 92

    assignment_operator            shift and go to state 84

state 71

    (54) argument -> function_call .

    DOT             reduce using rule 54 (argument -> function_call .)
    COMMA           reduce using rule 54 (argument -> function_call .)
    SEMICOLON       reduce using rule 54 (argument -> function_call .)
    RIGHT_PAREN     reduce using rule 54 (argument -> function_call .)
    RIGHT_BRACKET   reduce using rule 54 (argument -> function_call .)


state 72

    (53) argument -> array .

    DOT             reduce using rule 53 (argument -> array .)
    COMMA           reduce using rule 53 (argument -> array .)
    SEMICOLON       reduce using rule 53 (argument -> array .)
    RIGHT_PAREN     reduce using rule 53 (argument -> array .)
    RIGHT_BRACKET   reduce using rule 53 (argument -> array .)


state 73

    (55) argument -> fgets_statement .

    DOT             reduce using rule 55 (argument -> fgets_statement .)
    COMMA           reduce using rule 55 (argument -> fgets_statement .)
    SEMICOLON       reduce using rule 55 (argument -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 55 (argument -> fgets_statement .)
    RIGHT_BRACKET   reduce using rule 55 (argument -> fgets_statement .)


state 74

    (56) argument -> array_indexing .

    DOT             reduce using rule 56 (argument -> array_indexing .)
    COMMA           reduce using rule 56 (argument -> array_indexing .)
    SEMICOLON       reduce using rule 56 (argument -> array_indexing .)
    RIGHT_PAREN     reduce using rule 56 (argument -> array_indexing .)
    RIGHT_BRACKET   reduce using rule 56 (argument -> array_indexing .)


state 75

    (57) argument -> casting . argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    casting                        shift and go to state 75
    argument                       shift and go to state 140
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 76

    (58) argument -> object_creation .

    DOT             reduce using rule 58 (argument -> object_creation .)
    COMMA           reduce using rule 58 (argument -> object_creation .)
    SEMICOLON       reduce using rule 58 (argument -> object_creation .)
    RIGHT_PAREN     reduce using rule 58 (argument -> object_creation .)
    RIGHT_BRACKET   reduce using rule 58 (argument -> object_creation .)


state 77

    (122) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 141


state 78

    (123) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (124) array_elements -> . array_argument
    (125) array_elements -> . array_elements COMMA array_argument
    (126) array_argument -> . argument
    (127) array_argument -> . clave KEY_VALUE argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (128) clave -> . STRING
    (129) clave -> . INTEGER
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 146
    INTEGER         shift and go to state 147
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    array_elements                 shift and go to state 142
    array_argument                 shift and go to state 143
    argument                       shift and go to state 144
    clave                          shift and go to state 145
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 79

    (144) object_creation -> NEW . NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> NEW . NAME LEFT_PAREN arguments RIGHT_PAREN

    NAME            shift and go to state 148


state 80

    (67) factor -> condition .
    (101) complex_condition -> condition . logical_operator condition
    (113) logical_operator -> . LOGICAL_AND
    (114) logical_operator -> . LOGICAL_OR
    (115) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    TIMES           reduce using rule 67 (factor -> condition .)
    DIVIDE          reduce using rule 67 (factor -> condition .)
    PLUS            reduce using rule 67 (factor -> condition .)
    MINUS           reduce using rule 67 (factor -> condition .)
    EQUAL_TO        reduce using rule 67 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 67 (factor -> condition .)
    LESS_THAN       reduce using rule 67 (factor -> condition .)
    GREATER_THAN    reduce using rule 67 (factor -> condition .)
    LESS_EQUAL      reduce using rule 67 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 67 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 67 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 67 (factor -> condition .)
    DIFFERENT       reduce using rule 67 (factor -> condition .)
    DOT             reduce using rule 67 (factor -> condition .)
    COMMA           reduce using rule 67 (factor -> condition .)
    SEMICOLON       reduce using rule 67 (factor -> condition .)
    RIGHT_PAREN     reduce using rule 67 (factor -> condition .)
    RIGHT_BRACKET   reduce using rule 67 (factor -> condition .)
    LOGICAL_AND     shift and go to state 102
    LOGICAL_OR      shift and go to state 103
    LOGICAL_XOR     shift and go to state 104

  ! LOGICAL_AND     [ reduce using rule 67 (factor -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 67 (factor -> condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 67 (factor -> condition .) ]

    logical_operator               shift and go to state 101

state 81

    (27) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 149


state 82

    (26) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 150


state 83

    (31) assignment_statement -> variable CALL . NAME assignment_operator argument

    NAME            shift and go to state 151


state 84

    (32) assignment_statement -> variable assignment_operator . argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    variable                       shift and go to state 70
    argument                       shift and go to state 152
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 85

    (33) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 33 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 33 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 33 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 33 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 33 (assignment_statement -> variable PLUS_PLUS .)


state 86

    (34) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 34 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 34 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 34 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 34 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 34 (assignment_statement -> variable MINUS_MINUS .)


state 87

    (121) array_declaration_statement -> variable EQUALS . array
    (35) assignment_operator -> EQUALS .
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for LEFT_BRACKET resolved as shift
    STRING          reduce using rule 35 (assignment_operator -> EQUALS .)
    ID              reduce using rule 35 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 35 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 35 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 35 (assignment_operator -> EQUALS .)
    NEW             reduce using rule 35 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 35 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 35 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 35 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 35 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 35 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78

  ! ARRAY           [ reduce using rule 35 (assignment_operator -> EQUALS .) ]
  ! LEFT_BRACKET    [ reduce using rule 35 (assignment_operator -> EQUALS .) ]

    array                          shift and go to state 153

state 88

    (36) assignment_operator -> PLUS_EQUALS .

    STRING          reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    ARRAY           reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    LEFT_BRACKET    reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    NAME            reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    FGETS           reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    NEW             reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    INTEGER         reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 36 (assignment_operator -> PLUS_EQUALS .)


state 89

    (37) assignment_operator -> MINUS_EQUALS .

    STRING          reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    ARRAY           reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    LEFT_BRACKET    reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    NAME            reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    FGETS           reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    NEW             reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    INTEGER         reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 37 (assignment_operator -> MINUS_EQUALS .)


state 90

    (38) assignment_operator -> TIMES_EQUALS .

    STRING          reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    ARRAY           reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    LEFT_BRACKET    reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    NAME            reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    FGETS           reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    NEW             reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    INTEGER         reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 38 (assignment_operator -> TIMES_EQUALS .)


state 91

    (39) assignment_operator -> DIVIDE_EQUALS .

    STRING          reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    ARRAY           reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_BRACKET    reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    NAME            reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    FGETS           reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    NEW             reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    INTEGER         reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 39 (assignment_operator -> DIVIDE_EQUALS .)


state 92

    (40) assignment_operator -> MOD_EQUALS .

    STRING          reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    ARRAY           reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    LEFT_BRACKET    reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    NAME            reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    FGETS           reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    NEW             reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    INTEGER         reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 40 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 40 (assignment_operator -> MOD_EQUALS .)


state 93

    (25) return_statement -> RETURN arguments .
    (46) arguments -> arguments . DOT argument
    (47) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 25 (return_statement -> RETURN arguments .)
    RIGHT_PAREN     reduce using rule 25 (return_statement -> RETURN arguments .)
    DOT             shift and go to state 135
    COMMA           shift and go to state 136

  ! COMMA           [ reduce using rule 25 (return_statement -> RETURN arguments .) ]


state 94

    (116) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (68) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (102) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (117) casting_type -> . INT_TYPE
    (118) casting_type -> . FLOAT_TYPE
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 132
    FLOAT_TYPE      shift and go to state 133
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    ID              shift and go to state 36

    casting_type                   shift and go to state 130
    expression                     shift and go to state 109
    condition                      shift and go to state 98
    term                           shift and go to state 57
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    factor                         shift and go to state 58
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 95

    (78) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (79) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (86) assignment_list -> . assignment_statement
    (87) assignment_list -> . assignment_list COMMA assignment_statement
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID

    SEMICOLON       shift and go to state 155
    ID              shift and go to state 36

    assignment_list                shift and go to state 154
    assignment_statement           shift and go to state 156
    variable                       shift and go to state 157

state 96

    (69) if_statement -> IF parenthesized_condition block .
    (70) if_statement -> IF parenthesized_condition block . else_if_extended
    (71) if_statement -> IF parenthesized_condition block . else_if_extended if_part3
    (72) if_statement -> IF parenthesized_condition block . if_part3
    (73) else_if_extended -> . if_part2
    (74) else_if_extended -> . else_if_extended if_part2
    (76) if_part3 -> . ELSE block
    (75) if_part2 -> . ELSEIF parenthesized_condition block

    CLOSE_TAG       reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    BREAK           reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    CONTINUE        reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    IF              reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    WHILE           reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    FUNCTION        reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    CLASS           reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    FSCANF          reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    FGETS           reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    NAME            reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    RETURN          reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    FOR             reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    PRINT           reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    ECHO            reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    ID              reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 69 (if_statement -> IF parenthesized_condition block .)
    ELSE            shift and go to state 161
    ELSEIF          shift and go to state 162

    else_if_extended               shift and go to state 158
    if_part3                       shift and go to state 159
    if_part2                       shift and go to state 160

state 97

    (90) block -> LEFT_BRACE . statements RIGHT_BRACE
    (91) block -> LEFT_BRACE . RIGHT_BRACE
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (69) if_statement -> . IF parenthesized_condition block
    (70) if_statement -> . IF parenthesized_condition block else_if_extended
    (71) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (72) if_statement -> . IF parenthesized_condition block if_part3
    (77) while_statement -> . WHILE parenthesized_condition block
    (80) for_statement -> . for_part1 condition for_part3
    (81) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (131) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (132) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (41) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> . print_function arguments
    (27) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (121) array_declaration_statement -> . variable EQUALS array
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (25) return_statement -> . RETURN arguments
    (78) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (79) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (43) print_function -> . PRINT
    (44) print_function -> . ECHO
    (30) variable -> . ID

    RIGHT_BRACE     shift and go to state 164
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FUNCTION        shift and go to state 25
    CLASS           shift and go to state 27
    FSCANF          shift and go to state 29
    FGETS           shift and go to state 30
    NAME            shift and go to state 26
    RETURN          shift and go to state 32
    FOR             shift and go to state 33
    PRINT           shift and go to state 34
    ECHO            shift and go to state 35
    ID              shift and go to state 36

    statements                     shift and go to state 163
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    for_part1                      shift and go to state 24
    print_function                 shift and go to state 28
    variable                       shift and go to state 31

state 98

    (102) parenthesized_condition -> LEFT_PAREN condition . RIGHT_PAREN
    (101) complex_condition -> condition . logical_operator condition
    (67) factor -> condition .
    (113) logical_operator -> . LOGICAL_AND
    (114) logical_operator -> . LOGICAL_OR
    (115) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 165
    TIMES           reduce using rule 67 (factor -> condition .)
    DIVIDE          reduce using rule 67 (factor -> condition .)
    PLUS            reduce using rule 67 (factor -> condition .)
    MINUS           reduce using rule 67 (factor -> condition .)
    EQUAL_TO        reduce using rule 67 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 67 (factor -> condition .)
    LESS_THAN       reduce using rule 67 (factor -> condition .)
    GREATER_THAN    reduce using rule 67 (factor -> condition .)
    LESS_EQUAL      reduce using rule 67 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 67 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 67 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 67 (factor -> condition .)
    DIFFERENT       reduce using rule 67 (factor -> condition .)
    DOT             reduce using rule 67 (factor -> condition .)
    COMMA           reduce using rule 67 (factor -> condition .)
    LOGICAL_AND     shift and go to state 102
    LOGICAL_OR      shift and go to state 103
    LOGICAL_XOR     shift and go to state 104

  ! RIGHT_PAREN     [ reduce using rule 67 (factor -> condition .) ]

    logical_operator               shift and go to state 101

state 99

    (77) while_statement -> WHILE parenthesized_condition block .

    CLOSE_TAG       reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    BREAK           reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    CONTINUE        reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    IF              reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    WHILE           reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    FUNCTION        reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    CLASS           reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    FSCANF          reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    FGETS           reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    NAME            reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    RETURN          reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    FOR             reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    PRINT           reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    ECHO            reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    ID              reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 77 (while_statement -> WHILE parenthesized_condition block .)


state 100

    (80) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    FUNCTION        reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    CLASS           reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    NAME            reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    RETURN          reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 80 (for_statement -> for_part1 condition for_part3 .)


state 101

    (101) complex_condition -> condition logical_operator . condition
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    ID              shift and go to state 36
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    condition                      shift and go to state 166
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53
    expression                     shift and go to state 56
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 102

    (113) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 113 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 113 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 113 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 113 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 113 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 113 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 113 (logical_operator -> LOGICAL_AND .)


state 103

    (114) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 114 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 114 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 114 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 114 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 114 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 114 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 114 (logical_operator -> LOGICAL_OR .)


state 104

    (115) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 115 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 115 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 115 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 115 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 115 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 115 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 115 (logical_operator -> LOGICAL_XOR .)


state 105

    (82) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (89) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 167
    COMMA           shift and go to state 168


state 106

    (83) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (84) for_part4 -> . block
    (85) for_part4 -> . SEMICOLON
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 169
    LEFT_BRACE      shift and go to state 97

    for_part4                      shift and go to state 170
    block                          shift and go to state 171

state 107

    (88) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 88 (statement_list -> statement .)
    COMMA           reduce using rule 88 (statement_list -> statement .)


state 108

    (100) negated_condition -> LOGICAL_NOT condition .
    (101) complex_condition -> condition . logical_operator condition
    (67) factor -> condition .
    (113) logical_operator -> . LOGICAL_AND
    (114) logical_operator -> . LOGICAL_OR
    (115) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 67 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .)
    TIMES           reduce using rule 67 (factor -> condition .)
    DIVIDE          reduce using rule 67 (factor -> condition .)
    PLUS            reduce using rule 67 (factor -> condition .)
    MINUS           reduce using rule 67 (factor -> condition .)
    EQUAL_TO        reduce using rule 67 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 67 (factor -> condition .)
    LESS_THAN       reduce using rule 67 (factor -> condition .)
    GREATER_THAN    reduce using rule 67 (factor -> condition .)
    LESS_EQUAL      reduce using rule 67 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 67 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 67 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 67 (factor -> condition .)
    DIFFERENT       reduce using rule 67 (factor -> condition .)
    LOGICAL_AND     shift and go to state 102
    LOGICAL_OR      shift and go to state 103
    LOGICAL_XOR     shift and go to state 104

  ! LOGICAL_AND     [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! TIMES           [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIVIDE          [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! PLUS            [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MINUS           [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! EQUAL_TO        [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_THAN       [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_THAN    [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIFFERENT       [ reduce using rule 100 (negated_condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 101

state 109

    (68) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (59) expression -> expression . PLUS term
    (60) expression -> expression . MINUS term
    (103) relational_expression -> expression . relational_operator expression
    (104) relational_operator -> . EQUAL_TO
    (105) relational_operator -> . NOT_EQUAL_TO
    (106) relational_operator -> . LESS_THAN
    (107) relational_operator -> . GREATER_THAN
    (108) relational_operator -> . LESS_EQUAL
    (109) relational_operator -> . GREATER_EQUAL
    (110) relational_operator -> . IDENTICAL_TO
    (111) relational_operator -> . NOT_IDENTICAL_TO
    (112) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 172
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    EQUAL_TO        shift and go to state 113
    NOT_EQUAL_TO    shift and go to state 114
    LESS_THAN       shift and go to state 115
    GREATER_THAN    shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    IDENTICAL_TO    shift and go to state 119
    NOT_IDENTICAL_TO shift and go to state 120
    DIFFERENT       shift and go to state 121

    relational_operator            shift and go to state 110

state 110

    (103) relational_expression -> expression relational_operator . expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    LEFT_PAREN      shift and go to state 174
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    ID              shift and go to state 36

    expression                     shift and go to state 173
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 111

    (59) expression -> expression PLUS . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    LEFT_PAREN      shift and go to state 174
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    ID              shift and go to state 36

    expression                     shift and go to state 56
    term                           shift and go to state 175
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 112

    (60) expression -> expression MINUS . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    LEFT_PAREN      shift and go to state 174
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    ID              shift and go to state 36

    expression                     shift and go to state 56
    term                           shift and go to state 176
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 113

    (104) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 104 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 104 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 104 (relational_operator -> EQUAL_TO .)
    TRUE            reduce using rule 104 (relational_operator -> EQUAL_TO .)
    FALSE           reduce using rule 104 (relational_operator -> EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 104 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 104 (relational_operator -> EQUAL_TO .)


state 114

    (105) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)
    TRUE            reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)
    FALSE           reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 105 (relational_operator -> NOT_EQUAL_TO .)


state 115

    (106) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 106 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 106 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 106 (relational_operator -> LESS_THAN .)
    TRUE            reduce using rule 106 (relational_operator -> LESS_THAN .)
    FALSE           reduce using rule 106 (relational_operator -> LESS_THAN .)
    LOGICAL_NOT     reduce using rule 106 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 106 (relational_operator -> LESS_THAN .)


state 116

    (107) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 107 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 107 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 107 (relational_operator -> GREATER_THAN .)
    TRUE            reduce using rule 107 (relational_operator -> GREATER_THAN .)
    FALSE           reduce using rule 107 (relational_operator -> GREATER_THAN .)
    LOGICAL_NOT     reduce using rule 107 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 107 (relational_operator -> GREATER_THAN .)


state 117

    (108) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 108 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 108 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 108 (relational_operator -> LESS_EQUAL .)
    TRUE            reduce using rule 108 (relational_operator -> LESS_EQUAL .)
    FALSE           reduce using rule 108 (relational_operator -> LESS_EQUAL .)
    LOGICAL_NOT     reduce using rule 108 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 108 (relational_operator -> LESS_EQUAL .)


state 118

    (109) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 109 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 109 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 109 (relational_operator -> GREATER_EQUAL .)
    TRUE            reduce using rule 109 (relational_operator -> GREATER_EQUAL .)
    FALSE           reduce using rule 109 (relational_operator -> GREATER_EQUAL .)
    LOGICAL_NOT     reduce using rule 109 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 109 (relational_operator -> GREATER_EQUAL .)


state 119

    (110) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 110 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 110 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 110 (relational_operator -> IDENTICAL_TO .)
    TRUE            reduce using rule 110 (relational_operator -> IDENTICAL_TO .)
    FALSE           reduce using rule 110 (relational_operator -> IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 110 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 110 (relational_operator -> IDENTICAL_TO .)


state 120

    (111) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)
    TRUE            reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)
    FALSE           reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 111 (relational_operator -> NOT_IDENTICAL_TO .)


state 121

    (112) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 112 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 112 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 112 (relational_operator -> DIFFERENT .)
    TRUE            reduce using rule 112 (relational_operator -> DIFFERENT .)
    FALSE           reduce using rule 112 (relational_operator -> DIFFERENT .)
    LOGICAL_NOT     reduce using rule 112 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 112 (relational_operator -> DIFFERENT .)


state 122

    (62) term -> term TIMES . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    LEFT_PAREN      shift and go to state 174
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    ID              shift and go to state 36

    term                           shift and go to state 57
    factor                         shift and go to state 177
    condition                      shift and go to state 80
    expression                     shift and go to state 56
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 123

    (63) term -> term DIVIDE . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    LEFT_PAREN      shift and go to state 174
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    ID              shift and go to state 36

    term                           shift and go to state 57
    factor                         shift and go to state 178
    condition                      shift and go to state 80
    expression                     shift and go to state 56
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 124

    (21) function_statement -> FUNCTION NAME LEFT_PAREN . array_elements RIGHT_PAREN block
    (22) function_statement -> FUNCTION NAME LEFT_PAREN . RIGHT_PAREN block
    (124) array_elements -> . array_argument
    (125) array_elements -> . array_elements COMMA array_argument
    (126) array_argument -> . argument
    (127) array_argument -> . clave KEY_VALUE argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (128) clave -> . STRING
    (129) clave -> . INTEGER
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 180
    STRING          shift and go to state 146
    INTEGER         shift and go to state 147
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    array_elements                 shift and go to state 179
    array_argument                 shift and go to state 143
    argument                       shift and go to state 144
    clave                          shift and go to state 145
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 125

    (119) function_call -> NAME LEFT_PAREN arguments . RIGHT_PAREN
    (46) arguments -> arguments . DOT argument
    (47) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 181
    DOT             shift and go to state 135
    COMMA           shift and go to state 136


state 126

    (120) function_call -> NAME LEFT_PAREN RIGHT_PAREN .

    SEMICOLON       reduce using rule 120 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    DOT             reduce using rule 120 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    COMMA           reduce using rule 120 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 120 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 120 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)


state 127

    (131) class_declaration -> CLASS NAME LEFT_BRACE . class_statements RIGHT_BRACE
    (132) class_declaration -> CLASS NAME LEFT_BRACE . RIGHT_BRACE
    (133) class_statements -> . class_statement
    (134) class_statements -> . class_statements class_statement
    (135) class_statement -> . method_declaration
    (136) class_statement -> . property_declaration
    (137) class_statement -> . ONE_LINE_COMMENT
    (138) class_statement -> . MULTI_LINE_COMMENT
    (139) method_declaration -> . visibility_operator function_statement
    (140) property_declaration -> . visibility_operator variable SEMICOLON
    (141) visibility_operator -> . PUBLIC
    (142) visibility_operator -> . PRIVATE
    (143) visibility_operator -> . PROTECTED

    RIGHT_BRACE     shift and go to state 183
    ONE_LINE_COMMENT shift and go to state 187
    MULTI_LINE_COMMENT shift and go to state 188
    PUBLIC          shift and go to state 190
    PRIVATE         shift and go to state 191
    PROTECTED       shift and go to state 192

    class_statements               shift and go to state 182
    class_statement                shift and go to state 184
    method_declaration             shift and go to state 185
    property_declaration           shift and go to state 186
    visibility_operator            shift and go to state 189

state 128

    (102) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (116) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (68) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (117) casting_type -> . INT_TYPE
    (118) casting_type -> . FLOAT_TYPE
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INT_TYPE        shift and go to state 132
    FLOAT_TYPE      shift and go to state 133
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    ID              shift and go to state 36
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    condition                      shift and go to state 98
    casting_type                   shift and go to state 130
    expression                     shift and go to state 109
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    term                           shift and go to state 57
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53
    factor                         shift and go to state 58

state 129

    (41) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (46) arguments -> arguments . DOT argument
    (47) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 193
    DOT             shift and go to state 135
    COMMA           shift and go to state 136


state 130

    (116) casting -> LEFT_PAREN casting_type . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 194


state 131

    (68) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (59) expression -> expression . PLUS term
    (60) expression -> expression . MINUS term
    (49) argument -> expression .
    (103) relational_expression -> expression . relational_operator expression
    (104) relational_operator -> . EQUAL_TO
    (105) relational_operator -> . NOT_EQUAL_TO
    (106) relational_operator -> . LESS_THAN
    (107) relational_operator -> . GREATER_THAN
    (108) relational_operator -> . LESS_EQUAL
    (109) relational_operator -> . GREATER_EQUAL
    (110) relational_operator -> . IDENTICAL_TO
    (111) relational_operator -> . NOT_IDENTICAL_TO
    (112) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 172
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    DOT             reduce using rule 49 (argument -> expression .)
    COMMA           reduce using rule 49 (argument -> expression .)
    EQUAL_TO        shift and go to state 113
    NOT_EQUAL_TO    shift and go to state 114
    LESS_THAN       shift and go to state 115
    GREATER_THAN    shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    IDENTICAL_TO    shift and go to state 119
    NOT_IDENTICAL_TO shift and go to state 120
    DIFFERENT       shift and go to state 121

  ! RIGHT_PAREN     [ reduce using rule 49 (argument -> expression .) ]

    relational_operator            shift and go to state 110

state 132

    (117) casting_type -> INT_TYPE .

    RIGHT_PAREN     reduce using rule 117 (casting_type -> INT_TYPE .)


state 133

    (118) casting_type -> FLOAT_TYPE .

    RIGHT_PAREN     reduce using rule 118 (casting_type -> FLOAT_TYPE .)


state 134

    (51) argument -> variable . CALL NAME
    (52) argument -> variable . CALL function_call
    (98) simple_condition -> variable .
    (31) assignment_statement -> variable . CALL NAME assignment_operator argument
    (32) assignment_statement -> variable . assignment_operator argument
    (33) assignment_statement -> variable . PLUS_PLUS
    (34) assignment_statement -> variable . MINUS_MINUS
    (130) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (35) assignment_operator -> . EQUALS
    (36) assignment_operator -> . PLUS_EQUALS
    (37) assignment_operator -> . MINUS_EQUALS
    (38) assignment_operator -> . TIMES_EQUALS
    (39) assignment_operator -> . DIVIDE_EQUALS
    (40) assignment_operator -> . MOD_EQUALS

    CALL            shift and go to state 137
    RIGHT_PAREN     reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 98 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 98 (simple_condition -> variable .)
    TIMES           reduce using rule 98 (simple_condition -> variable .)
    DIVIDE          reduce using rule 98 (simple_condition -> variable .)
    PLUS            reduce using rule 98 (simple_condition -> variable .)
    MINUS           reduce using rule 98 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 98 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 98 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 98 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 98 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 98 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 98 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 98 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 98 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 98 (simple_condition -> variable .)
    DOT             reduce using rule 98 (simple_condition -> variable .)
    COMMA           reduce using rule 98 (simple_condition -> variable .)
    PLUS_PLUS       shift and go to state 85
    MINUS_MINUS     shift and go to state 86
    LEFT_BRACKET    shift and go to state 138
    EQUALS          shift and go to state 139
    PLUS_EQUALS     shift and go to state 88
    MINUS_EQUALS    shift and go to state 89
    TIMES_EQUALS    shift and go to state 90
    DIVIDE_EQUALS   shift and go to state 91
    MOD_EQUALS      shift and go to state 92

    assignment_operator            shift and go to state 84

state 135

    (46) arguments -> arguments DOT . argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    argument                       shift and go to state 195
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 136

    (47) arguments -> arguments COMMA . argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    argument                       shift and go to state 196
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 137

    (51) argument -> variable CALL . NAME
    (52) argument -> variable CALL . function_call
    (31) assignment_statement -> variable CALL . NAME assignment_operator argument
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN

    NAME            shift and go to state 197

    function_call                  shift and go to state 198

state 138

    (130) array_indexing -> variable LEFT_BRACKET . INTEGER RIGHT_BRACKET

    INTEGER         shift and go to state 199


state 139

    (35) assignment_operator -> EQUALS .

    STRING          reduce using rule 35 (assignment_operator -> EQUALS .)
    ID              reduce using rule 35 (assignment_operator -> EQUALS .)
    ARRAY           reduce using rule 35 (assignment_operator -> EQUALS .)
    LEFT_BRACKET    reduce using rule 35 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 35 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 35 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 35 (assignment_operator -> EQUALS .)
    NEW             reduce using rule 35 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 35 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 35 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 35 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 35 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 35 (assignment_operator -> EQUALS .)


state 140

    (57) argument -> casting argument .

    DOT             reduce using rule 57 (argument -> casting argument .)
    COMMA           reduce using rule 57 (argument -> casting argument .)
    SEMICOLON       reduce using rule 57 (argument -> casting argument .)
    RIGHT_PAREN     reduce using rule 57 (argument -> casting argument .)
    RIGHT_BRACKET   reduce using rule 57 (argument -> casting argument .)


state 141

    (122) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (124) array_elements -> . array_argument
    (125) array_elements -> . array_elements COMMA array_argument
    (126) array_argument -> . argument
    (127) array_argument -> . clave KEY_VALUE argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (128) clave -> . STRING
    (129) clave -> . INTEGER
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 146
    INTEGER         shift and go to state 147
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    array_elements                 shift and go to state 200
    array_argument                 shift and go to state 143
    argument                       shift and go to state 144
    clave                          shift and go to state 145
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 142

    (123) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (125) array_elements -> array_elements . COMMA array_argument

    RIGHT_BRACKET   shift and go to state 201
    COMMA           shift and go to state 202


state 143

    (124) array_elements -> array_argument .

    RIGHT_BRACKET   reduce using rule 124 (array_elements -> array_argument .)
    COMMA           reduce using rule 124 (array_elements -> array_argument .)
    RIGHT_PAREN     reduce using rule 124 (array_elements -> array_argument .)


state 144

    (126) array_argument -> argument .

    RIGHT_BRACKET   reduce using rule 126 (array_argument -> argument .)
    COMMA           reduce using rule 126 (array_argument -> argument .)
    RIGHT_PAREN     reduce using rule 126 (array_argument -> argument .)


state 145

    (127) array_argument -> clave . KEY_VALUE argument

    KEY_VALUE       shift and go to state 203


state 146

    (48) argument -> STRING .
    (128) clave -> STRING .

    RIGHT_BRACKET   reduce using rule 48 (argument -> STRING .)
    COMMA           reduce using rule 48 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 48 (argument -> STRING .)
    KEY_VALUE       reduce using rule 128 (clave -> STRING .)


state 147

    (129) clave -> INTEGER .
    (65) factor -> INTEGER .

    KEY_VALUE       reduce using rule 129 (clave -> INTEGER .)
    TIMES           reduce using rule 65 (factor -> INTEGER .)
    DIVIDE          reduce using rule 65 (factor -> INTEGER .)
    PLUS            reduce using rule 65 (factor -> INTEGER .)
    MINUS           reduce using rule 65 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 65 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 65 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 65 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 65 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 65 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 65 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 65 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 65 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 65 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 65 (factor -> INTEGER .)
    COMMA           reduce using rule 65 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 65 (factor -> INTEGER .)


state 148

    (144) object_creation -> NEW NAME . LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> NEW NAME . LEFT_PAREN arguments RIGHT_PAREN

    LEFT_PAREN      shift and go to state 204


state 149

    (27) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 205


state 150

    (26) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 206


state 151

    (31) assignment_statement -> variable CALL NAME . assignment_operator argument
    (35) assignment_operator -> . EQUALS
    (36) assignment_operator -> . PLUS_EQUALS
    (37) assignment_operator -> . MINUS_EQUALS
    (38) assignment_operator -> . TIMES_EQUALS
    (39) assignment_operator -> . DIVIDE_EQUALS
    (40) assignment_operator -> . MOD_EQUALS

    EQUALS          shift and go to state 139
    PLUS_EQUALS     shift and go to state 88
    MINUS_EQUALS    shift and go to state 89
    TIMES_EQUALS    shift and go to state 90
    DIVIDE_EQUALS   shift and go to state 91
    MOD_EQUALS      shift and go to state 92

    assignment_operator            shift and go to state 207

state 152

    (32) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 32 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 32 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 32 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 32 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 32 (assignment_statement -> variable assignment_operator argument .)


state 153

    (121) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 121 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 121 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 121 (array_declaration_statement -> variable EQUALS array .)


state 154

    (78) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (87) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 208
    COMMA           shift and go to state 209


state 155

    (79) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    SEMICOLON       reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    TRUE            reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 79 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 156

    (86) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 86 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 86 (assignment_list -> assignment_statement .)


state 157

    (31) assignment_statement -> variable . CALL NAME assignment_operator argument
    (32) assignment_statement -> variable . assignment_operator argument
    (33) assignment_statement -> variable . PLUS_PLUS
    (34) assignment_statement -> variable . MINUS_MINUS
    (35) assignment_operator -> . EQUALS
    (36) assignment_operator -> . PLUS_EQUALS
    (37) assignment_operator -> . MINUS_EQUALS
    (38) assignment_operator -> . TIMES_EQUALS
    (39) assignment_operator -> . DIVIDE_EQUALS
    (40) assignment_operator -> . MOD_EQUALS

    CALL            shift and go to state 83
    PLUS_PLUS       shift and go to state 85
    MINUS_MINUS     shift and go to state 86
    EQUALS          shift and go to state 139
    PLUS_EQUALS     shift and go to state 88
    MINUS_EQUALS    shift and go to state 89
    TIMES_EQUALS    shift and go to state 90
    DIVIDE_EQUALS   shift and go to state 91
    MOD_EQUALS      shift and go to state 92

    assignment_operator            shift and go to state 84

state 158

    (70) if_statement -> IF parenthesized_condition block else_if_extended .
    (71) if_statement -> IF parenthesized_condition block else_if_extended . if_part3
    (74) else_if_extended -> else_if_extended . if_part2
    (76) if_part3 -> . ELSE block
    (75) if_part2 -> . ELSEIF parenthesized_condition block

    CLOSE_TAG       reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ONE_LINE_COMMENT reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    MULTI_LINE_COMMENT reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    BREAK           reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    CONTINUE        reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    IF              reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    WHILE           reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FUNCTION        reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    CLASS           reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FSCANF          reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FGETS           reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    NAME            reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    RETURN          reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FOR             reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    PRINT           reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ECHO            reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ID              reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    RIGHT_BRACE     reduce using rule 70 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ELSE            shift and go to state 161
    ELSEIF          shift and go to state 162

    if_part3                       shift and go to state 210
    if_part2                       shift and go to state 211

state 159

    (72) if_statement -> IF parenthesized_condition block if_part3 .

    CLOSE_TAG       reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    ONE_LINE_COMMENT reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    BREAK           reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    CONTINUE        reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    IF              reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    WHILE           reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    FUNCTION        reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    CLASS           reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    FSCANF          reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    FGETS           reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    NAME            reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    RETURN          reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    FOR             reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    PRINT           reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    ECHO            reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    ID              reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)
    RIGHT_BRACE     reduce using rule 72 (if_statement -> IF parenthesized_condition block if_part3 .)


state 160

    (73) else_if_extended -> if_part2 .

    ELSE            reduce using rule 73 (else_if_extended -> if_part2 .)
    ELSEIF          reduce using rule 73 (else_if_extended -> if_part2 .)
    CLOSE_TAG       reduce using rule 73 (else_if_extended -> if_part2 .)
    ONE_LINE_COMMENT reduce using rule 73 (else_if_extended -> if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 73 (else_if_extended -> if_part2 .)
    BREAK           reduce using rule 73 (else_if_extended -> if_part2 .)
    CONTINUE        reduce using rule 73 (else_if_extended -> if_part2 .)
    IF              reduce using rule 73 (else_if_extended -> if_part2 .)
    WHILE           reduce using rule 73 (else_if_extended -> if_part2 .)
    FUNCTION        reduce using rule 73 (else_if_extended -> if_part2 .)
    CLASS           reduce using rule 73 (else_if_extended -> if_part2 .)
    FSCANF          reduce using rule 73 (else_if_extended -> if_part2 .)
    FGETS           reduce using rule 73 (else_if_extended -> if_part2 .)
    NAME            reduce using rule 73 (else_if_extended -> if_part2 .)
    RETURN          reduce using rule 73 (else_if_extended -> if_part2 .)
    FOR             reduce using rule 73 (else_if_extended -> if_part2 .)
    PRINT           reduce using rule 73 (else_if_extended -> if_part2 .)
    ECHO            reduce using rule 73 (else_if_extended -> if_part2 .)
    ID              reduce using rule 73 (else_if_extended -> if_part2 .)
    RIGHT_BRACE     reduce using rule 73 (else_if_extended -> if_part2 .)


state 161

    (76) if_part3 -> ELSE . block
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 97

    block                          shift and go to state 212

state 162

    (75) if_part2 -> ELSEIF . parenthesized_condition block
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 41

    parenthesized_condition        shift and go to state 213

state 163

    (90) block -> LEFT_BRACE statements . RIGHT_BRACE
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (69) if_statement -> . IF parenthesized_condition block
    (70) if_statement -> . IF parenthesized_condition block else_if_extended
    (71) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (72) if_statement -> . IF parenthesized_condition block if_part3
    (77) while_statement -> . WHILE parenthesized_condition block
    (80) for_statement -> . for_part1 condition for_part3
    (81) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (131) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (132) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (41) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> . print_function arguments
    (27) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (121) array_declaration_statement -> . variable EQUALS array
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (25) return_statement -> . RETURN arguments
    (78) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (79) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (43) print_function -> . PRINT
    (44) print_function -> . ECHO
    (30) variable -> . ID

    RIGHT_BRACE     shift and go to state 214
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FUNCTION        shift and go to state 25
    CLASS           shift and go to state 27
    FSCANF          shift and go to state 29
    FGETS           shift and go to state 30
    NAME            shift and go to state 26
    RETURN          shift and go to state 32
    FOR             shift and go to state 33
    PRINT           shift and go to state 34
    ECHO            shift and go to state 35
    ID              shift and go to state 36

    statement2                     shift and go to state 38
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    for_part1                      shift and go to state 24
    print_function                 shift and go to state 28
    variable                       shift and go to state 31

state 164

    (91) block -> LEFT_BRACE RIGHT_BRACE .

    ELSE            reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSEIF          reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLASS           reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    PUBLIC          reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRIVATE         reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)
    PROTECTED       reduce using rule 91 (block -> LEFT_BRACE RIGHT_BRACE .)


state 165

    (102) parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .

    LEFT_BRACE      reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    SEMICOLON       reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    TIMES           reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIVIDE          reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    PLUS            reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MINUS           reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_THAN       reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIFFERENT       reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 102 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 166

    (101) complex_condition -> condition logical_operator condition .
    (101) complex_condition -> condition . logical_operator condition
    (67) factor -> condition .
    (113) logical_operator -> . LOGICAL_AND
    (114) logical_operator -> . LOGICAL_OR
    (115) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 67 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 67 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 101 (complex_condition -> condition logical_operator condition .)
    DOT             reduce using rule 101 (complex_condition -> condition logical_operator condition .)
    COMMA           reduce using rule 101 (complex_condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 101 (complex_condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 101 (complex_condition -> condition logical_operator condition .)
    TIMES           reduce using rule 67 (factor -> condition .)
    DIVIDE          reduce using rule 67 (factor -> condition .)
    PLUS            reduce using rule 67 (factor -> condition .)
    MINUS           reduce using rule 67 (factor -> condition .)
    EQUAL_TO        reduce using rule 67 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 67 (factor -> condition .)
    LESS_THAN       reduce using rule 67 (factor -> condition .)
    GREATER_THAN    reduce using rule 67 (factor -> condition .)
    LESS_EQUAL      reduce using rule 67 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 67 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 67 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 67 (factor -> condition .)
    DIFFERENT       reduce using rule 67 (factor -> condition .)
    LOGICAL_AND     shift and go to state 102
    LOGICAL_OR      shift and go to state 103
    LOGICAL_XOR     shift and go to state 104

  ! LOGICAL_AND     [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! TIMES           [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! DIVIDE          [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! PLUS            [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! MINUS           [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! EQUAL_TO        [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_THAN       [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_THAN    [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_EQUAL      [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]
  ! DIFFERENT       [ reduce using rule 101 (complex_condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 101

state 167

    (82) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (84) for_part4 -> . block
    (85) for_part4 -> . SEMICOLON
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 169
    LEFT_BRACE      shift and go to state 97

    for_part4                      shift and go to state 215
    block                          shift and go to state 171

state 168

    (89) statement_list -> statement_list COMMA . statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (41) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (42) print_statement -> . print_function arguments
    (27) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (121) array_declaration_statement -> . variable EQUALS array
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (25) return_statement -> . RETURN arguments
    (43) print_function -> . PRINT
    (44) print_function -> . ECHO
    (30) variable -> . ID

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 29
    FGETS           shift and go to state 30
    NAME            shift and go to state 26
    RETURN          shift and go to state 32
    PRINT           shift and go to state 34
    ECHO            shift and go to state 35
    ID              shift and go to state 36

    statement                      shift and go to state 216
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    print_function                 shift and go to state 28
    variable                       shift and go to state 31

state 169

    (85) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 85 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 85 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 85 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 85 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 85 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 85 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 85 (for_part4 -> SEMICOLON .)
    FUNCTION        reduce using rule 85 (for_part4 -> SEMICOLON .)
    CLASS           reduce using rule 85 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 85 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 85 (for_part4 -> SEMICOLON .)
    NAME            reduce using rule 85 (for_part4 -> SEMICOLON .)
    RETURN          reduce using rule 85 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 85 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 85 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 85 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 85 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 85 (for_part4 -> SEMICOLON .)


state 170

    (83) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CLASS           reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 83 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 171

    (84) for_part4 -> block .

    CLOSE_TAG       reduce using rule 84 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 84 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 84 (for_part4 -> block .)
    BREAK           reduce using rule 84 (for_part4 -> block .)
    CONTINUE        reduce using rule 84 (for_part4 -> block .)
    IF              reduce using rule 84 (for_part4 -> block .)
    WHILE           reduce using rule 84 (for_part4 -> block .)
    FUNCTION        reduce using rule 84 (for_part4 -> block .)
    CLASS           reduce using rule 84 (for_part4 -> block .)
    FSCANF          reduce using rule 84 (for_part4 -> block .)
    FGETS           reduce using rule 84 (for_part4 -> block .)
    NAME            reduce using rule 84 (for_part4 -> block .)
    RETURN          reduce using rule 84 (for_part4 -> block .)
    FOR             reduce using rule 84 (for_part4 -> block .)
    PRINT           reduce using rule 84 (for_part4 -> block .)
    ECHO            reduce using rule 84 (for_part4 -> block .)
    ID              reduce using rule 84 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 84 (for_part4 -> block .)


state 172

    (68) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 68 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 173

    (103) relational_expression -> expression relational_operator expression .
    (59) expression -> expression . PLUS term
    (60) expression -> expression . MINUS term
    (103) relational_expression -> expression . relational_operator expression
    (104) relational_operator -> . EQUAL_TO
    (105) relational_operator -> . NOT_EQUAL_TO
    (106) relational_operator -> . LESS_THAN
    (107) relational_operator -> . GREATER_THAN
    (108) relational_operator -> . LESS_EQUAL
    (109) relational_operator -> . GREATER_EQUAL
    (110) relational_operator -> . IDENTICAL_TO
    (111) relational_operator -> . NOT_IDENTICAL_TO
    (112) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL_TO resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for NOT_IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    SEMICOLON       reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    LOGICAL_AND     reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    TIMES           reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    DIVIDE          reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    DOT             reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    COMMA           reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 103 (relational_expression -> expression relational_operator expression .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    EQUAL_TO        shift and go to state 113
    NOT_EQUAL_TO    shift and go to state 114
    LESS_THAN       shift and go to state 115
    GREATER_THAN    shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    IDENTICAL_TO    shift and go to state 119
    NOT_IDENTICAL_TO shift and go to state 120
    DIFFERENT       shift and go to state 121

  ! PLUS            [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! MINUS           [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! EQUAL_TO        [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_THAN       [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_THAN    [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_EQUAL      [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! IDENTICAL_TO    [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]
  ! DIFFERENT       [ reduce using rule 103 (relational_expression -> expression relational_operator expression .) ]

    relational_operator            shift and go to state 110

state 174

    (68) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (102) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (30) variable -> . ID
    (103) relational_expression -> . expression relational_operator expression

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54
    LEFT_PAREN      shift and go to state 55
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    ID              shift and go to state 36

    expression                     shift and go to state 109
    condition                      shift and go to state 98
    term                           shift and go to state 57
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    factor                         shift and go to state 58
    variable                       shift and go to state 52
    relational_expression          shift and go to state 53

state 175

    (59) expression -> expression PLUS term .
    (62) term -> term . TIMES factor
    (63) term -> term . DIVIDE factor
    (61) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 59 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 59 (expression -> expression PLUS term .)
    PLUS            reduce using rule 59 (expression -> expression PLUS term .)
    MINUS           reduce using rule 59 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 59 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 59 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 59 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 59 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 59 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 59 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 59 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 59 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 59 (expression -> expression PLUS term .)
    DOT             reduce using rule 59 (expression -> expression PLUS term .)
    COMMA           reduce using rule 59 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 59 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 59 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 59 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 59 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 59 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 59 (expression -> expression PLUS term .)
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123

  ! TIMES           [ reduce using rule 59 (expression -> expression PLUS term .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> expression PLUS term .) ]
  ! PLUS            [ reduce using rule 61 (expression -> term .) ]
  ! MINUS           [ reduce using rule 61 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 61 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 61 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 61 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 61 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 61 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 61 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 61 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 61 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 61 (expression -> term .) ]


state 176

    (60) expression -> expression MINUS term .
    (62) term -> term . TIMES factor
    (63) term -> term . DIVIDE factor
    (61) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 60 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 60 (expression -> expression MINUS term .)
    PLUS            reduce using rule 60 (expression -> expression MINUS term .)
    MINUS           reduce using rule 60 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 60 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 60 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 60 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 60 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 60 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 60 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 60 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 60 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 60 (expression -> expression MINUS term .)
    DOT             reduce using rule 60 (expression -> expression MINUS term .)
    COMMA           reduce using rule 60 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 60 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 60 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 60 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 60 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 60 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 60 (expression -> expression MINUS term .)
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123

  ! TIMES           [ reduce using rule 60 (expression -> expression MINUS term .) ]
  ! DIVIDE          [ reduce using rule 60 (expression -> expression MINUS term .) ]
  ! PLUS            [ reduce using rule 61 (expression -> term .) ]
  ! MINUS           [ reduce using rule 61 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 61 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 61 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 61 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 61 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 61 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 61 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 61 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 61 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 61 (expression -> term .) ]


state 177

    (62) term -> term TIMES factor .
    (64) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 62 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 62 (term -> term TIMES factor .)
    TIMES           reduce using rule 62 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 62 (term -> term TIMES factor .)
    PLUS            reduce using rule 62 (term -> term TIMES factor .)
    MINUS           reduce using rule 62 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 62 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 62 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 62 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 62 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 62 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 62 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 62 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 62 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 62 (term -> term TIMES factor .)
    DOT             reduce using rule 62 (term -> term TIMES factor .)
    COMMA           reduce using rule 62 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 62 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 62 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 62 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 62 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 62 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 62 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 64 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 64 (term -> factor .) ]
  ! PLUS            [ reduce using rule 64 (term -> factor .) ]
  ! MINUS           [ reduce using rule 64 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 64 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 64 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 64 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 64 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 64 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 64 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 64 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 64 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 64 (term -> factor .) ]


state 178

    (63) term -> term DIVIDE factor .
    (64) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 63 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 63 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 63 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 63 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 63 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 63 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 63 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 63 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 63 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 63 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 63 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 63 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 63 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 63 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 63 (term -> term DIVIDE factor .)
    DOT             reduce using rule 63 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 63 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 63 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 63 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 63 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 63 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 63 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 63 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 64 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 64 (term -> factor .) ]
  ! PLUS            [ reduce using rule 64 (term -> factor .) ]
  ! MINUS           [ reduce using rule 64 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 64 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 64 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 64 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 64 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 64 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 64 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 64 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 64 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 64 (term -> factor .) ]


state 179

    (21) function_statement -> FUNCTION NAME LEFT_PAREN array_elements . RIGHT_PAREN block
    (125) array_elements -> array_elements . COMMA array_argument

    RIGHT_PAREN     shift and go to state 217
    COMMA           shift and go to state 202


state 180

    (22) function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN . block
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 97

    block                          shift and go to state 218

state 181

    (119) function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 119 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    DOT             reduce using rule 119 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 119 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 119 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 119 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)


state 182

    (131) class_declaration -> CLASS NAME LEFT_BRACE class_statements . RIGHT_BRACE
    (134) class_statements -> class_statements . class_statement
    (135) class_statement -> . method_declaration
    (136) class_statement -> . property_declaration
    (137) class_statement -> . ONE_LINE_COMMENT
    (138) class_statement -> . MULTI_LINE_COMMENT
    (139) method_declaration -> . visibility_operator function_statement
    (140) property_declaration -> . visibility_operator variable SEMICOLON
    (141) visibility_operator -> . PUBLIC
    (142) visibility_operator -> . PRIVATE
    (143) visibility_operator -> . PROTECTED

    RIGHT_BRACE     shift and go to state 219
    ONE_LINE_COMMENT shift and go to state 187
    MULTI_LINE_COMMENT shift and go to state 188
    PUBLIC          shift and go to state 190
    PRIVATE         shift and go to state 191
    PROTECTED       shift and go to state 192

    class_statement                shift and go to state 220
    method_declaration             shift and go to state 185
    property_declaration           shift and go to state 186
    visibility_operator            shift and go to state 189

state 183

    (132) class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    CLASS           reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 132 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)


state 184

    (133) class_statements -> class_statement .

    RIGHT_BRACE     reduce using rule 133 (class_statements -> class_statement .)
    ONE_LINE_COMMENT reduce using rule 133 (class_statements -> class_statement .)
    MULTI_LINE_COMMENT reduce using rule 133 (class_statements -> class_statement .)
    PUBLIC          reduce using rule 133 (class_statements -> class_statement .)
    PRIVATE         reduce using rule 133 (class_statements -> class_statement .)
    PROTECTED       reduce using rule 133 (class_statements -> class_statement .)


state 185

    (135) class_statement -> method_declaration .

    RIGHT_BRACE     reduce using rule 135 (class_statement -> method_declaration .)
    ONE_LINE_COMMENT reduce using rule 135 (class_statement -> method_declaration .)
    MULTI_LINE_COMMENT reduce using rule 135 (class_statement -> method_declaration .)
    PUBLIC          reduce using rule 135 (class_statement -> method_declaration .)
    PRIVATE         reduce using rule 135 (class_statement -> method_declaration .)
    PROTECTED       reduce using rule 135 (class_statement -> method_declaration .)


state 186

    (136) class_statement -> property_declaration .

    RIGHT_BRACE     reduce using rule 136 (class_statement -> property_declaration .)
    ONE_LINE_COMMENT reduce using rule 136 (class_statement -> property_declaration .)
    MULTI_LINE_COMMENT reduce using rule 136 (class_statement -> property_declaration .)
    PUBLIC          reduce using rule 136 (class_statement -> property_declaration .)
    PRIVATE         reduce using rule 136 (class_statement -> property_declaration .)
    PROTECTED       reduce using rule 136 (class_statement -> property_declaration .)


state 187

    (137) class_statement -> ONE_LINE_COMMENT .

    RIGHT_BRACE     reduce using rule 137 (class_statement -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 137 (class_statement -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 137 (class_statement -> ONE_LINE_COMMENT .)
    PUBLIC          reduce using rule 137 (class_statement -> ONE_LINE_COMMENT .)
    PRIVATE         reduce using rule 137 (class_statement -> ONE_LINE_COMMENT .)
    PROTECTED       reduce using rule 137 (class_statement -> ONE_LINE_COMMENT .)


state 188

    (138) class_statement -> MULTI_LINE_COMMENT .

    RIGHT_BRACE     reduce using rule 138 (class_statement -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 138 (class_statement -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 138 (class_statement -> MULTI_LINE_COMMENT .)
    PUBLIC          reduce using rule 138 (class_statement -> MULTI_LINE_COMMENT .)
    PRIVATE         reduce using rule 138 (class_statement -> MULTI_LINE_COMMENT .)
    PROTECTED       reduce using rule 138 (class_statement -> MULTI_LINE_COMMENT .)


state 189

    (139) method_declaration -> visibility_operator . function_statement
    (140) property_declaration -> visibility_operator . variable SEMICOLON
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (30) variable -> . ID

    FUNCTION        shift and go to state 25
    ID              shift and go to state 36

    function_statement             shift and go to state 221
    variable                       shift and go to state 222

state 190

    (141) visibility_operator -> PUBLIC .

    FUNCTION        reduce using rule 141 (visibility_operator -> PUBLIC .)
    ID              reduce using rule 141 (visibility_operator -> PUBLIC .)


state 191

    (142) visibility_operator -> PRIVATE .

    FUNCTION        reduce using rule 142 (visibility_operator -> PRIVATE .)
    ID              reduce using rule 142 (visibility_operator -> PRIVATE .)


state 192

    (143) visibility_operator -> PROTECTED .

    FUNCTION        reduce using rule 143 (visibility_operator -> PROTECTED .)
    ID              reduce using rule 143 (visibility_operator -> PROTECTED .)


state 193

    (41) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 41 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 41 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 41 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 194

    (116) casting -> LEFT_PAREN casting_type RIGHT_PAREN .

    STRING          reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ID              reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ARRAY           reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_BRACKET    reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NAME            reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FGETS           reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NEW             reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    INTEGER         reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FLOAT           reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    TRUE            reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FALSE           reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 116 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)


state 195

    (46) arguments -> arguments DOT argument .

    DOT             reduce using rule 46 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 46 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 46 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 46 (arguments -> arguments DOT argument .)


state 196

    (47) arguments -> arguments COMMA argument .

    DOT             reduce using rule 47 (arguments -> arguments COMMA argument .)
    COMMA           reduce using rule 47 (arguments -> arguments COMMA argument .)
    SEMICOLON       reduce using rule 47 (arguments -> arguments COMMA argument .)
    RIGHT_PAREN     reduce using rule 47 (arguments -> arguments COMMA argument .)


state 197

    (51) argument -> variable CALL NAME .
    (31) assignment_statement -> variable CALL NAME . assignment_operator argument
    (119) function_call -> NAME . LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> NAME . LEFT_PAREN RIGHT_PAREN
    (35) assignment_operator -> . EQUALS
    (36) assignment_operator -> . PLUS_EQUALS
    (37) assignment_operator -> . MINUS_EQUALS
    (38) assignment_operator -> . TIMES_EQUALS
    (39) assignment_operator -> . DIVIDE_EQUALS
    (40) assignment_operator -> . MOD_EQUALS

    DOT             reduce using rule 51 (argument -> variable CALL NAME .)
    COMMA           reduce using rule 51 (argument -> variable CALL NAME .)
    SEMICOLON       reduce using rule 51 (argument -> variable CALL NAME .)
    RIGHT_PAREN     reduce using rule 51 (argument -> variable CALL NAME .)
    RIGHT_BRACKET   reduce using rule 51 (argument -> variable CALL NAME .)
    LEFT_PAREN      shift and go to state 62
    EQUALS          shift and go to state 139
    PLUS_EQUALS     shift and go to state 88
    MINUS_EQUALS    shift and go to state 89
    TIMES_EQUALS    shift and go to state 90
    DIVIDE_EQUALS   shift and go to state 91
    MOD_EQUALS      shift and go to state 92

    assignment_operator            shift and go to state 207

state 198

    (52) argument -> variable CALL function_call .

    DOT             reduce using rule 52 (argument -> variable CALL function_call .)
    COMMA           reduce using rule 52 (argument -> variable CALL function_call .)
    SEMICOLON       reduce using rule 52 (argument -> variable CALL function_call .)
    RIGHT_PAREN     reduce using rule 52 (argument -> variable CALL function_call .)
    RIGHT_BRACKET   reduce using rule 52 (argument -> variable CALL function_call .)


state 199

    (130) array_indexing -> variable LEFT_BRACKET INTEGER . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 223


state 200

    (122) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (125) array_elements -> array_elements . COMMA array_argument

    RIGHT_PAREN     shift and go to state 224
    COMMA           shift and go to state 202


state 201

    (123) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    DOT             reduce using rule 123 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 123 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 123 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 123 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 123 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)


state 202

    (125) array_elements -> array_elements COMMA . array_argument
    (126) array_argument -> . argument
    (127) array_argument -> . clave KEY_VALUE argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (128) clave -> . STRING
    (129) clave -> . INTEGER
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 146
    INTEGER         shift and go to state 147
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    array_argument                 shift and go to state 225
    argument                       shift and go to state 144
    clave                          shift and go to state 145
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 203

    (127) array_argument -> clave KEY_VALUE . argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    argument                       shift and go to state 226
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 204

    (144) object_creation -> NEW NAME LEFT_PAREN . RIGHT_PAREN
    (145) object_creation -> NEW NAME LEFT_PAREN . arguments RIGHT_PAREN
    (45) arguments -> . argument
    (46) arguments -> . arguments DOT argument
    (47) arguments -> . arguments COMMA argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 227
    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    arguments                      shift and go to state 228
    argument                       shift and go to state 66
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    variable                       shift and go to state 70
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 205

    (27) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 229


state 206

    (26) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 26 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    DOT             reduce using rule 26 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 26 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 26 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 26 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)


state 207

    (31) assignment_statement -> variable CALL NAME assignment_operator . argument
    (48) argument -> . STRING
    (49) argument -> . expression
    (50) argument -> . assignment_statement
    (51) argument -> . variable CALL NAME
    (52) argument -> . variable CALL function_call
    (53) argument -> . array
    (54) argument -> . function_call
    (55) argument -> . fgets_statement
    (56) argument -> . array_indexing
    (57) argument -> . casting argument
    (58) argument -> . object_creation
    (59) expression -> . expression PLUS term
    (60) expression -> . expression MINUS term
    (61) expression -> . term
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID
    (122) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (123) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (119) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (120) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (26) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (130) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (116) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (144) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (145) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (62) term -> . term TIMES factor
    (63) term -> . term DIVIDE factor
    (64) term -> . factor
    (65) factor -> . INTEGER
    (66) factor -> . FLOAT
    (67) factor -> . condition
    (68) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (92) condition -> . simple_condition
    (93) condition -> . negated_condition
    (94) condition -> . complex_condition
    (95) condition -> . parenthesized_condition
    (96) simple_condition -> . TRUE
    (97) simple_condition -> . FALSE
    (98) simple_condition -> . variable
    (99) simple_condition -> . relational_expression
    (100) negated_condition -> . LOGICAL_NOT condition
    (101) complex_condition -> . condition logical_operator condition
    (102) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (103) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 67
    ID              shift and go to state 36
    ARRAY           shift and go to state 77
    LEFT_BRACKET    shift and go to state 78
    NAME            shift and go to state 26
    FGETS           shift and go to state 30
    LEFT_PAREN      shift and go to state 94
    NEW             shift and go to state 79
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    LOGICAL_NOT     shift and go to state 54

    variable                       shift and go to state 70
    argument                       shift and go to state 230
    expression                     shift and go to state 68
    assignment_statement           shift and go to state 69
    function_call                  shift and go to state 71
    array                          shift and go to state 72
    fgets_statement                shift and go to state 73
    array_indexing                 shift and go to state 74
    casting                        shift and go to state 75
    object_creation                shift and go to state 76
    term                           shift and go to state 57
    factor                         shift and go to state 58
    condition                      shift and go to state 80
    simple_condition               shift and go to state 45
    negated_condition              shift and go to state 46
    complex_condition              shift and go to state 47
    parenthesized_condition        shift and go to state 48
    relational_expression          shift and go to state 53

state 208

    (78) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    SEMICOLON       reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    TRUE            reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 78 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)


state 209

    (87) assignment_list -> assignment_list COMMA . assignment_statement
    (31) assignment_statement -> . variable CALL NAME assignment_operator argument
    (32) assignment_statement -> . variable assignment_operator argument
    (33) assignment_statement -> . variable PLUS_PLUS
    (34) assignment_statement -> . variable MINUS_MINUS
    (30) variable -> . ID

    ID              shift and go to state 36

    assignment_statement           shift and go to state 231
    variable                       shift and go to state 157

state 210

    (71) if_statement -> IF parenthesized_condition block else_if_extended if_part3 .

    CLOSE_TAG       reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ONE_LINE_COMMENT reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    BREAK           reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CONTINUE        reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    IF              reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    WHILE           reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FUNCTION        reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CLASS           reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FSCANF          reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FGETS           reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    NAME            reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RETURN          reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FOR             reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    PRINT           reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ECHO            reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ID              reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RIGHT_BRACE     reduce using rule 71 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)


state 211

    (74) else_if_extended -> else_if_extended if_part2 .

    ELSE            reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    ELSEIF          reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    CLOSE_TAG       reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    ONE_LINE_COMMENT reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    BREAK           reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    CONTINUE        reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    IF              reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    WHILE           reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    FUNCTION        reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    CLASS           reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    FSCANF          reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    FGETS           reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    NAME            reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    RETURN          reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    FOR             reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    PRINT           reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    ECHO            reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    ID              reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)
    RIGHT_BRACE     reduce using rule 74 (else_if_extended -> else_if_extended if_part2 .)


state 212

    (76) if_part3 -> ELSE block .

    CLOSE_TAG       reduce using rule 76 (if_part3 -> ELSE block .)
    ONE_LINE_COMMENT reduce using rule 76 (if_part3 -> ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 76 (if_part3 -> ELSE block .)
    BREAK           reduce using rule 76 (if_part3 -> ELSE block .)
    CONTINUE        reduce using rule 76 (if_part3 -> ELSE block .)
    IF              reduce using rule 76 (if_part3 -> ELSE block .)
    WHILE           reduce using rule 76 (if_part3 -> ELSE block .)
    FUNCTION        reduce using rule 76 (if_part3 -> ELSE block .)
    CLASS           reduce using rule 76 (if_part3 -> ELSE block .)
    FSCANF          reduce using rule 76 (if_part3 -> ELSE block .)
    FGETS           reduce using rule 76 (if_part3 -> ELSE block .)
    NAME            reduce using rule 76 (if_part3 -> ELSE block .)
    RETURN          reduce using rule 76 (if_part3 -> ELSE block .)
    FOR             reduce using rule 76 (if_part3 -> ELSE block .)
    PRINT           reduce using rule 76 (if_part3 -> ELSE block .)
    ECHO            reduce using rule 76 (if_part3 -> ELSE block .)
    ID              reduce using rule 76 (if_part3 -> ELSE block .)
    RIGHT_BRACE     reduce using rule 76 (if_part3 -> ELSE block .)


state 213

    (75) if_part2 -> ELSEIF parenthesized_condition . block
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 97

    block                          shift and go to state 232

state 214

    (90) block -> LEFT_BRACE statements RIGHT_BRACE .

    ELSE            reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSEIF          reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLASS           reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    NAME            reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RETURN          reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PUBLIC          reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRIVATE         reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PROTECTED       reduce using rule 90 (block -> LEFT_BRACE statements RIGHT_BRACE .)


state 215

    (82) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CLASS           reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 82 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)


state 216

    (89) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 89 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 89 (statement_list -> statement_list COMMA statement .)


state 217

    (21) function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN . block
    (90) block -> . LEFT_BRACE statements RIGHT_BRACE
    (91) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 97

    block                          shift and go to state 233

state 218

    (22) function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    BREAK           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    CONTINUE        reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    IF              reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    WHILE           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FUNCTION        reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    CLASS           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FSCANF          reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FGETS           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    NAME            reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    RETURN          reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FOR             reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PRINT           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ECHO            reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ID              reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PUBLIC          reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PRIVATE         reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PROTECTED       reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)


state 219

    (131) class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    BREAK           reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    IF              reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    WHILE           reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    CLASS           reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FSCANF          reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FGETS           reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    NAME            reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    RETURN          reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FOR             reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    PRINT           reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ECHO            reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ID              reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 131 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)


state 220

    (134) class_statements -> class_statements class_statement .

    RIGHT_BRACE     reduce using rule 134 (class_statements -> class_statements class_statement .)
    ONE_LINE_COMMENT reduce using rule 134 (class_statements -> class_statements class_statement .)
    MULTI_LINE_COMMENT reduce using rule 134 (class_statements -> class_statements class_statement .)
    PUBLIC          reduce using rule 134 (class_statements -> class_statements class_statement .)
    PRIVATE         reduce using rule 134 (class_statements -> class_statements class_statement .)
    PROTECTED       reduce using rule 134 (class_statements -> class_statements class_statement .)


state 221

    (139) method_declaration -> visibility_operator function_statement .

    RIGHT_BRACE     reduce using rule 139 (method_declaration -> visibility_operator function_statement .)
    ONE_LINE_COMMENT reduce using rule 139 (method_declaration -> visibility_operator function_statement .)
    MULTI_LINE_COMMENT reduce using rule 139 (method_declaration -> visibility_operator function_statement .)
    PUBLIC          reduce using rule 139 (method_declaration -> visibility_operator function_statement .)
    PRIVATE         reduce using rule 139 (method_declaration -> visibility_operator function_statement .)
    PROTECTED       reduce using rule 139 (method_declaration -> visibility_operator function_statement .)


state 222

    (140) property_declaration -> visibility_operator variable . SEMICOLON

    SEMICOLON       shift and go to state 234


state 223

    (130) array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .

    DOT             reduce using rule 130 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    COMMA           reduce using rule 130 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 130 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 130 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 130 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)


state 224

    (122) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    DOT             reduce using rule 122 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 122 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    SEMICOLON       reduce using rule 122 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 122 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 122 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 225

    (125) array_elements -> array_elements COMMA array_argument .

    RIGHT_BRACKET   reduce using rule 125 (array_elements -> array_elements COMMA array_argument .)
    COMMA           reduce using rule 125 (array_elements -> array_elements COMMA array_argument .)
    RIGHT_PAREN     reduce using rule 125 (array_elements -> array_elements COMMA array_argument .)


state 226

    (127) array_argument -> clave KEY_VALUE argument .

    RIGHT_BRACKET   reduce using rule 127 (array_argument -> clave KEY_VALUE argument .)
    COMMA           reduce using rule 127 (array_argument -> clave KEY_VALUE argument .)
    RIGHT_PAREN     reduce using rule 127 (array_argument -> clave KEY_VALUE argument .)


state 227

    (144) object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .

    DOT             reduce using rule 144 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    COMMA           reduce using rule 144 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    SEMICOLON       reduce using rule 144 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 144 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 144 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)


state 228

    (145) object_creation -> NEW NAME LEFT_PAREN arguments . RIGHT_PAREN
    (46) arguments -> arguments . DOT argument
    (47) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 235
    DOT             shift and go to state 135
    COMMA           shift and go to state 136


state 229

    (27) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 236


state 230

    (31) assignment_statement -> variable CALL NAME assignment_operator argument .

    SEMICOLON       reduce using rule 31 (assignment_statement -> variable CALL NAME assignment_operator argument .)
    DOT             reduce using rule 31 (assignment_statement -> variable CALL NAME assignment_operator argument .)
    COMMA           reduce using rule 31 (assignment_statement -> variable CALL NAME assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 31 (assignment_statement -> variable CALL NAME assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 31 (assignment_statement -> variable CALL NAME assignment_operator argument .)


state 231

    (87) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 87 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 87 (assignment_list -> assignment_list COMMA assignment_statement .)


state 232

    (75) if_part2 -> ELSEIF parenthesized_condition block .

    ELSE            reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    ELSEIF          reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLOSE_TAG       reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    BREAK           reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    CONTINUE        reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    IF              reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    WHILE           reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    FUNCTION        reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLASS           reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    FSCANF          reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    FGETS           reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    NAME            reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    RETURN          reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    FOR             reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    PRINT           reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    ECHO            reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    ID              reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 75 (if_part2 -> ELSEIF parenthesized_condition block .)


state 233

    (21) function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    BREAK           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    CONTINUE        reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    IF              reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    WHILE           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FUNCTION        reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    CLASS           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FSCANF          reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FGETS           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    NAME            reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    RETURN          reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FOR             reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PRINT           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    ECHO            reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    ID              reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PUBLIC          reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PRIVATE         reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PROTECTED       reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)


state 234

    (140) property_declaration -> visibility_operator variable SEMICOLON .

    RIGHT_BRACE     reduce using rule 140 (property_declaration -> visibility_operator variable SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 140 (property_declaration -> visibility_operator variable SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 140 (property_declaration -> visibility_operator variable SEMICOLON .)
    PUBLIC          reduce using rule 140 (property_declaration -> visibility_operator variable SEMICOLON .)
    PRIVATE         reduce using rule 140 (property_declaration -> visibility_operator variable SEMICOLON .)
    PROTECTED       reduce using rule 140 (property_declaration -> visibility_operator variable SEMICOLON .)


state 235

    (145) object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .

    DOT             reduce using rule 145 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 145 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    SEMICOLON       reduce using rule 145 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 145 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 145 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)


state 236

    (27) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (28) variable_list -> . variable
    (29) variable_list -> . variable_list COMMA variable
    (30) variable -> . ID

    ID              shift and go to state 36

    variable_list                  shift and go to state 237
    variable                       shift and go to state 238

state 237

    (27) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (29) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 240
    COMMA           shift and go to state 239


state 238

    (28) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 28 (variable_list -> variable .)
    COMMA           reduce using rule 28 (variable_list -> variable .)


state 239

    (29) variable_list -> variable_list COMMA . variable
    (30) variable -> . ID

    ID              shift and go to state 36

    variable                       shift and go to state 241

state 240

    (27) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 27 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 27 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 27 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)


state 241

    (29) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 29 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 29 (variable_list -> variable_list COMMA variable .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TIMES in state 57 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 57 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 65 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 80 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 80 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 80 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 87 resolved as shift
WARNING: shift/reduce conflict for LEFT_BRACKET in state 87 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 93 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 108 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 131 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 166 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 166 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 166 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 173 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL_TO in state 173 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 173 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for IDENTICAL_TO in state 173 resolved as shift
WARNING: shift/reduce conflict for NOT_IDENTICAL_TO in state 173 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 173 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 175 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 175 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 176 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 176 resolved as shift
WARNING: reduce/reduce conflict in state 108 resolved using rule (factor -> condition)
WARNING: rejected rule (negated_condition -> LOGICAL_NOT condition) in state 108
WARNING: reduce/reduce conflict in state 166 resolved using rule (factor -> condition)
WARNING: rejected rule (complex_condition -> condition logical_operator condition) in state 166
WARNING: reduce/reduce conflict in state 175 resolved using rule (expression -> expression PLUS term)
WARNING: rejected rule (expression -> term) in state 175
WARNING: reduce/reduce conflict in state 176 resolved using rule (expression -> expression MINUS term)
WARNING: rejected rule (expression -> term) in state 176
WARNING: reduce/reduce conflict in state 177 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 177
WARNING: reduce/reduce conflict in state 178 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 178
