Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ADD_CHILD
    APPEND
    APPENDLEFT
    ARROW
    AS
    ASYNC
    AWAIT
    BOOL
    CALL
    CALLABLE
    CASE
    CATCH
    CLASS
    CLONE
    COLON
    CONST
    DECLARE
    DEFAULT
    DEQUEUE
    DICTIONARY
    DIE
    DO
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENQUEUE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FINAL
    FINALLY
    FN
    FOREACH
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    ITERATOR
    KEY_VALUE
    LAMBDA
    LIST
    LPAREN
    MATCH
    MIXED
    MOD
    NAMESPACE
    NEW
    NULL
    OBJECT
    POP
    POPLEFT
    POWER
    PRIVATE
    PROTECTED
    PUBLIC
    PUSH
    REQUIRE
    REQUIRE_ONCE
    RPAREN
    SELF
    SET
    STATIC
    SWITCH
    THROW
    TRAIT
    TRY
    UNSET
    USE
    VAR
    VOID
    YIELD
    YIELD_FROM
    object_declaration

Grammar

Rule 0     S' -> program
Rule 1     program -> OPEN_TAG statements CLOSE_TAG
Rule 2     statements -> statement2
Rule 3     statements -> statements statement2
Rule 4     statement2 -> statement SEMICOLON
Rule 5     statement2 -> if_statement
Rule 6     statement2 -> while_statement
Rule 7     statement2 -> for_statement
Rule 8     statement2 -> function_statement
Rule 9     statement2 -> ONE_LINE_COMMENT
Rule 10    statement2 -> MULTI_LINE_COMMENT
Rule 11    statement2 -> condition
Rule 12    statement -> print_statement
Rule 13    statement -> fscanf_statement
Rule 14    statement -> fgets_statement
Rule 15    statement -> assignment_statement
Rule 16    statement -> array_declaration_statement
Rule 17    statement -> BREAK
Rule 18    statement -> CONTINUE
Rule 19    statement -> function_call
Rule 20    statement -> statement_return
Rule 21    function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
Rule 22    statement_return -> RETURN expression
Rule 23    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 24    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 25    variable_list -> variable
Rule 26    variable_list -> variable_list COMMA variable
Rule 27    variable -> ID
Rule 28    assignment_statement -> variable assignment_operator argument
Rule 29    assignment_statement -> variable PLUS_PLUS
Rule 30    assignment_statement -> variable MINUS_MINUS
Rule 31    assignment_operator -> EQUALS
Rule 32    assignment_operator -> PLUS_EQUALS
Rule 33    assignment_operator -> MINUS_EQUALS
Rule 34    assignment_operator -> TIMES_EQUALS
Rule 35    assignment_operator -> DIVIDE_EQUALS
Rule 36    assignment_operator -> MOD_EQUALS
Rule 37    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 38    print_statement -> print_function arguments
Rule 39    print_function -> PRINT
Rule 40    print_function -> ECHO
Rule 41    arguments -> argument
Rule 42    arguments -> arguments DOT argument
Rule 43    arguments -> arguments COMMA argument
Rule 44    argument -> STRING
Rule 45    argument -> expression
Rule 46    argument -> assignment_statement
Rule 47    argument -> function_call
Rule 48    argument -> fgets_statement
Rule 49    argument -> array_indexing
Rule 50    argument -> casting argument
Rule 51    expression -> expression PLUS term
Rule 52    expression -> expression MINUS term
Rule 53    expression -> term
Rule 54    term -> term TIMES factor
Rule 55    term -> term DIVIDE factor
Rule 56    term -> factor
Rule 57    factor -> INTEGER
Rule 58    factor -> FLOAT
Rule 59    factor -> condition
Rule 60    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 61    if_statement -> IF parenthesized_condition block else_if_extended if_part3
Rule 62    else_if_extended -> if_part2
Rule 63    else_if_extended -> else_if_extended if_part2
Rule 64    if_part2 -> ELSEIF parenthesized_condition block
Rule 65    if_part2 -> <empty>
Rule 66    if_part3 -> ELSE block
Rule 67    if_part3 -> <empty>
Rule 68    while_statement -> WHILE parenthesized_condition block
Rule 69    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 70    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 71    for_statement -> for_part1 condition for_part3
Rule 72    for_statement -> for_part1 for_part3
Rule 73    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 74    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 75    for_part4 -> block
Rule 76    for_part4 -> SEMICOLON
Rule 77    assignment_list -> assignment_statement
Rule 78    assignment_list -> assignment_list COMMA assignment_statement
Rule 79    statement_list -> statement
Rule 80    statement_list -> statement_list COMMA statement
Rule 81    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 82    block -> LEFT_BRACE RIGHT_BRACE
Rule 83    condition -> simple_condition
Rule 84    condition -> negated_condition
Rule 85    condition -> complex_condition
Rule 86    condition -> parenthesized_condition
Rule 87    simple_condition -> TRUE
Rule 88    simple_condition -> FALSE
Rule 89    simple_condition -> variable
Rule 90    simple_condition -> relational_expression
Rule 91    negated_condition -> LOGICAL_NOT condition
Rule 92    complex_condition -> condition logical_operator condition
Rule 93    parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 94    relational_expression -> expression relational_operator expression
Rule 95    relational_operator -> EQUAL_TO
Rule 96    relational_operator -> NOT_EQUAL_TO
Rule 97    relational_operator -> LESS_THAN
Rule 98    relational_operator -> GREATER_THAN
Rule 99    relational_operator -> LESS_EQUAL
Rule 100   relational_operator -> GREATER_EQUAL
Rule 101   relational_operator -> IDENTICAL_TO
Rule 102   relational_operator -> NOT_IDENTICAL_TO
Rule 103   relational_operator -> DIFFERENT
Rule 104   logical_operator -> LOGICAL_AND
Rule 105   logical_operator -> LOGICAL_OR
Rule 106   logical_operator -> LOGICAL_XOR
Rule 107   casting -> LEFT_PAREN casting_type RIGHT_PAREN
Rule 108   casting_type -> INT_TYPE
Rule 109   casting_type -> FLOAT_TYPE
Rule 110   function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN
Rule 111   array_declaration_statement -> variable EQUALS array
Rule 112   array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 113   array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 114   array_elements -> argument
Rule 115   array_elements -> array_elements COMMA argument
Rule 116   array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET

Terminals, with rules where they appear

ABSTRACT             : 
ADD_CHILD            : 
APPEND               : 
APPENDLEFT           : 
ARRAY                : 112
ARROW                : 
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 17
CALL                 : 
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 1
COLON                : 
COMMA                : 24 24 26 43 78 80 115
CONST                : 
CONTINUE             : 18
DECLARE              : 
DEFAULT              : 
DEQUEUE              : 
DICTIONARY           : 
DIE                  : 
DIFFERENT            : 103
DIVIDE               : 55
DIVIDE_EQUALS        : 35
DO                   : 
DOT                  : 42
ECHO                 : 40
ELSE                 : 66
ELSEIF               : 64
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENQUEUE              : 
ENUM                 : 
EQUALS               : 31 111
EQUAL_TO             : 95
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 88
FGETS                : 23
FINAL                : 
FINALLY              : 
FLOAT                : 58
FLOAT_TYPE           : 109
FN                   : 
FOR                  : 69 70
FOREACH              : 
FSCANF               : 24
FUNCTION             : 21
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 100
GREATER_THAN         : 98
HALT_COMPILER        : 
ID                   : 27
IDENTICAL_TO         : 101
IF                   : 61
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 57 116
INTERFACE            : 
INT_TYPE             : 108
ISSET                : 
ITERABLE             : 
ITERATOR             : 
KEY_VALUE            : 
LAMBDA               : 
LEFT_BRACE           : 81 82
LEFT_BRACKET         : 113 116
LEFT_PAREN           : 21 23 24 37 60 69 70 93 107 110 112
LESS_EQUAL           : 99
LESS_THAN            : 97
LIST                 : 
LOGICAL_AND          : 104
LOGICAL_NOT          : 91
LOGICAL_OR           : 105
LOGICAL_XOR          : 106
LPAREN               : 
MATCH                : 
MINUS                : 52
MINUS_EQUALS         : 33
MINUS_MINUS          : 30
MIXED                : 
MOD                  : 
MOD_EQUALS           : 36
MULTI_LINE_COMMENT   : 10
NAME                 : 21 110
NAMESPACE            : 
NEW                  : 
NOT_EQUAL_TO         : 96
NOT_IDENTICAL_TO     : 102
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 9
OPEN_TAG             : 1
PLUS                 : 51
PLUS_EQUALS          : 32
PLUS_PLUS            : 29
POP                  : 
POPLEFT              : 
POWER                : 
PRINT                : 39
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 22
RIGHT_BRACE          : 81 82
RIGHT_BRACKET        : 113 116
RIGHT_PAREN          : 21 23 24 37 60 73 74 93 107 110 112
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 69 70 73 74 76
SET                  : 
STATIC               : 
STDIN                : 23 24
STRING               : 24 44
SWITCH               : 
THROW                : 
TIMES                : 54
TIMES_EQUALS         : 34
TRAIT                : 
TRUE                 : 87
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
VOID                 : 
WHILE                : 68
YIELD                : 
YIELD_FROM           : 
error                : 
object_declaration   : 

Nonterminals, with rules where they appear

argument             : 28 41 42 43 50 114 115
arguments            : 21 37 38 42 43
array                : 111
array_declaration_statement : 16
array_elements       : 110 112 113 115
array_indexing       : 49
assignment_list      : 69 78
assignment_operator  : 28
assignment_statement : 15 46 77 78
block                : 21 61 64 66 68 75
casting              : 50
casting_type         : 107
complex_condition    : 85
condition            : 11 59 71 91 92 92 93
else_if_extended     : 61 63
expression           : 22 45 51 52 60 94 94
factor               : 54 55 56
fgets_statement      : 14 48
for_part1            : 71 72
for_part3            : 71 72
for_part4            : 73 74
for_statement        : 7
fscanf_statement     : 13
function_call        : 19 47
function_statement   : 8
if_part2             : 62 63
if_part3             : 61
if_statement         : 5
logical_operator     : 92
negated_condition    : 84
parenthesized_condition : 61 64 68 86
print_function       : 37 38
print_statement      : 12
program              : 0
relational_expression : 90
relational_operator  : 94
simple_condition     : 83
statement            : 4 79 80
statement2           : 2 3
statement_list       : 73 80
statement_return     : 20
statements           : 1 3 81
term                 : 51 52 53 54 55
variable             : 25 26 28 29 30 89 111 116
variable_list        : 24 26
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . OPEN_TAG statements CLOSE_TAG

    OPEN_TAG        shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> OPEN_TAG . statements CLOSE_TAG
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . condition
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . statement_return
    (61) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (68) while_statement -> . WHILE parenthesized_condition block
    (71) for_statement -> . for_part1 condition for_part3
    (72) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (111) array_declaration_statement -> . variable EQUALS array
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (22) statement_return -> . RETURN expression
    (69) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (70) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 24
    FUNCTION        shift and go to state 26
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    NAME            shift and go to state 27
    RETURN          shift and go to state 36
    FOR             shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    PRINT           shift and go to state 43
    ECHO            shift and go to state 44
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    statements                     shift and go to state 3
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    condition                      shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    statement_return               shift and go to state 21
    parenthesized_condition        shift and go to state 23
    for_part1                      shift and go to state 25
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    expression                     shift and go to state 37
    relational_expression          shift and go to state 41
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 3

    (1) program -> OPEN_TAG statements . CLOSE_TAG
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . condition
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . statement_return
    (61) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (68) while_statement -> . WHILE parenthesized_condition block
    (71) for_statement -> . for_part1 condition for_part3
    (72) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (111) array_declaration_statement -> . variable EQUALS array
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (22) statement_return -> . RETURN expression
    (69) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (70) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    CLOSE_TAG       shift and go to state 50
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 24
    FUNCTION        shift and go to state 26
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    NAME            shift and go to state 27
    RETURN          shift and go to state 36
    FOR             shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    PRINT           shift and go to state 43
    ECHO            shift and go to state 44
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    statement2                     shift and go to state 51
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    condition                      shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    statement_return               shift and go to state 21
    parenthesized_condition        shift and go to state 23
    for_part1                      shift and go to state 25
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    expression                     shift and go to state 37
    relational_expression          shift and go to state 41
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 4

    (2) statements -> statement2 .

    CLOSE_TAG       reduce using rule 2 (statements -> statement2 .)
    ONE_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    MULTI_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    BREAK           reduce using rule 2 (statements -> statement2 .)
    CONTINUE        reduce using rule 2 (statements -> statement2 .)
    IF              reduce using rule 2 (statements -> statement2 .)
    WHILE           reduce using rule 2 (statements -> statement2 .)
    FUNCTION        reduce using rule 2 (statements -> statement2 .)
    FSCANF          reduce using rule 2 (statements -> statement2 .)
    FGETS           reduce using rule 2 (statements -> statement2 .)
    NAME            reduce using rule 2 (statements -> statement2 .)
    RETURN          reduce using rule 2 (statements -> statement2 .)
    FOR             reduce using rule 2 (statements -> statement2 .)
    TRUE            reduce using rule 2 (statements -> statement2 .)
    FALSE           reduce using rule 2 (statements -> statement2 .)
    LOGICAL_NOT     reduce using rule 2 (statements -> statement2 .)
    LEFT_PAREN      reduce using rule 2 (statements -> statement2 .)
    PRINT           reduce using rule 2 (statements -> statement2 .)
    ECHO            reduce using rule 2 (statements -> statement2 .)
    ID              reduce using rule 2 (statements -> statement2 .)
    INTEGER         reduce using rule 2 (statements -> statement2 .)
    FLOAT           reduce using rule 2 (statements -> statement2 .)
    RIGHT_BRACE     reduce using rule 2 (statements -> statement2 .)


state 5

    (4) statement2 -> statement . SEMICOLON

    SEMICOLON       shift and go to state 52


state 6

    (5) statement2 -> if_statement .

    CLOSE_TAG       reduce using rule 5 (statement2 -> if_statement .)
    ONE_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    MULTI_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    BREAK           reduce using rule 5 (statement2 -> if_statement .)
    CONTINUE        reduce using rule 5 (statement2 -> if_statement .)
    IF              reduce using rule 5 (statement2 -> if_statement .)
    WHILE           reduce using rule 5 (statement2 -> if_statement .)
    FUNCTION        reduce using rule 5 (statement2 -> if_statement .)
    FSCANF          reduce using rule 5 (statement2 -> if_statement .)
    FGETS           reduce using rule 5 (statement2 -> if_statement .)
    NAME            reduce using rule 5 (statement2 -> if_statement .)
    RETURN          reduce using rule 5 (statement2 -> if_statement .)
    FOR             reduce using rule 5 (statement2 -> if_statement .)
    TRUE            reduce using rule 5 (statement2 -> if_statement .)
    FALSE           reduce using rule 5 (statement2 -> if_statement .)
    LOGICAL_NOT     reduce using rule 5 (statement2 -> if_statement .)
    LEFT_PAREN      reduce using rule 5 (statement2 -> if_statement .)
    PRINT           reduce using rule 5 (statement2 -> if_statement .)
    ECHO            reduce using rule 5 (statement2 -> if_statement .)
    ID              reduce using rule 5 (statement2 -> if_statement .)
    INTEGER         reduce using rule 5 (statement2 -> if_statement .)
    FLOAT           reduce using rule 5 (statement2 -> if_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement2 -> if_statement .)


state 7

    (6) statement2 -> while_statement .

    CLOSE_TAG       reduce using rule 6 (statement2 -> while_statement .)
    ONE_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    MULTI_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    BREAK           reduce using rule 6 (statement2 -> while_statement .)
    CONTINUE        reduce using rule 6 (statement2 -> while_statement .)
    IF              reduce using rule 6 (statement2 -> while_statement .)
    WHILE           reduce using rule 6 (statement2 -> while_statement .)
    FUNCTION        reduce using rule 6 (statement2 -> while_statement .)
    FSCANF          reduce using rule 6 (statement2 -> while_statement .)
    FGETS           reduce using rule 6 (statement2 -> while_statement .)
    NAME            reduce using rule 6 (statement2 -> while_statement .)
    RETURN          reduce using rule 6 (statement2 -> while_statement .)
    FOR             reduce using rule 6 (statement2 -> while_statement .)
    TRUE            reduce using rule 6 (statement2 -> while_statement .)
    FALSE           reduce using rule 6 (statement2 -> while_statement .)
    LOGICAL_NOT     reduce using rule 6 (statement2 -> while_statement .)
    LEFT_PAREN      reduce using rule 6 (statement2 -> while_statement .)
    PRINT           reduce using rule 6 (statement2 -> while_statement .)
    ECHO            reduce using rule 6 (statement2 -> while_statement .)
    ID              reduce using rule 6 (statement2 -> while_statement .)
    INTEGER         reduce using rule 6 (statement2 -> while_statement .)
    FLOAT           reduce using rule 6 (statement2 -> while_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement2 -> while_statement .)


state 8

    (7) statement2 -> for_statement .

    CLOSE_TAG       reduce using rule 7 (statement2 -> for_statement .)
    ONE_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    MULTI_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    BREAK           reduce using rule 7 (statement2 -> for_statement .)
    CONTINUE        reduce using rule 7 (statement2 -> for_statement .)
    IF              reduce using rule 7 (statement2 -> for_statement .)
    WHILE           reduce using rule 7 (statement2 -> for_statement .)
    FUNCTION        reduce using rule 7 (statement2 -> for_statement .)
    FSCANF          reduce using rule 7 (statement2 -> for_statement .)
    FGETS           reduce using rule 7 (statement2 -> for_statement .)
    NAME            reduce using rule 7 (statement2 -> for_statement .)
    RETURN          reduce using rule 7 (statement2 -> for_statement .)
    FOR             reduce using rule 7 (statement2 -> for_statement .)
    TRUE            reduce using rule 7 (statement2 -> for_statement .)
    FALSE           reduce using rule 7 (statement2 -> for_statement .)
    LOGICAL_NOT     reduce using rule 7 (statement2 -> for_statement .)
    LEFT_PAREN      reduce using rule 7 (statement2 -> for_statement .)
    PRINT           reduce using rule 7 (statement2 -> for_statement .)
    ECHO            reduce using rule 7 (statement2 -> for_statement .)
    ID              reduce using rule 7 (statement2 -> for_statement .)
    INTEGER         reduce using rule 7 (statement2 -> for_statement .)
    FLOAT           reduce using rule 7 (statement2 -> for_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement2 -> for_statement .)


state 9

    (8) statement2 -> function_statement .

    CLOSE_TAG       reduce using rule 8 (statement2 -> function_statement .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    BREAK           reduce using rule 8 (statement2 -> function_statement .)
    CONTINUE        reduce using rule 8 (statement2 -> function_statement .)
    IF              reduce using rule 8 (statement2 -> function_statement .)
    WHILE           reduce using rule 8 (statement2 -> function_statement .)
    FUNCTION        reduce using rule 8 (statement2 -> function_statement .)
    FSCANF          reduce using rule 8 (statement2 -> function_statement .)
    FGETS           reduce using rule 8 (statement2 -> function_statement .)
    NAME            reduce using rule 8 (statement2 -> function_statement .)
    RETURN          reduce using rule 8 (statement2 -> function_statement .)
    FOR             reduce using rule 8 (statement2 -> function_statement .)
    TRUE            reduce using rule 8 (statement2 -> function_statement .)
    FALSE           reduce using rule 8 (statement2 -> function_statement .)
    LOGICAL_NOT     reduce using rule 8 (statement2 -> function_statement .)
    LEFT_PAREN      reduce using rule 8 (statement2 -> function_statement .)
    PRINT           reduce using rule 8 (statement2 -> function_statement .)
    ECHO            reduce using rule 8 (statement2 -> function_statement .)
    ID              reduce using rule 8 (statement2 -> function_statement .)
    INTEGER         reduce using rule 8 (statement2 -> function_statement .)
    FLOAT           reduce using rule 8 (statement2 -> function_statement .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> function_statement .)


state 10

    (9) statement2 -> ONE_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FUNCTION        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    NAME            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RETURN          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    TRUE            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FALSE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    LOGICAL_NOT     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    LEFT_PAREN      reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    INTEGER         reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FLOAT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)


state 11

    (10) statement2 -> MULTI_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FUNCTION        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    NAME            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RETURN          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    TRUE            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FALSE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    LOGICAL_NOT     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    LEFT_PAREN      reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    INTEGER         reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FLOAT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)


state 12

    (11) statement2 -> condition .
    (92) complex_condition -> condition . logical_operator condition
    (59) factor -> condition .
    (104) logical_operator -> . LOGICAL_AND
    (105) logical_operator -> . LOGICAL_OR
    (106) logical_operator -> . LOGICAL_XOR

    CLOSE_TAG       reduce using rule 11 (statement2 -> condition .)
    ONE_LINE_COMMENT reduce using rule 11 (statement2 -> condition .)
    MULTI_LINE_COMMENT reduce using rule 11 (statement2 -> condition .)
    BREAK           reduce using rule 11 (statement2 -> condition .)
    CONTINUE        reduce using rule 11 (statement2 -> condition .)
    IF              reduce using rule 11 (statement2 -> condition .)
    WHILE           reduce using rule 11 (statement2 -> condition .)
    FUNCTION        reduce using rule 11 (statement2 -> condition .)
    FSCANF          reduce using rule 11 (statement2 -> condition .)
    FGETS           reduce using rule 11 (statement2 -> condition .)
    NAME            reduce using rule 11 (statement2 -> condition .)
    RETURN          reduce using rule 11 (statement2 -> condition .)
    FOR             reduce using rule 11 (statement2 -> condition .)
    TRUE            reduce using rule 11 (statement2 -> condition .)
    FALSE           reduce using rule 11 (statement2 -> condition .)
    LOGICAL_NOT     reduce using rule 11 (statement2 -> condition .)
    LEFT_PAREN      reduce using rule 11 (statement2 -> condition .)
    PRINT           reduce using rule 11 (statement2 -> condition .)
    ECHO            reduce using rule 11 (statement2 -> condition .)
    ID              reduce using rule 11 (statement2 -> condition .)
    INTEGER         reduce using rule 11 (statement2 -> condition .)
    FLOAT           reduce using rule 11 (statement2 -> condition .)
    RIGHT_BRACE     reduce using rule 11 (statement2 -> condition .)
    TIMES           reduce using rule 59 (factor -> condition .)
    DIVIDE          reduce using rule 59 (factor -> condition .)
    PLUS            reduce using rule 59 (factor -> condition .)
    MINUS           reduce using rule 59 (factor -> condition .)
    EQUAL_TO        reduce using rule 59 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> condition .)
    LESS_THAN       reduce using rule 59 (factor -> condition .)
    GREATER_THAN    reduce using rule 59 (factor -> condition .)
    LESS_EQUAL      reduce using rule 59 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 59 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 59 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> condition .)
    DIFFERENT       reduce using rule 59 (factor -> condition .)
    LOGICAL_AND     shift and go to state 54
    LOGICAL_OR      shift and go to state 55
    LOGICAL_XOR     shift and go to state 56

    logical_operator               shift and go to state 53

state 13

    (12) statement -> print_statement .

    SEMICOLON       reduce using rule 12 (statement -> print_statement .)
    RIGHT_PAREN     reduce using rule 12 (statement -> print_statement .)
    COMMA           reduce using rule 12 (statement -> print_statement .)


state 14

    (13) statement -> fscanf_statement .

    SEMICOLON       reduce using rule 13 (statement -> fscanf_statement .)
    RIGHT_PAREN     reduce using rule 13 (statement -> fscanf_statement .)
    COMMA           reduce using rule 13 (statement -> fscanf_statement .)


state 15

    (14) statement -> fgets_statement .

    SEMICOLON       reduce using rule 14 (statement -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 14 (statement -> fgets_statement .)
    COMMA           reduce using rule 14 (statement -> fgets_statement .)


state 16

    (15) statement -> assignment_statement .

    SEMICOLON       reduce using rule 15 (statement -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 15 (statement -> assignment_statement .)
    COMMA           reduce using rule 15 (statement -> assignment_statement .)


state 17

    (16) statement -> array_declaration_statement .

    SEMICOLON       reduce using rule 16 (statement -> array_declaration_statement .)
    RIGHT_PAREN     reduce using rule 16 (statement -> array_declaration_statement .)
    COMMA           reduce using rule 16 (statement -> array_declaration_statement .)


state 18

    (17) statement -> BREAK .

    SEMICOLON       reduce using rule 17 (statement -> BREAK .)
    RIGHT_PAREN     reduce using rule 17 (statement -> BREAK .)
    COMMA           reduce using rule 17 (statement -> BREAK .)


state 19

    (18) statement -> CONTINUE .

    SEMICOLON       reduce using rule 18 (statement -> CONTINUE .)
    RIGHT_PAREN     reduce using rule 18 (statement -> CONTINUE .)
    COMMA           reduce using rule 18 (statement -> CONTINUE .)


state 20

    (19) statement -> function_call .

    SEMICOLON       reduce using rule 19 (statement -> function_call .)
    RIGHT_PAREN     reduce using rule 19 (statement -> function_call .)
    COMMA           reduce using rule 19 (statement -> function_call .)


state 21

    (20) statement -> statement_return .

    SEMICOLON       reduce using rule 20 (statement -> statement_return .)
    RIGHT_PAREN     reduce using rule 20 (statement -> statement_return .)
    COMMA           reduce using rule 20 (statement -> statement_return .)


state 22

    (61) if_statement -> IF . parenthesized_condition block else_if_extended if_part3
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 58

    parenthesized_condition        shift and go to state 57

state 23

    (86) condition -> parenthesized_condition .

    LOGICAL_AND     reduce using rule 86 (condition -> parenthesized_condition .)
    LOGICAL_OR      reduce using rule 86 (condition -> parenthesized_condition .)
    LOGICAL_XOR     reduce using rule 86 (condition -> parenthesized_condition .)
    CLOSE_TAG       reduce using rule 86 (condition -> parenthesized_condition .)
    ONE_LINE_COMMENT reduce using rule 86 (condition -> parenthesized_condition .)
    MULTI_LINE_COMMENT reduce using rule 86 (condition -> parenthesized_condition .)
    BREAK           reduce using rule 86 (condition -> parenthesized_condition .)
    CONTINUE        reduce using rule 86 (condition -> parenthesized_condition .)
    IF              reduce using rule 86 (condition -> parenthesized_condition .)
    WHILE           reduce using rule 86 (condition -> parenthesized_condition .)
    FUNCTION        reduce using rule 86 (condition -> parenthesized_condition .)
    FSCANF          reduce using rule 86 (condition -> parenthesized_condition .)
    FGETS           reduce using rule 86 (condition -> parenthesized_condition .)
    NAME            reduce using rule 86 (condition -> parenthesized_condition .)
    RETURN          reduce using rule 86 (condition -> parenthesized_condition .)
    FOR             reduce using rule 86 (condition -> parenthesized_condition .)
    TRUE            reduce using rule 86 (condition -> parenthesized_condition .)
    FALSE           reduce using rule 86 (condition -> parenthesized_condition .)
    LOGICAL_NOT     reduce using rule 86 (condition -> parenthesized_condition .)
    LEFT_PAREN      reduce using rule 86 (condition -> parenthesized_condition .)
    PRINT           reduce using rule 86 (condition -> parenthesized_condition .)
    ECHO            reduce using rule 86 (condition -> parenthesized_condition .)
    ID              reduce using rule 86 (condition -> parenthesized_condition .)
    INTEGER         reduce using rule 86 (condition -> parenthesized_condition .)
    FLOAT           reduce using rule 86 (condition -> parenthesized_condition .)
    TIMES           reduce using rule 86 (condition -> parenthesized_condition .)
    DIVIDE          reduce using rule 86 (condition -> parenthesized_condition .)
    PLUS            reduce using rule 86 (condition -> parenthesized_condition .)
    MINUS           reduce using rule 86 (condition -> parenthesized_condition .)
    EQUAL_TO        reduce using rule 86 (condition -> parenthesized_condition .)
    NOT_EQUAL_TO    reduce using rule 86 (condition -> parenthesized_condition .)
    LESS_THAN       reduce using rule 86 (condition -> parenthesized_condition .)
    GREATER_THAN    reduce using rule 86 (condition -> parenthesized_condition .)
    LESS_EQUAL      reduce using rule 86 (condition -> parenthesized_condition .)
    GREATER_EQUAL   reduce using rule 86 (condition -> parenthesized_condition .)
    IDENTICAL_TO    reduce using rule 86 (condition -> parenthesized_condition .)
    NOT_IDENTICAL_TO reduce using rule 86 (condition -> parenthesized_condition .)
    DIFFERENT       reduce using rule 86 (condition -> parenthesized_condition .)
    SEMICOLON       reduce using rule 86 (condition -> parenthesized_condition .)
    RIGHT_PAREN     reduce using rule 86 (condition -> parenthesized_condition .)
    DOT             reduce using rule 86 (condition -> parenthesized_condition .)
    COMMA           reduce using rule 86 (condition -> parenthesized_condition .)
    RIGHT_BRACKET   reduce using rule 86 (condition -> parenthesized_condition .)
    RIGHT_BRACE     reduce using rule 86 (condition -> parenthesized_condition .)


state 24

    (68) while_statement -> WHILE . parenthesized_condition block
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 58

    parenthesized_condition        shift and go to state 59

state 25

    (71) for_statement -> for_part1 . condition for_part3
    (72) for_statement -> for_part1 . for_part3
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (73) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (74) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    SEMICOLON       shift and go to state 62
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 60
    for_part3                      shift and go to state 61
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41
    expression                     shift and go to state 37
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 26

    (21) function_statement -> FUNCTION . NAME LEFT_PAREN arguments RIGHT_PAREN block

    NAME            shift and go to state 64


state 27

    (110) function_call -> NAME . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 65


state 28

    (93) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (60) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 66
    expression                     shift and go to state 67
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    term                           shift and go to state 46
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41
    factor                         shift and go to state 47

state 29

    (83) condition -> simple_condition .

    LOGICAL_AND     reduce using rule 83 (condition -> simple_condition .)
    LOGICAL_OR      reduce using rule 83 (condition -> simple_condition .)
    LOGICAL_XOR     reduce using rule 83 (condition -> simple_condition .)
    CLOSE_TAG       reduce using rule 83 (condition -> simple_condition .)
    ONE_LINE_COMMENT reduce using rule 83 (condition -> simple_condition .)
    MULTI_LINE_COMMENT reduce using rule 83 (condition -> simple_condition .)
    BREAK           reduce using rule 83 (condition -> simple_condition .)
    CONTINUE        reduce using rule 83 (condition -> simple_condition .)
    IF              reduce using rule 83 (condition -> simple_condition .)
    WHILE           reduce using rule 83 (condition -> simple_condition .)
    FUNCTION        reduce using rule 83 (condition -> simple_condition .)
    FSCANF          reduce using rule 83 (condition -> simple_condition .)
    FGETS           reduce using rule 83 (condition -> simple_condition .)
    NAME            reduce using rule 83 (condition -> simple_condition .)
    RETURN          reduce using rule 83 (condition -> simple_condition .)
    FOR             reduce using rule 83 (condition -> simple_condition .)
    TRUE            reduce using rule 83 (condition -> simple_condition .)
    FALSE           reduce using rule 83 (condition -> simple_condition .)
    LOGICAL_NOT     reduce using rule 83 (condition -> simple_condition .)
    LEFT_PAREN      reduce using rule 83 (condition -> simple_condition .)
    PRINT           reduce using rule 83 (condition -> simple_condition .)
    ECHO            reduce using rule 83 (condition -> simple_condition .)
    ID              reduce using rule 83 (condition -> simple_condition .)
    INTEGER         reduce using rule 83 (condition -> simple_condition .)
    FLOAT           reduce using rule 83 (condition -> simple_condition .)
    TIMES           reduce using rule 83 (condition -> simple_condition .)
    DIVIDE          reduce using rule 83 (condition -> simple_condition .)
    PLUS            reduce using rule 83 (condition -> simple_condition .)
    MINUS           reduce using rule 83 (condition -> simple_condition .)
    EQUAL_TO        reduce using rule 83 (condition -> simple_condition .)
    NOT_EQUAL_TO    reduce using rule 83 (condition -> simple_condition .)
    LESS_THAN       reduce using rule 83 (condition -> simple_condition .)
    GREATER_THAN    reduce using rule 83 (condition -> simple_condition .)
    LESS_EQUAL      reduce using rule 83 (condition -> simple_condition .)
    GREATER_EQUAL   reduce using rule 83 (condition -> simple_condition .)
    IDENTICAL_TO    reduce using rule 83 (condition -> simple_condition .)
    NOT_IDENTICAL_TO reduce using rule 83 (condition -> simple_condition .)
    DIFFERENT       reduce using rule 83 (condition -> simple_condition .)
    SEMICOLON       reduce using rule 83 (condition -> simple_condition .)
    RIGHT_PAREN     reduce using rule 83 (condition -> simple_condition .)
    DOT             reduce using rule 83 (condition -> simple_condition .)
    COMMA           reduce using rule 83 (condition -> simple_condition .)
    RIGHT_BRACKET   reduce using rule 83 (condition -> simple_condition .)
    RIGHT_BRACE     reduce using rule 83 (condition -> simple_condition .)


state 30

    (84) condition -> negated_condition .

    LOGICAL_AND     reduce using rule 84 (condition -> negated_condition .)
    LOGICAL_OR      reduce using rule 84 (condition -> negated_condition .)
    LOGICAL_XOR     reduce using rule 84 (condition -> negated_condition .)
    CLOSE_TAG       reduce using rule 84 (condition -> negated_condition .)
    ONE_LINE_COMMENT reduce using rule 84 (condition -> negated_condition .)
    MULTI_LINE_COMMENT reduce using rule 84 (condition -> negated_condition .)
    BREAK           reduce using rule 84 (condition -> negated_condition .)
    CONTINUE        reduce using rule 84 (condition -> negated_condition .)
    IF              reduce using rule 84 (condition -> negated_condition .)
    WHILE           reduce using rule 84 (condition -> negated_condition .)
    FUNCTION        reduce using rule 84 (condition -> negated_condition .)
    FSCANF          reduce using rule 84 (condition -> negated_condition .)
    FGETS           reduce using rule 84 (condition -> negated_condition .)
    NAME            reduce using rule 84 (condition -> negated_condition .)
    RETURN          reduce using rule 84 (condition -> negated_condition .)
    FOR             reduce using rule 84 (condition -> negated_condition .)
    TRUE            reduce using rule 84 (condition -> negated_condition .)
    FALSE           reduce using rule 84 (condition -> negated_condition .)
    LOGICAL_NOT     reduce using rule 84 (condition -> negated_condition .)
    LEFT_PAREN      reduce using rule 84 (condition -> negated_condition .)
    PRINT           reduce using rule 84 (condition -> negated_condition .)
    ECHO            reduce using rule 84 (condition -> negated_condition .)
    ID              reduce using rule 84 (condition -> negated_condition .)
    INTEGER         reduce using rule 84 (condition -> negated_condition .)
    FLOAT           reduce using rule 84 (condition -> negated_condition .)
    TIMES           reduce using rule 84 (condition -> negated_condition .)
    DIVIDE          reduce using rule 84 (condition -> negated_condition .)
    PLUS            reduce using rule 84 (condition -> negated_condition .)
    MINUS           reduce using rule 84 (condition -> negated_condition .)
    EQUAL_TO        reduce using rule 84 (condition -> negated_condition .)
    NOT_EQUAL_TO    reduce using rule 84 (condition -> negated_condition .)
    LESS_THAN       reduce using rule 84 (condition -> negated_condition .)
    GREATER_THAN    reduce using rule 84 (condition -> negated_condition .)
    LESS_EQUAL      reduce using rule 84 (condition -> negated_condition .)
    GREATER_EQUAL   reduce using rule 84 (condition -> negated_condition .)
    IDENTICAL_TO    reduce using rule 84 (condition -> negated_condition .)
    NOT_IDENTICAL_TO reduce using rule 84 (condition -> negated_condition .)
    DIFFERENT       reduce using rule 84 (condition -> negated_condition .)
    SEMICOLON       reduce using rule 84 (condition -> negated_condition .)
    RIGHT_PAREN     reduce using rule 84 (condition -> negated_condition .)
    DOT             reduce using rule 84 (condition -> negated_condition .)
    COMMA           reduce using rule 84 (condition -> negated_condition .)
    RIGHT_BRACKET   reduce using rule 84 (condition -> negated_condition .)
    RIGHT_BRACE     reduce using rule 84 (condition -> negated_condition .)


state 31

    (85) condition -> complex_condition .

    LOGICAL_AND     reduce using rule 85 (condition -> complex_condition .)
    LOGICAL_OR      reduce using rule 85 (condition -> complex_condition .)
    LOGICAL_XOR     reduce using rule 85 (condition -> complex_condition .)
    CLOSE_TAG       reduce using rule 85 (condition -> complex_condition .)
    ONE_LINE_COMMENT reduce using rule 85 (condition -> complex_condition .)
    MULTI_LINE_COMMENT reduce using rule 85 (condition -> complex_condition .)
    BREAK           reduce using rule 85 (condition -> complex_condition .)
    CONTINUE        reduce using rule 85 (condition -> complex_condition .)
    IF              reduce using rule 85 (condition -> complex_condition .)
    WHILE           reduce using rule 85 (condition -> complex_condition .)
    FUNCTION        reduce using rule 85 (condition -> complex_condition .)
    FSCANF          reduce using rule 85 (condition -> complex_condition .)
    FGETS           reduce using rule 85 (condition -> complex_condition .)
    NAME            reduce using rule 85 (condition -> complex_condition .)
    RETURN          reduce using rule 85 (condition -> complex_condition .)
    FOR             reduce using rule 85 (condition -> complex_condition .)
    TRUE            reduce using rule 85 (condition -> complex_condition .)
    FALSE           reduce using rule 85 (condition -> complex_condition .)
    LOGICAL_NOT     reduce using rule 85 (condition -> complex_condition .)
    LEFT_PAREN      reduce using rule 85 (condition -> complex_condition .)
    PRINT           reduce using rule 85 (condition -> complex_condition .)
    ECHO            reduce using rule 85 (condition -> complex_condition .)
    ID              reduce using rule 85 (condition -> complex_condition .)
    INTEGER         reduce using rule 85 (condition -> complex_condition .)
    FLOAT           reduce using rule 85 (condition -> complex_condition .)
    TIMES           reduce using rule 85 (condition -> complex_condition .)
    DIVIDE          reduce using rule 85 (condition -> complex_condition .)
    PLUS            reduce using rule 85 (condition -> complex_condition .)
    MINUS           reduce using rule 85 (condition -> complex_condition .)
    EQUAL_TO        reduce using rule 85 (condition -> complex_condition .)
    NOT_EQUAL_TO    reduce using rule 85 (condition -> complex_condition .)
    LESS_THAN       reduce using rule 85 (condition -> complex_condition .)
    GREATER_THAN    reduce using rule 85 (condition -> complex_condition .)
    LESS_EQUAL      reduce using rule 85 (condition -> complex_condition .)
    GREATER_EQUAL   reduce using rule 85 (condition -> complex_condition .)
    IDENTICAL_TO    reduce using rule 85 (condition -> complex_condition .)
    NOT_IDENTICAL_TO reduce using rule 85 (condition -> complex_condition .)
    DIFFERENT       reduce using rule 85 (condition -> complex_condition .)
    SEMICOLON       reduce using rule 85 (condition -> complex_condition .)
    RIGHT_PAREN     reduce using rule 85 (condition -> complex_condition .)
    DOT             reduce using rule 85 (condition -> complex_condition .)
    COMMA           reduce using rule 85 (condition -> complex_condition .)
    RIGHT_BRACKET   reduce using rule 85 (condition -> complex_condition .)
    RIGHT_BRACE     reduce using rule 85 (condition -> complex_condition .)


state 32

    (37) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> print_function . arguments
    (41) arguments -> . argument
    (42) arguments -> . arguments DOT argument
    (43) arguments -> . arguments COMMA argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    LEFT_PAREN      shift and go to state 68
    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    arguments                      shift and go to state 69
    argument                       shift and go to state 70
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 33

    (24) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 80


state 34

    (23) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 81


state 35

    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (111) array_declaration_statement -> variable . EQUALS array
    (89) simple_condition -> variable .
    (31) assignment_operator -> . EQUALS
    (32) assignment_operator -> . PLUS_EQUALS
    (33) assignment_operator -> . MINUS_EQUALS
    (34) assignment_operator -> . TIMES_EQUALS
    (35) assignment_operator -> . DIVIDE_EQUALS
    (36) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 83
    MINUS_MINUS     shift and go to state 84
    EQUALS          shift and go to state 85
    LOGICAL_AND     reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 89 (simple_condition -> variable .)
    CLOSE_TAG       reduce using rule 89 (simple_condition -> variable .)
    ONE_LINE_COMMENT reduce using rule 89 (simple_condition -> variable .)
    MULTI_LINE_COMMENT reduce using rule 89 (simple_condition -> variable .)
    BREAK           reduce using rule 89 (simple_condition -> variable .)
    CONTINUE        reduce using rule 89 (simple_condition -> variable .)
    IF              reduce using rule 89 (simple_condition -> variable .)
    WHILE           reduce using rule 89 (simple_condition -> variable .)
    FUNCTION        reduce using rule 89 (simple_condition -> variable .)
    FSCANF          reduce using rule 89 (simple_condition -> variable .)
    FGETS           reduce using rule 89 (simple_condition -> variable .)
    NAME            reduce using rule 89 (simple_condition -> variable .)
    RETURN          reduce using rule 89 (simple_condition -> variable .)
    FOR             reduce using rule 89 (simple_condition -> variable .)
    TRUE            reduce using rule 89 (simple_condition -> variable .)
    FALSE           reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_NOT     reduce using rule 89 (simple_condition -> variable .)
    LEFT_PAREN      reduce using rule 89 (simple_condition -> variable .)
    PRINT           reduce using rule 89 (simple_condition -> variable .)
    ECHO            reduce using rule 89 (simple_condition -> variable .)
    ID              reduce using rule 89 (simple_condition -> variable .)
    INTEGER         reduce using rule 89 (simple_condition -> variable .)
    FLOAT           reduce using rule 89 (simple_condition -> variable .)
    TIMES           reduce using rule 89 (simple_condition -> variable .)
    DIVIDE          reduce using rule 89 (simple_condition -> variable .)
    PLUS            reduce using rule 89 (simple_condition -> variable .)
    MINUS           reduce using rule 89 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 89 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 89 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 89 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 89 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 89 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 89 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 89 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 89 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 89 (simple_condition -> variable .)
    RIGHT_BRACE     reduce using rule 89 (simple_condition -> variable .)
    PLUS_EQUALS     shift and go to state 86
    MINUS_EQUALS    shift and go to state 87
    TIMES_EQUALS    shift and go to state 88
    DIVIDE_EQUALS   shift and go to state 89
    MOD_EQUALS      shift and go to state 90

    assignment_operator            shift and go to state 82

state 36

    (22) statement_return -> RETURN . expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LEFT_PAREN      shift and go to state 92
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    ID              shift and go to state 45

    expression                     shift and go to state 91
    term                           shift and go to state 46
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 37

    (94) relational_expression -> expression . relational_operator expression
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (95) relational_operator -> . EQUAL_TO
    (96) relational_operator -> . NOT_EQUAL_TO
    (97) relational_operator -> . LESS_THAN
    (98) relational_operator -> . GREATER_THAN
    (99) relational_operator -> . LESS_EQUAL
    (100) relational_operator -> . GREATER_EQUAL
    (101) relational_operator -> . IDENTICAL_TO
    (102) relational_operator -> . NOT_IDENTICAL_TO
    (103) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    EQUAL_TO        shift and go to state 96
    NOT_EQUAL_TO    shift and go to state 97
    LESS_THAN       shift and go to state 98
    GREATER_THAN    shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    IDENTICAL_TO    shift and go to state 102
    NOT_IDENTICAL_TO shift and go to state 103
    DIFFERENT       shift and go to state 104

    relational_operator            shift and go to state 93

state 38

    (69) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (70) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 105


state 39

    (87) simple_condition -> TRUE .

    LOGICAL_AND     reduce using rule 87 (simple_condition -> TRUE .)
    LOGICAL_OR      reduce using rule 87 (simple_condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 87 (simple_condition -> TRUE .)
    CLOSE_TAG       reduce using rule 87 (simple_condition -> TRUE .)
    ONE_LINE_COMMENT reduce using rule 87 (simple_condition -> TRUE .)
    MULTI_LINE_COMMENT reduce using rule 87 (simple_condition -> TRUE .)
    BREAK           reduce using rule 87 (simple_condition -> TRUE .)
    CONTINUE        reduce using rule 87 (simple_condition -> TRUE .)
    IF              reduce using rule 87 (simple_condition -> TRUE .)
    WHILE           reduce using rule 87 (simple_condition -> TRUE .)
    FUNCTION        reduce using rule 87 (simple_condition -> TRUE .)
    FSCANF          reduce using rule 87 (simple_condition -> TRUE .)
    FGETS           reduce using rule 87 (simple_condition -> TRUE .)
    NAME            reduce using rule 87 (simple_condition -> TRUE .)
    RETURN          reduce using rule 87 (simple_condition -> TRUE .)
    FOR             reduce using rule 87 (simple_condition -> TRUE .)
    TRUE            reduce using rule 87 (simple_condition -> TRUE .)
    FALSE           reduce using rule 87 (simple_condition -> TRUE .)
    LOGICAL_NOT     reduce using rule 87 (simple_condition -> TRUE .)
    LEFT_PAREN      reduce using rule 87 (simple_condition -> TRUE .)
    PRINT           reduce using rule 87 (simple_condition -> TRUE .)
    ECHO            reduce using rule 87 (simple_condition -> TRUE .)
    ID              reduce using rule 87 (simple_condition -> TRUE .)
    INTEGER         reduce using rule 87 (simple_condition -> TRUE .)
    FLOAT           reduce using rule 87 (simple_condition -> TRUE .)
    TIMES           reduce using rule 87 (simple_condition -> TRUE .)
    DIVIDE          reduce using rule 87 (simple_condition -> TRUE .)
    PLUS            reduce using rule 87 (simple_condition -> TRUE .)
    MINUS           reduce using rule 87 (simple_condition -> TRUE .)
    EQUAL_TO        reduce using rule 87 (simple_condition -> TRUE .)
    NOT_EQUAL_TO    reduce using rule 87 (simple_condition -> TRUE .)
    LESS_THAN       reduce using rule 87 (simple_condition -> TRUE .)
    GREATER_THAN    reduce using rule 87 (simple_condition -> TRUE .)
    LESS_EQUAL      reduce using rule 87 (simple_condition -> TRUE .)
    GREATER_EQUAL   reduce using rule 87 (simple_condition -> TRUE .)
    IDENTICAL_TO    reduce using rule 87 (simple_condition -> TRUE .)
    NOT_IDENTICAL_TO reduce using rule 87 (simple_condition -> TRUE .)
    DIFFERENT       reduce using rule 87 (simple_condition -> TRUE .)
    SEMICOLON       reduce using rule 87 (simple_condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 87 (simple_condition -> TRUE .)
    DOT             reduce using rule 87 (simple_condition -> TRUE .)
    COMMA           reduce using rule 87 (simple_condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 87 (simple_condition -> TRUE .)
    RIGHT_BRACE     reduce using rule 87 (simple_condition -> TRUE .)


state 40

    (88) simple_condition -> FALSE .

    LOGICAL_AND     reduce using rule 88 (simple_condition -> FALSE .)
    LOGICAL_OR      reduce using rule 88 (simple_condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 88 (simple_condition -> FALSE .)
    CLOSE_TAG       reduce using rule 88 (simple_condition -> FALSE .)
    ONE_LINE_COMMENT reduce using rule 88 (simple_condition -> FALSE .)
    MULTI_LINE_COMMENT reduce using rule 88 (simple_condition -> FALSE .)
    BREAK           reduce using rule 88 (simple_condition -> FALSE .)
    CONTINUE        reduce using rule 88 (simple_condition -> FALSE .)
    IF              reduce using rule 88 (simple_condition -> FALSE .)
    WHILE           reduce using rule 88 (simple_condition -> FALSE .)
    FUNCTION        reduce using rule 88 (simple_condition -> FALSE .)
    FSCANF          reduce using rule 88 (simple_condition -> FALSE .)
    FGETS           reduce using rule 88 (simple_condition -> FALSE .)
    NAME            reduce using rule 88 (simple_condition -> FALSE .)
    RETURN          reduce using rule 88 (simple_condition -> FALSE .)
    FOR             reduce using rule 88 (simple_condition -> FALSE .)
    TRUE            reduce using rule 88 (simple_condition -> FALSE .)
    FALSE           reduce using rule 88 (simple_condition -> FALSE .)
    LOGICAL_NOT     reduce using rule 88 (simple_condition -> FALSE .)
    LEFT_PAREN      reduce using rule 88 (simple_condition -> FALSE .)
    PRINT           reduce using rule 88 (simple_condition -> FALSE .)
    ECHO            reduce using rule 88 (simple_condition -> FALSE .)
    ID              reduce using rule 88 (simple_condition -> FALSE .)
    INTEGER         reduce using rule 88 (simple_condition -> FALSE .)
    FLOAT           reduce using rule 88 (simple_condition -> FALSE .)
    TIMES           reduce using rule 88 (simple_condition -> FALSE .)
    DIVIDE          reduce using rule 88 (simple_condition -> FALSE .)
    PLUS            reduce using rule 88 (simple_condition -> FALSE .)
    MINUS           reduce using rule 88 (simple_condition -> FALSE .)
    EQUAL_TO        reduce using rule 88 (simple_condition -> FALSE .)
    NOT_EQUAL_TO    reduce using rule 88 (simple_condition -> FALSE .)
    LESS_THAN       reduce using rule 88 (simple_condition -> FALSE .)
    GREATER_THAN    reduce using rule 88 (simple_condition -> FALSE .)
    LESS_EQUAL      reduce using rule 88 (simple_condition -> FALSE .)
    GREATER_EQUAL   reduce using rule 88 (simple_condition -> FALSE .)
    IDENTICAL_TO    reduce using rule 88 (simple_condition -> FALSE .)
    NOT_IDENTICAL_TO reduce using rule 88 (simple_condition -> FALSE .)
    DIFFERENT       reduce using rule 88 (simple_condition -> FALSE .)
    SEMICOLON       reduce using rule 88 (simple_condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 88 (simple_condition -> FALSE .)
    DOT             reduce using rule 88 (simple_condition -> FALSE .)
    COMMA           reduce using rule 88 (simple_condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 88 (simple_condition -> FALSE .)
    RIGHT_BRACE     reduce using rule 88 (simple_condition -> FALSE .)


state 41

    (90) simple_condition -> relational_expression .

    LOGICAL_AND     reduce using rule 90 (simple_condition -> relational_expression .)
    LOGICAL_OR      reduce using rule 90 (simple_condition -> relational_expression .)
    LOGICAL_XOR     reduce using rule 90 (simple_condition -> relational_expression .)
    CLOSE_TAG       reduce using rule 90 (simple_condition -> relational_expression .)
    ONE_LINE_COMMENT reduce using rule 90 (simple_condition -> relational_expression .)
    MULTI_LINE_COMMENT reduce using rule 90 (simple_condition -> relational_expression .)
    BREAK           reduce using rule 90 (simple_condition -> relational_expression .)
    CONTINUE        reduce using rule 90 (simple_condition -> relational_expression .)
    IF              reduce using rule 90 (simple_condition -> relational_expression .)
    WHILE           reduce using rule 90 (simple_condition -> relational_expression .)
    FUNCTION        reduce using rule 90 (simple_condition -> relational_expression .)
    FSCANF          reduce using rule 90 (simple_condition -> relational_expression .)
    FGETS           reduce using rule 90 (simple_condition -> relational_expression .)
    NAME            reduce using rule 90 (simple_condition -> relational_expression .)
    RETURN          reduce using rule 90 (simple_condition -> relational_expression .)
    FOR             reduce using rule 90 (simple_condition -> relational_expression .)
    TRUE            reduce using rule 90 (simple_condition -> relational_expression .)
    FALSE           reduce using rule 90 (simple_condition -> relational_expression .)
    LOGICAL_NOT     reduce using rule 90 (simple_condition -> relational_expression .)
    LEFT_PAREN      reduce using rule 90 (simple_condition -> relational_expression .)
    PRINT           reduce using rule 90 (simple_condition -> relational_expression .)
    ECHO            reduce using rule 90 (simple_condition -> relational_expression .)
    ID              reduce using rule 90 (simple_condition -> relational_expression .)
    INTEGER         reduce using rule 90 (simple_condition -> relational_expression .)
    FLOAT           reduce using rule 90 (simple_condition -> relational_expression .)
    TIMES           reduce using rule 90 (simple_condition -> relational_expression .)
    DIVIDE          reduce using rule 90 (simple_condition -> relational_expression .)
    PLUS            reduce using rule 90 (simple_condition -> relational_expression .)
    MINUS           reduce using rule 90 (simple_condition -> relational_expression .)
    EQUAL_TO        reduce using rule 90 (simple_condition -> relational_expression .)
    NOT_EQUAL_TO    reduce using rule 90 (simple_condition -> relational_expression .)
    LESS_THAN       reduce using rule 90 (simple_condition -> relational_expression .)
    GREATER_THAN    reduce using rule 90 (simple_condition -> relational_expression .)
    LESS_EQUAL      reduce using rule 90 (simple_condition -> relational_expression .)
    GREATER_EQUAL   reduce using rule 90 (simple_condition -> relational_expression .)
    IDENTICAL_TO    reduce using rule 90 (simple_condition -> relational_expression .)
    NOT_IDENTICAL_TO reduce using rule 90 (simple_condition -> relational_expression .)
    DIFFERENT       reduce using rule 90 (simple_condition -> relational_expression .)
    SEMICOLON       reduce using rule 90 (simple_condition -> relational_expression .)
    RIGHT_PAREN     reduce using rule 90 (simple_condition -> relational_expression .)
    DOT             reduce using rule 90 (simple_condition -> relational_expression .)
    COMMA           reduce using rule 90 (simple_condition -> relational_expression .)
    RIGHT_BRACKET   reduce using rule 90 (simple_condition -> relational_expression .)
    RIGHT_BRACE     reduce using rule 90 (simple_condition -> relational_expression .)


state 42

    (91) negated_condition -> LOGICAL_NOT . condition
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 106
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41
    expression                     shift and go to state 37
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 43

    (39) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 39 (print_function -> PRINT .)
    STRING          reduce using rule 39 (print_function -> PRINT .)
    NAME            reduce using rule 39 (print_function -> PRINT .)
    FGETS           reduce using rule 39 (print_function -> PRINT .)
    ID              reduce using rule 39 (print_function -> PRINT .)
    INTEGER         reduce using rule 39 (print_function -> PRINT .)
    FLOAT           reduce using rule 39 (print_function -> PRINT .)
    TRUE            reduce using rule 39 (print_function -> PRINT .)
    FALSE           reduce using rule 39 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 39 (print_function -> PRINT .)


state 44

    (40) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 40 (print_function -> ECHO .)
    STRING          reduce using rule 40 (print_function -> ECHO .)
    NAME            reduce using rule 40 (print_function -> ECHO .)
    FGETS           reduce using rule 40 (print_function -> ECHO .)
    ID              reduce using rule 40 (print_function -> ECHO .)
    INTEGER         reduce using rule 40 (print_function -> ECHO .)
    FLOAT           reduce using rule 40 (print_function -> ECHO .)
    TRUE            reduce using rule 40 (print_function -> ECHO .)
    FALSE           reduce using rule 40 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 40 (print_function -> ECHO .)


state 45

    (27) variable -> ID .

    PLUS_PLUS       reduce using rule 27 (variable -> ID .)
    MINUS_MINUS     reduce using rule 27 (variable -> ID .)
    EQUALS          reduce using rule 27 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 27 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 27 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 27 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 27 (variable -> ID .)
    MOD_EQUALS      reduce using rule 27 (variable -> ID .)
    LOGICAL_AND     reduce using rule 27 (variable -> ID .)
    LOGICAL_OR      reduce using rule 27 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 27 (variable -> ID .)
    CLOSE_TAG       reduce using rule 27 (variable -> ID .)
    ONE_LINE_COMMENT reduce using rule 27 (variable -> ID .)
    MULTI_LINE_COMMENT reduce using rule 27 (variable -> ID .)
    BREAK           reduce using rule 27 (variable -> ID .)
    CONTINUE        reduce using rule 27 (variable -> ID .)
    IF              reduce using rule 27 (variable -> ID .)
    WHILE           reduce using rule 27 (variable -> ID .)
    FUNCTION        reduce using rule 27 (variable -> ID .)
    FSCANF          reduce using rule 27 (variable -> ID .)
    FGETS           reduce using rule 27 (variable -> ID .)
    NAME            reduce using rule 27 (variable -> ID .)
    RETURN          reduce using rule 27 (variable -> ID .)
    FOR             reduce using rule 27 (variable -> ID .)
    TRUE            reduce using rule 27 (variable -> ID .)
    FALSE           reduce using rule 27 (variable -> ID .)
    LOGICAL_NOT     reduce using rule 27 (variable -> ID .)
    LEFT_PAREN      reduce using rule 27 (variable -> ID .)
    PRINT           reduce using rule 27 (variable -> ID .)
    ECHO            reduce using rule 27 (variable -> ID .)
    ID              reduce using rule 27 (variable -> ID .)
    INTEGER         reduce using rule 27 (variable -> ID .)
    FLOAT           reduce using rule 27 (variable -> ID .)
    TIMES           reduce using rule 27 (variable -> ID .)
    DIVIDE          reduce using rule 27 (variable -> ID .)
    PLUS            reduce using rule 27 (variable -> ID .)
    MINUS           reduce using rule 27 (variable -> ID .)
    EQUAL_TO        reduce using rule 27 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 27 (variable -> ID .)
    LESS_THAN       reduce using rule 27 (variable -> ID .)
    GREATER_THAN    reduce using rule 27 (variable -> ID .)
    LESS_EQUAL      reduce using rule 27 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 27 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 27 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 27 (variable -> ID .)
    DIFFERENT       reduce using rule 27 (variable -> ID .)
    SEMICOLON       reduce using rule 27 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 27 (variable -> ID .)
    LEFT_BRACKET    reduce using rule 27 (variable -> ID .)
    DOT             reduce using rule 27 (variable -> ID .)
    COMMA           reduce using rule 27 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 27 (variable -> ID .)
    RIGHT_BRACE     reduce using rule 27 (variable -> ID .)


state 46

    (53) expression -> term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 53 (expression -> term .)
    MINUS           reduce using rule 53 (expression -> term .)
    EQUAL_TO        reduce using rule 53 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 53 (expression -> term .)
    LESS_THAN       reduce using rule 53 (expression -> term .)
    GREATER_THAN    reduce using rule 53 (expression -> term .)
    LESS_EQUAL      reduce using rule 53 (expression -> term .)
    GREATER_EQUAL   reduce using rule 53 (expression -> term .)
    IDENTICAL_TO    reduce using rule 53 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 53 (expression -> term .)
    DIFFERENT       reduce using rule 53 (expression -> term .)
    RIGHT_PAREN     reduce using rule 53 (expression -> term .)
    DOT             reduce using rule 53 (expression -> term .)
    COMMA           reduce using rule 53 (expression -> term .)
    SEMICOLON       reduce using rule 53 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 53 (expression -> term .)
    LOGICAL_AND     reduce using rule 53 (expression -> term .)
    LOGICAL_OR      reduce using rule 53 (expression -> term .)
    LOGICAL_XOR     reduce using rule 53 (expression -> term .)
    CLOSE_TAG       reduce using rule 53 (expression -> term .)
    ONE_LINE_COMMENT reduce using rule 53 (expression -> term .)
    MULTI_LINE_COMMENT reduce using rule 53 (expression -> term .)
    BREAK           reduce using rule 53 (expression -> term .)
    CONTINUE        reduce using rule 53 (expression -> term .)
    IF              reduce using rule 53 (expression -> term .)
    WHILE           reduce using rule 53 (expression -> term .)
    FUNCTION        reduce using rule 53 (expression -> term .)
    FSCANF          reduce using rule 53 (expression -> term .)
    FGETS           reduce using rule 53 (expression -> term .)
    NAME            reduce using rule 53 (expression -> term .)
    RETURN          reduce using rule 53 (expression -> term .)
    FOR             reduce using rule 53 (expression -> term .)
    TRUE            reduce using rule 53 (expression -> term .)
    FALSE           reduce using rule 53 (expression -> term .)
    LOGICAL_NOT     reduce using rule 53 (expression -> term .)
    LEFT_PAREN      reduce using rule 53 (expression -> term .)
    PRINT           reduce using rule 53 (expression -> term .)
    ECHO            reduce using rule 53 (expression -> term .)
    ID              reduce using rule 53 (expression -> term .)
    INTEGER         reduce using rule 53 (expression -> term .)
    FLOAT           reduce using rule 53 (expression -> term .)
    RIGHT_BRACE     reduce using rule 53 (expression -> term .)
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 108

  ! TIMES           [ reduce using rule 53 (expression -> term .) ]
  ! DIVIDE          [ reduce using rule 53 (expression -> term .) ]


state 47

    (56) term -> factor .

    TIMES           reduce using rule 56 (term -> factor .)
    DIVIDE          reduce using rule 56 (term -> factor .)
    PLUS            reduce using rule 56 (term -> factor .)
    MINUS           reduce using rule 56 (term -> factor .)
    EQUAL_TO        reduce using rule 56 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 56 (term -> factor .)
    LESS_THAN       reduce using rule 56 (term -> factor .)
    GREATER_THAN    reduce using rule 56 (term -> factor .)
    LESS_EQUAL      reduce using rule 56 (term -> factor .)
    GREATER_EQUAL   reduce using rule 56 (term -> factor .)
    IDENTICAL_TO    reduce using rule 56 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 56 (term -> factor .)
    DIFFERENT       reduce using rule 56 (term -> factor .)
    RIGHT_PAREN     reduce using rule 56 (term -> factor .)
    DOT             reduce using rule 56 (term -> factor .)
    COMMA           reduce using rule 56 (term -> factor .)
    SEMICOLON       reduce using rule 56 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 56 (term -> factor .)
    LOGICAL_AND     reduce using rule 56 (term -> factor .)
    LOGICAL_OR      reduce using rule 56 (term -> factor .)
    LOGICAL_XOR     reduce using rule 56 (term -> factor .)
    CLOSE_TAG       reduce using rule 56 (term -> factor .)
    ONE_LINE_COMMENT reduce using rule 56 (term -> factor .)
    MULTI_LINE_COMMENT reduce using rule 56 (term -> factor .)
    BREAK           reduce using rule 56 (term -> factor .)
    CONTINUE        reduce using rule 56 (term -> factor .)
    IF              reduce using rule 56 (term -> factor .)
    WHILE           reduce using rule 56 (term -> factor .)
    FUNCTION        reduce using rule 56 (term -> factor .)
    FSCANF          reduce using rule 56 (term -> factor .)
    FGETS           reduce using rule 56 (term -> factor .)
    NAME            reduce using rule 56 (term -> factor .)
    RETURN          reduce using rule 56 (term -> factor .)
    FOR             reduce using rule 56 (term -> factor .)
    TRUE            reduce using rule 56 (term -> factor .)
    FALSE           reduce using rule 56 (term -> factor .)
    LOGICAL_NOT     reduce using rule 56 (term -> factor .)
    LEFT_PAREN      reduce using rule 56 (term -> factor .)
    PRINT           reduce using rule 56 (term -> factor .)
    ECHO            reduce using rule 56 (term -> factor .)
    ID              reduce using rule 56 (term -> factor .)
    INTEGER         reduce using rule 56 (term -> factor .)
    FLOAT           reduce using rule 56 (term -> factor .)
    RIGHT_BRACE     reduce using rule 56 (term -> factor .)


state 48

    (57) factor -> INTEGER .

    TIMES           reduce using rule 57 (factor -> INTEGER .)
    DIVIDE          reduce using rule 57 (factor -> INTEGER .)
    PLUS            reduce using rule 57 (factor -> INTEGER .)
    MINUS           reduce using rule 57 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 57 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 57 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 57 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 57 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 57 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 57 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 57 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 57 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 57 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 57 (factor -> INTEGER .)
    DOT             reduce using rule 57 (factor -> INTEGER .)
    COMMA           reduce using rule 57 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 57 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 57 (factor -> INTEGER .)
    CLOSE_TAG       reduce using rule 57 (factor -> INTEGER .)
    ONE_LINE_COMMENT reduce using rule 57 (factor -> INTEGER .)
    MULTI_LINE_COMMENT reduce using rule 57 (factor -> INTEGER .)
    BREAK           reduce using rule 57 (factor -> INTEGER .)
    CONTINUE        reduce using rule 57 (factor -> INTEGER .)
    IF              reduce using rule 57 (factor -> INTEGER .)
    WHILE           reduce using rule 57 (factor -> INTEGER .)
    FUNCTION        reduce using rule 57 (factor -> INTEGER .)
    FSCANF          reduce using rule 57 (factor -> INTEGER .)
    FGETS           reduce using rule 57 (factor -> INTEGER .)
    NAME            reduce using rule 57 (factor -> INTEGER .)
    RETURN          reduce using rule 57 (factor -> INTEGER .)
    FOR             reduce using rule 57 (factor -> INTEGER .)
    TRUE            reduce using rule 57 (factor -> INTEGER .)
    FALSE           reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_NOT     reduce using rule 57 (factor -> INTEGER .)
    LEFT_PAREN      reduce using rule 57 (factor -> INTEGER .)
    PRINT           reduce using rule 57 (factor -> INTEGER .)
    ECHO            reduce using rule 57 (factor -> INTEGER .)
    ID              reduce using rule 57 (factor -> INTEGER .)
    INTEGER         reduce using rule 57 (factor -> INTEGER .)
    FLOAT           reduce using rule 57 (factor -> INTEGER .)
    RIGHT_BRACE     reduce using rule 57 (factor -> INTEGER .)


state 49

    (58) factor -> FLOAT .

    TIMES           reduce using rule 58 (factor -> FLOAT .)
    DIVIDE          reduce using rule 58 (factor -> FLOAT .)
    PLUS            reduce using rule 58 (factor -> FLOAT .)
    MINUS           reduce using rule 58 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 58 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 58 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 58 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 58 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 58 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 58 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 58 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 58 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 58 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 58 (factor -> FLOAT .)
    DOT             reduce using rule 58 (factor -> FLOAT .)
    COMMA           reduce using rule 58 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 58 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 58 (factor -> FLOAT .)
    CLOSE_TAG       reduce using rule 58 (factor -> FLOAT .)
    ONE_LINE_COMMENT reduce using rule 58 (factor -> FLOAT .)
    MULTI_LINE_COMMENT reduce using rule 58 (factor -> FLOAT .)
    BREAK           reduce using rule 58 (factor -> FLOAT .)
    CONTINUE        reduce using rule 58 (factor -> FLOAT .)
    IF              reduce using rule 58 (factor -> FLOAT .)
    WHILE           reduce using rule 58 (factor -> FLOAT .)
    FUNCTION        reduce using rule 58 (factor -> FLOAT .)
    FSCANF          reduce using rule 58 (factor -> FLOAT .)
    FGETS           reduce using rule 58 (factor -> FLOAT .)
    NAME            reduce using rule 58 (factor -> FLOAT .)
    RETURN          reduce using rule 58 (factor -> FLOAT .)
    FOR             reduce using rule 58 (factor -> FLOAT .)
    TRUE            reduce using rule 58 (factor -> FLOAT .)
    FALSE           reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_NOT     reduce using rule 58 (factor -> FLOAT .)
    LEFT_PAREN      reduce using rule 58 (factor -> FLOAT .)
    PRINT           reduce using rule 58 (factor -> FLOAT .)
    ECHO            reduce using rule 58 (factor -> FLOAT .)
    ID              reduce using rule 58 (factor -> FLOAT .)
    INTEGER         reduce using rule 58 (factor -> FLOAT .)
    FLOAT           reduce using rule 58 (factor -> FLOAT .)
    RIGHT_BRACE     reduce using rule 58 (factor -> FLOAT .)


state 50

    (1) program -> OPEN_TAG statements CLOSE_TAG .

    $end            reduce using rule 1 (program -> OPEN_TAG statements CLOSE_TAG .)


state 51

    (3) statements -> statements statement2 .

    CLOSE_TAG       reduce using rule 3 (statements -> statements statement2 .)
    ONE_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    MULTI_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    BREAK           reduce using rule 3 (statements -> statements statement2 .)
    CONTINUE        reduce using rule 3 (statements -> statements statement2 .)
    IF              reduce using rule 3 (statements -> statements statement2 .)
    WHILE           reduce using rule 3 (statements -> statements statement2 .)
    FUNCTION        reduce using rule 3 (statements -> statements statement2 .)
    FSCANF          reduce using rule 3 (statements -> statements statement2 .)
    FGETS           reduce using rule 3 (statements -> statements statement2 .)
    NAME            reduce using rule 3 (statements -> statements statement2 .)
    RETURN          reduce using rule 3 (statements -> statements statement2 .)
    FOR             reduce using rule 3 (statements -> statements statement2 .)
    TRUE            reduce using rule 3 (statements -> statements statement2 .)
    FALSE           reduce using rule 3 (statements -> statements statement2 .)
    LOGICAL_NOT     reduce using rule 3 (statements -> statements statement2 .)
    LEFT_PAREN      reduce using rule 3 (statements -> statements statement2 .)
    PRINT           reduce using rule 3 (statements -> statements statement2 .)
    ECHO            reduce using rule 3 (statements -> statements statement2 .)
    ID              reduce using rule 3 (statements -> statements statement2 .)
    INTEGER         reduce using rule 3 (statements -> statements statement2 .)
    FLOAT           reduce using rule 3 (statements -> statements statement2 .)
    RIGHT_BRACE     reduce using rule 3 (statements -> statements statement2 .)


state 52

    (4) statement2 -> statement SEMICOLON .

    CLOSE_TAG       reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    BREAK           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    IF              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FSCANF          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FGETS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    NAME            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RETURN          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FOR             reduce using rule 4 (statement2 -> statement SEMICOLON .)
    TRUE            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FALSE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    LOGICAL_NOT     reduce using rule 4 (statement2 -> statement SEMICOLON .)
    LEFT_PAREN      reduce using rule 4 (statement2 -> statement SEMICOLON .)
    PRINT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ECHO            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ID              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    INTEGER         reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FLOAT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RIGHT_BRACE     reduce using rule 4 (statement2 -> statement SEMICOLON .)


state 53

    (92) complex_condition -> condition logical_operator . condition
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 109
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41
    expression                     shift and go to state 37
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 54

    (104) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 104 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 104 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 104 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 104 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 104 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 104 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 104 (logical_operator -> LOGICAL_AND .)


state 55

    (105) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 105 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 105 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 105 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 105 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 105 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 105 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 105 (logical_operator -> LOGICAL_OR .)


state 56

    (106) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 106 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 106 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 106 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 106 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 106 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 106 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 106 (logical_operator -> LOGICAL_XOR .)


state 57

    (61) if_statement -> IF parenthesized_condition . block else_if_extended if_part3
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 111

    block                          shift and go to state 110

state 58

    (93) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 66
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41
    expression                     shift and go to state 37
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 59

    (68) while_statement -> WHILE parenthesized_condition . block
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 111

    block                          shift and go to state 112

state 60

    (71) for_statement -> for_part1 condition . for_part3
    (92) complex_condition -> condition . logical_operator condition
    (59) factor -> condition .
    (73) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (74) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (104) logical_operator -> . LOGICAL_AND
    (105) logical_operator -> . LOGICAL_OR
    (106) logical_operator -> . LOGICAL_XOR

    TIMES           reduce using rule 59 (factor -> condition .)
    DIVIDE          reduce using rule 59 (factor -> condition .)
    PLUS            reduce using rule 59 (factor -> condition .)
    MINUS           reduce using rule 59 (factor -> condition .)
    EQUAL_TO        reduce using rule 59 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> condition .)
    LESS_THAN       reduce using rule 59 (factor -> condition .)
    GREATER_THAN    reduce using rule 59 (factor -> condition .)
    LESS_EQUAL      reduce using rule 59 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 59 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 59 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> condition .)
    DIFFERENT       reduce using rule 59 (factor -> condition .)
    SEMICOLON       shift and go to state 62
    LOGICAL_AND     shift and go to state 54
    LOGICAL_OR      shift and go to state 55
    LOGICAL_XOR     shift and go to state 56

    for_part3                      shift and go to state 113
    logical_operator               shift and go to state 53

state 61

    (72) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    FUNCTION        reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    NAME            reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    RETURN          reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    TRUE            reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    FALSE           reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    LOGICAL_NOT     reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    LEFT_PAREN      reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    INTEGER         reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    FLOAT           reduce using rule 72 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 72 (for_statement -> for_part1 for_part3 .)


state 62

    (73) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (74) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (79) statement_list -> . statement
    (80) statement_list -> . statement_list COMMA statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . statement_return
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (111) array_declaration_statement -> . variable EQUALS array
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (22) statement_return -> . RETURN expression
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    RIGHT_PAREN     shift and go to state 115
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    NAME            shift and go to state 27
    RETURN          shift and go to state 36
    PRINT           shift and go to state 43
    ECHO            shift and go to state 44
    ID              shift and go to state 45

    statement_list                 shift and go to state 114
    statement                      shift and go to state 116
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    statement_return               shift and go to state 21
    print_function                 shift and go to state 32
    variable                       shift and go to state 117

state 63

    (89) simple_condition -> variable .

    SEMICOLON       reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 89 (simple_condition -> variable .)
    TIMES           reduce using rule 89 (simple_condition -> variable .)
    DIVIDE          reduce using rule 89 (simple_condition -> variable .)
    PLUS            reduce using rule 89 (simple_condition -> variable .)
    MINUS           reduce using rule 89 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 89 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 89 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 89 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 89 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 89 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 89 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 89 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 89 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 89 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 89 (simple_condition -> variable .)
    COMMA           reduce using rule 89 (simple_condition -> variable .)
    CLOSE_TAG       reduce using rule 89 (simple_condition -> variable .)
    ONE_LINE_COMMENT reduce using rule 89 (simple_condition -> variable .)
    MULTI_LINE_COMMENT reduce using rule 89 (simple_condition -> variable .)
    BREAK           reduce using rule 89 (simple_condition -> variable .)
    CONTINUE        reduce using rule 89 (simple_condition -> variable .)
    IF              reduce using rule 89 (simple_condition -> variable .)
    WHILE           reduce using rule 89 (simple_condition -> variable .)
    FUNCTION        reduce using rule 89 (simple_condition -> variable .)
    FSCANF          reduce using rule 89 (simple_condition -> variable .)
    FGETS           reduce using rule 89 (simple_condition -> variable .)
    NAME            reduce using rule 89 (simple_condition -> variable .)
    RETURN          reduce using rule 89 (simple_condition -> variable .)
    FOR             reduce using rule 89 (simple_condition -> variable .)
    TRUE            reduce using rule 89 (simple_condition -> variable .)
    FALSE           reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_NOT     reduce using rule 89 (simple_condition -> variable .)
    LEFT_PAREN      reduce using rule 89 (simple_condition -> variable .)
    PRINT           reduce using rule 89 (simple_condition -> variable .)
    ECHO            reduce using rule 89 (simple_condition -> variable .)
    ID              reduce using rule 89 (simple_condition -> variable .)
    INTEGER         reduce using rule 89 (simple_condition -> variable .)
    FLOAT           reduce using rule 89 (simple_condition -> variable .)
    DOT             reduce using rule 89 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 89 (simple_condition -> variable .)
    RIGHT_BRACE     reduce using rule 89 (simple_condition -> variable .)


state 64

    (21) function_statement -> FUNCTION NAME . LEFT_PAREN arguments RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 118


state 65

    (110) function_call -> NAME LEFT_PAREN . array_elements RIGHT_PAREN
    (114) array_elements -> . argument
    (115) array_elements -> . array_elements COMMA argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    array_elements                 shift and go to state 120
    argument                       shift and go to state 121
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 66

    (93) parenthesized_condition -> LEFT_PAREN condition . RIGHT_PAREN
    (92) complex_condition -> condition . logical_operator condition
    (59) factor -> condition .
    (104) logical_operator -> . LOGICAL_AND
    (105) logical_operator -> . LOGICAL_OR
    (106) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 122
    TIMES           reduce using rule 59 (factor -> condition .)
    DIVIDE          reduce using rule 59 (factor -> condition .)
    PLUS            reduce using rule 59 (factor -> condition .)
    MINUS           reduce using rule 59 (factor -> condition .)
    EQUAL_TO        reduce using rule 59 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> condition .)
    LESS_THAN       reduce using rule 59 (factor -> condition .)
    GREATER_THAN    reduce using rule 59 (factor -> condition .)
    LESS_EQUAL      reduce using rule 59 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 59 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 59 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> condition .)
    DIFFERENT       reduce using rule 59 (factor -> condition .)
    DOT             reduce using rule 59 (factor -> condition .)
    COMMA           reduce using rule 59 (factor -> condition .)
    LOGICAL_AND     shift and go to state 54
    LOGICAL_OR      shift and go to state 55
    LOGICAL_XOR     shift and go to state 56

  ! RIGHT_PAREN     [ reduce using rule 59 (factor -> condition .) ]

    logical_operator               shift and go to state 53

state 67

    (60) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (94) relational_expression -> expression . relational_operator expression
    (95) relational_operator -> . EQUAL_TO
    (96) relational_operator -> . NOT_EQUAL_TO
    (97) relational_operator -> . LESS_THAN
    (98) relational_operator -> . GREATER_THAN
    (99) relational_operator -> . LESS_EQUAL
    (100) relational_operator -> . GREATER_EQUAL
    (101) relational_operator -> . IDENTICAL_TO
    (102) relational_operator -> . NOT_IDENTICAL_TO
    (103) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 123
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    EQUAL_TO        shift and go to state 96
    NOT_EQUAL_TO    shift and go to state 97
    LESS_THAN       shift and go to state 98
    GREATER_THAN    shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    IDENTICAL_TO    shift and go to state 102
    NOT_IDENTICAL_TO shift and go to state 103
    DIFFERENT       shift and go to state 104

    relational_operator            shift and go to state 93

state 68

    (37) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (107) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (60) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (93) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (41) arguments -> . argument
    (42) arguments -> . arguments DOT argument
    (43) arguments -> . arguments COMMA argument
    (108) casting_type -> . INT_TYPE
    (109) casting_type -> . FLOAT_TYPE
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 128
    FLOAT_TYPE      shift and go to state 129
    STRING          shift and go to state 71
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 124
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    ID              shift and go to state 45

    arguments                      shift and go to state 125
    casting_type                   shift and go to state 126
    expression                     shift and go to state 127
    condition                      shift and go to state 66
    argument                       shift and go to state 70
    term                           shift and go to state 46
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    factor                         shift and go to state 47
    variable                       shift and go to state 130
    relational_expression          shift and go to state 41

state 69

    (38) print_statement -> print_function arguments .
    (42) arguments -> arguments . DOT argument
    (43) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 38 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 38 (print_statement -> print_function arguments .)
    DOT             shift and go to state 131
    COMMA           shift and go to state 132

  ! COMMA           [ reduce using rule 38 (print_statement -> print_function arguments .) ]


state 70

    (41) arguments -> argument .

    DOT             reduce using rule 41 (arguments -> argument .)
    COMMA           reduce using rule 41 (arguments -> argument .)
    SEMICOLON       reduce using rule 41 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 41 (arguments -> argument .)


state 71

    (44) argument -> STRING .

    DOT             reduce using rule 44 (argument -> STRING .)
    COMMA           reduce using rule 44 (argument -> STRING .)
    SEMICOLON       reduce using rule 44 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 44 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 44 (argument -> STRING .)


state 72

    (45) argument -> expression .
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (94) relational_expression -> expression . relational_operator expression
    (95) relational_operator -> . EQUAL_TO
    (96) relational_operator -> . NOT_EQUAL_TO
    (97) relational_operator -> . LESS_THAN
    (98) relational_operator -> . GREATER_THAN
    (99) relational_operator -> . LESS_EQUAL
    (100) relational_operator -> . GREATER_EQUAL
    (101) relational_operator -> . IDENTICAL_TO
    (102) relational_operator -> . NOT_IDENTICAL_TO
    (103) relational_operator -> . DIFFERENT

    DOT             reduce using rule 45 (argument -> expression .)
    COMMA           reduce using rule 45 (argument -> expression .)
    SEMICOLON       reduce using rule 45 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 45 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 45 (argument -> expression .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    EQUAL_TO        shift and go to state 96
    NOT_EQUAL_TO    shift and go to state 97
    LESS_THAN       shift and go to state 98
    GREATER_THAN    shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    IDENTICAL_TO    shift and go to state 102
    NOT_IDENTICAL_TO shift and go to state 103
    DIFFERENT       shift and go to state 104

    relational_operator            shift and go to state 93

state 73

    (46) argument -> assignment_statement .

    DOT             reduce using rule 46 (argument -> assignment_statement .)
    COMMA           reduce using rule 46 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 46 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 46 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 46 (argument -> assignment_statement .)


state 74

    (47) argument -> function_call .

    DOT             reduce using rule 47 (argument -> function_call .)
    COMMA           reduce using rule 47 (argument -> function_call .)
    SEMICOLON       reduce using rule 47 (argument -> function_call .)
    RIGHT_PAREN     reduce using rule 47 (argument -> function_call .)
    RIGHT_BRACKET   reduce using rule 47 (argument -> function_call .)


state 75

    (48) argument -> fgets_statement .

    DOT             reduce using rule 48 (argument -> fgets_statement .)
    COMMA           reduce using rule 48 (argument -> fgets_statement .)
    SEMICOLON       reduce using rule 48 (argument -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 48 (argument -> fgets_statement .)
    RIGHT_BRACKET   reduce using rule 48 (argument -> fgets_statement .)


state 76

    (49) argument -> array_indexing .

    DOT             reduce using rule 49 (argument -> array_indexing .)
    COMMA           reduce using rule 49 (argument -> array_indexing .)
    SEMICOLON       reduce using rule 49 (argument -> array_indexing .)
    RIGHT_PAREN     reduce using rule 49 (argument -> array_indexing .)
    RIGHT_BRACKET   reduce using rule 49 (argument -> array_indexing .)


state 77

    (50) argument -> casting . argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    casting                        shift and go to state 77
    argument                       shift and go to state 133
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 78

    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (116) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (89) simple_condition -> variable .
    (31) assignment_operator -> . EQUALS
    (32) assignment_operator -> . PLUS_EQUALS
    (33) assignment_operator -> . MINUS_EQUALS
    (34) assignment_operator -> . TIMES_EQUALS
    (35) assignment_operator -> . DIVIDE_EQUALS
    (36) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 83
    MINUS_MINUS     shift and go to state 84
    LEFT_BRACKET    shift and go to state 134
    LOGICAL_AND     reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 89 (simple_condition -> variable .)
    TIMES           reduce using rule 89 (simple_condition -> variable .)
    DIVIDE          reduce using rule 89 (simple_condition -> variable .)
    PLUS            reduce using rule 89 (simple_condition -> variable .)
    MINUS           reduce using rule 89 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 89 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 89 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 89 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 89 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 89 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 89 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 89 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 89 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 89 (simple_condition -> variable .)
    DOT             reduce using rule 89 (simple_condition -> variable .)
    COMMA           reduce using rule 89 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 89 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 89 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 89 (simple_condition -> variable .)
    EQUALS          shift and go to state 135
    PLUS_EQUALS     shift and go to state 86
    MINUS_EQUALS    shift and go to state 87
    TIMES_EQUALS    shift and go to state 88
    DIVIDE_EQUALS   shift and go to state 89
    MOD_EQUALS      shift and go to state 90

    assignment_operator            shift and go to state 82

state 79

    (59) factor -> condition .
    (92) complex_condition -> condition . logical_operator condition
    (104) logical_operator -> . LOGICAL_AND
    (105) logical_operator -> . LOGICAL_OR
    (106) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    TIMES           reduce using rule 59 (factor -> condition .)
    DIVIDE          reduce using rule 59 (factor -> condition .)
    PLUS            reduce using rule 59 (factor -> condition .)
    MINUS           reduce using rule 59 (factor -> condition .)
    EQUAL_TO        reduce using rule 59 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> condition .)
    LESS_THAN       reduce using rule 59 (factor -> condition .)
    GREATER_THAN    reduce using rule 59 (factor -> condition .)
    LESS_EQUAL      reduce using rule 59 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 59 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 59 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> condition .)
    DIFFERENT       reduce using rule 59 (factor -> condition .)
    DOT             reduce using rule 59 (factor -> condition .)
    COMMA           reduce using rule 59 (factor -> condition .)
    SEMICOLON       reduce using rule 59 (factor -> condition .)
    RIGHT_PAREN     reduce using rule 59 (factor -> condition .)
    RIGHT_BRACKET   reduce using rule 59 (factor -> condition .)
    CLOSE_TAG       reduce using rule 59 (factor -> condition .)
    ONE_LINE_COMMENT reduce using rule 59 (factor -> condition .)
    MULTI_LINE_COMMENT reduce using rule 59 (factor -> condition .)
    BREAK           reduce using rule 59 (factor -> condition .)
    CONTINUE        reduce using rule 59 (factor -> condition .)
    IF              reduce using rule 59 (factor -> condition .)
    WHILE           reduce using rule 59 (factor -> condition .)
    FUNCTION        reduce using rule 59 (factor -> condition .)
    FSCANF          reduce using rule 59 (factor -> condition .)
    FGETS           reduce using rule 59 (factor -> condition .)
    NAME            reduce using rule 59 (factor -> condition .)
    RETURN          reduce using rule 59 (factor -> condition .)
    FOR             reduce using rule 59 (factor -> condition .)
    TRUE            reduce using rule 59 (factor -> condition .)
    FALSE           reduce using rule 59 (factor -> condition .)
    LOGICAL_NOT     reduce using rule 59 (factor -> condition .)
    LEFT_PAREN      reduce using rule 59 (factor -> condition .)
    PRINT           reduce using rule 59 (factor -> condition .)
    ECHO            reduce using rule 59 (factor -> condition .)
    ID              reduce using rule 59 (factor -> condition .)
    INTEGER         reduce using rule 59 (factor -> condition .)
    FLOAT           reduce using rule 59 (factor -> condition .)
    RIGHT_BRACE     reduce using rule 59 (factor -> condition .)
    LOGICAL_AND     shift and go to state 54
    LOGICAL_OR      shift and go to state 55
    LOGICAL_XOR     shift and go to state 56

  ! LOGICAL_AND     [ reduce using rule 59 (factor -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 59 (factor -> condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 59 (factor -> condition .) ]

    logical_operator               shift and go to state 53

state 80

    (24) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 136


state 81

    (23) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 137


state 82

    (28) assignment_statement -> variable assignment_operator . argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    variable                       shift and go to state 78
    argument                       shift and go to state 138
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 83

    (29) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)


state 84

    (30) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)


state 85

    (111) array_declaration_statement -> variable EQUALS . array
    (31) assignment_operator -> EQUALS .
    (112) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (113) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

    STRING          reduce using rule 31 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 31 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 31 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 31 (assignment_operator -> EQUALS .)
    ID              reduce using rule 31 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 31 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 31 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 31 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 31 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 31 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 140
    LEFT_BRACKET    shift and go to state 141

    array                          shift and go to state 139

state 86

    (32) assignment_operator -> PLUS_EQUALS .

    STRING          reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    NAME            reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    FGETS           reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    INTEGER         reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 32 (assignment_operator -> PLUS_EQUALS .)


state 87

    (33) assignment_operator -> MINUS_EQUALS .

    STRING          reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    NAME            reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    FGETS           reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    INTEGER         reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 33 (assignment_operator -> MINUS_EQUALS .)


state 88

    (34) assignment_operator -> TIMES_EQUALS .

    STRING          reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    NAME            reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    FGETS           reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    INTEGER         reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 34 (assignment_operator -> TIMES_EQUALS .)


state 89

    (35) assignment_operator -> DIVIDE_EQUALS .

    STRING          reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    NAME            reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    FGETS           reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    INTEGER         reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 35 (assignment_operator -> DIVIDE_EQUALS .)


state 90

    (36) assignment_operator -> MOD_EQUALS .

    STRING          reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    NAME            reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    FGETS           reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    INTEGER         reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 36 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 36 (assignment_operator -> MOD_EQUALS .)


state 91

    (22) statement_return -> RETURN expression .
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (94) relational_expression -> expression . relational_operator expression
    (95) relational_operator -> . EQUAL_TO
    (96) relational_operator -> . NOT_EQUAL_TO
    (97) relational_operator -> . LESS_THAN
    (98) relational_operator -> . GREATER_THAN
    (99) relational_operator -> . LESS_EQUAL
    (100) relational_operator -> . GREATER_EQUAL
    (101) relational_operator -> . IDENTICAL_TO
    (102) relational_operator -> . NOT_IDENTICAL_TO
    (103) relational_operator -> . DIFFERENT

    SEMICOLON       reduce using rule 22 (statement_return -> RETURN expression .)
    RIGHT_PAREN     reduce using rule 22 (statement_return -> RETURN expression .)
    COMMA           reduce using rule 22 (statement_return -> RETURN expression .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    EQUAL_TO        shift and go to state 96
    NOT_EQUAL_TO    shift and go to state 97
    LESS_THAN       shift and go to state 98
    GREATER_THAN    shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    IDENTICAL_TO    shift and go to state 102
    NOT_IDENTICAL_TO shift and go to state 103
    DIFFERENT       shift and go to state 104

    relational_operator            shift and go to state 93

state 92

    (60) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (93) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    ID              shift and go to state 45

    expression                     shift and go to state 67
    condition                      shift and go to state 66
    term                           shift and go to state 46
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    factor                         shift and go to state 47
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 93

    (94) relational_expression -> expression relational_operator . expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LEFT_PAREN      shift and go to state 92
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    ID              shift and go to state 45

    expression                     shift and go to state 142
    term                           shift and go to state 46
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 94

    (51) expression -> expression PLUS . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LEFT_PAREN      shift and go to state 92
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    ID              shift and go to state 45

    expression                     shift and go to state 37
    term                           shift and go to state 143
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 95

    (52) expression -> expression MINUS . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LEFT_PAREN      shift and go to state 92
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    ID              shift and go to state 45

    expression                     shift and go to state 37
    term                           shift and go to state 144
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 96

    (95) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 95 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 95 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 95 (relational_operator -> EQUAL_TO .)
    TRUE            reduce using rule 95 (relational_operator -> EQUAL_TO .)
    FALSE           reduce using rule 95 (relational_operator -> EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 95 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 95 (relational_operator -> EQUAL_TO .)


state 97

    (96) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)
    TRUE            reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)
    FALSE           reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 96 (relational_operator -> NOT_EQUAL_TO .)


state 98

    (97) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 97 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 97 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 97 (relational_operator -> LESS_THAN .)
    TRUE            reduce using rule 97 (relational_operator -> LESS_THAN .)
    FALSE           reduce using rule 97 (relational_operator -> LESS_THAN .)
    LOGICAL_NOT     reduce using rule 97 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 97 (relational_operator -> LESS_THAN .)


state 99

    (98) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 98 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 98 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 98 (relational_operator -> GREATER_THAN .)
    TRUE            reduce using rule 98 (relational_operator -> GREATER_THAN .)
    FALSE           reduce using rule 98 (relational_operator -> GREATER_THAN .)
    LOGICAL_NOT     reduce using rule 98 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 98 (relational_operator -> GREATER_THAN .)


state 100

    (99) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 99 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 99 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 99 (relational_operator -> LESS_EQUAL .)
    TRUE            reduce using rule 99 (relational_operator -> LESS_EQUAL .)
    FALSE           reduce using rule 99 (relational_operator -> LESS_EQUAL .)
    LOGICAL_NOT     reduce using rule 99 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 99 (relational_operator -> LESS_EQUAL .)


state 101

    (100) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 100 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 100 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 100 (relational_operator -> GREATER_EQUAL .)
    TRUE            reduce using rule 100 (relational_operator -> GREATER_EQUAL .)
    FALSE           reduce using rule 100 (relational_operator -> GREATER_EQUAL .)
    LOGICAL_NOT     reduce using rule 100 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 100 (relational_operator -> GREATER_EQUAL .)


state 102

    (101) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 101 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 101 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 101 (relational_operator -> IDENTICAL_TO .)
    TRUE            reduce using rule 101 (relational_operator -> IDENTICAL_TO .)
    FALSE           reduce using rule 101 (relational_operator -> IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 101 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 101 (relational_operator -> IDENTICAL_TO .)


state 103

    (102) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)
    TRUE            reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)
    FALSE           reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 102 (relational_operator -> NOT_IDENTICAL_TO .)


state 104

    (103) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 103 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 103 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 103 (relational_operator -> DIFFERENT .)
    TRUE            reduce using rule 103 (relational_operator -> DIFFERENT .)
    FALSE           reduce using rule 103 (relational_operator -> DIFFERENT .)
    LOGICAL_NOT     reduce using rule 103 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 103 (relational_operator -> DIFFERENT .)


state 105

    (69) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (70) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (77) assignment_list -> . assignment_statement
    (78) assignment_list -> . assignment_list COMMA assignment_statement
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (27) variable -> . ID

    SEMICOLON       shift and go to state 146
    ID              shift and go to state 45

    assignment_list                shift and go to state 145
    assignment_statement           shift and go to state 147
    variable                       shift and go to state 148

state 106

    (91) negated_condition -> LOGICAL_NOT condition .
    (92) complex_condition -> condition . logical_operator condition
    (59) factor -> condition .
    (104) logical_operator -> . LOGICAL_AND
    (105) logical_operator -> . LOGICAL_OR
    (106) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 59 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    CLOSE_TAG       reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    ONE_LINE_COMMENT reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    MULTI_LINE_COMMENT reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    BREAK           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    CONTINUE        reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    IF              reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    WHILE           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    FUNCTION        reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    FSCANF          reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    FGETS           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    NAME            reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    RETURN          reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    FOR             reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    TRUE            reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    FALSE           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    LOGICAL_NOT     reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    LEFT_PAREN      reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    PRINT           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    ECHO            reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    ID              reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    INTEGER         reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    FLOAT           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    SEMICOLON       reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_BRACE     reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .)
    TIMES           reduce using rule 59 (factor -> condition .)
    DIVIDE          reduce using rule 59 (factor -> condition .)
    PLUS            reduce using rule 59 (factor -> condition .)
    MINUS           reduce using rule 59 (factor -> condition .)
    EQUAL_TO        reduce using rule 59 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> condition .)
    LESS_THAN       reduce using rule 59 (factor -> condition .)
    GREATER_THAN    reduce using rule 59 (factor -> condition .)
    LESS_EQUAL      reduce using rule 59 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 59 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 59 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> condition .)
    DIFFERENT       reduce using rule 59 (factor -> condition .)
    LOGICAL_AND     shift and go to state 54
    LOGICAL_OR      shift and go to state 55
    LOGICAL_XOR     shift and go to state 56

  ! LOGICAL_AND     [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! TIMES           [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIVIDE          [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! PLUS            [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MINUS           [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! EQUAL_TO        [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_THAN       [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_THAN    [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIFFERENT       [ reduce using rule 91 (negated_condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 53

state 107

    (54) term -> term TIMES . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LEFT_PAREN      shift and go to state 92
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    ID              shift and go to state 45

    term                           shift and go to state 46
    factor                         shift and go to state 149
    condition                      shift and go to state 79
    expression                     shift and go to state 37
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 108

    (55) term -> term DIVIDE . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LEFT_PAREN      shift and go to state 92
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    ID              shift and go to state 45

    term                           shift and go to state 46
    factor                         shift and go to state 150
    condition                      shift and go to state 79
    expression                     shift and go to state 37
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 109

    (92) complex_condition -> condition logical_operator condition .
    (92) complex_condition -> condition . logical_operator condition
    (59) factor -> condition .
    (104) logical_operator -> . LOGICAL_AND
    (105) logical_operator -> . LOGICAL_OR
    (106) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 59 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 59 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    CLOSE_TAG       reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    ONE_LINE_COMMENT reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    MULTI_LINE_COMMENT reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    BREAK           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    CONTINUE        reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    IF              reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    WHILE           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    FUNCTION        reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    FSCANF          reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    FGETS           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    NAME            reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    RETURN          reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    FOR             reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    TRUE            reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    FALSE           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    LOGICAL_NOT     reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    LEFT_PAREN      reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    PRINT           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    ECHO            reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    ID              reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    INTEGER         reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    FLOAT           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    SEMICOLON       reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    DOT             reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    COMMA           reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    RIGHT_BRACE     reduce using rule 92 (complex_condition -> condition logical_operator condition .)
    TIMES           reduce using rule 59 (factor -> condition .)
    DIVIDE          reduce using rule 59 (factor -> condition .)
    PLUS            reduce using rule 59 (factor -> condition .)
    MINUS           reduce using rule 59 (factor -> condition .)
    EQUAL_TO        reduce using rule 59 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> condition .)
    LESS_THAN       reduce using rule 59 (factor -> condition .)
    GREATER_THAN    reduce using rule 59 (factor -> condition .)
    LESS_EQUAL      reduce using rule 59 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 59 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 59 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> condition .)
    DIFFERENT       reduce using rule 59 (factor -> condition .)
    LOGICAL_AND     shift and go to state 54
    LOGICAL_OR      shift and go to state 55
    LOGICAL_XOR     shift and go to state 56

  ! LOGICAL_AND     [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! TIMES           [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! DIVIDE          [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! PLUS            [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! MINUS           [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! EQUAL_TO        [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_THAN       [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_THAN    [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]
  ! DIFFERENT       [ reduce using rule 92 (complex_condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 53

state 110

    (61) if_statement -> IF parenthesized_condition block . else_if_extended if_part3
    (62) else_if_extended -> . if_part2
    (63) else_if_extended -> . else_if_extended if_part2
    (64) if_part2 -> . ELSEIF parenthesized_condition block
    (65) if_part2 -> .

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSEIF          shift and go to state 153
    ELSE            reduce using rule 65 (if_part2 -> .)
    CLOSE_TAG       reduce using rule 65 (if_part2 -> .)
    ONE_LINE_COMMENT reduce using rule 65 (if_part2 -> .)
    MULTI_LINE_COMMENT reduce using rule 65 (if_part2 -> .)
    BREAK           reduce using rule 65 (if_part2 -> .)
    CONTINUE        reduce using rule 65 (if_part2 -> .)
    IF              reduce using rule 65 (if_part2 -> .)
    WHILE           reduce using rule 65 (if_part2 -> .)
    FUNCTION        reduce using rule 65 (if_part2 -> .)
    FSCANF          reduce using rule 65 (if_part2 -> .)
    FGETS           reduce using rule 65 (if_part2 -> .)
    NAME            reduce using rule 65 (if_part2 -> .)
    RETURN          reduce using rule 65 (if_part2 -> .)
    FOR             reduce using rule 65 (if_part2 -> .)
    TRUE            reduce using rule 65 (if_part2 -> .)
    FALSE           reduce using rule 65 (if_part2 -> .)
    LOGICAL_NOT     reduce using rule 65 (if_part2 -> .)
    LEFT_PAREN      reduce using rule 65 (if_part2 -> .)
    PRINT           reduce using rule 65 (if_part2 -> .)
    ECHO            reduce using rule 65 (if_part2 -> .)
    ID              reduce using rule 65 (if_part2 -> .)
    INTEGER         reduce using rule 65 (if_part2 -> .)
    FLOAT           reduce using rule 65 (if_part2 -> .)
    RIGHT_BRACE     reduce using rule 65 (if_part2 -> .)

  ! ELSEIF          [ reduce using rule 65 (if_part2 -> .) ]

    else_if_extended               shift and go to state 151
    if_part2                       shift and go to state 152

state 111

    (81) block -> LEFT_BRACE . statements RIGHT_BRACE
    (82) block -> LEFT_BRACE . RIGHT_BRACE
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . condition
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . statement_return
    (61) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (68) while_statement -> . WHILE parenthesized_condition block
    (71) for_statement -> . for_part1 condition for_part3
    (72) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (111) array_declaration_statement -> . variable EQUALS array
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (22) statement_return -> . RETURN expression
    (69) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (70) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    RIGHT_BRACE     shift and go to state 155
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 24
    FUNCTION        shift and go to state 26
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    NAME            shift and go to state 27
    RETURN          shift and go to state 36
    FOR             shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    PRINT           shift and go to state 43
    ECHO            shift and go to state 44
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    statements                     shift and go to state 154
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    condition                      shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    statement_return               shift and go to state 21
    parenthesized_condition        shift and go to state 23
    for_part1                      shift and go to state 25
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    expression                     shift and go to state 37
    relational_expression          shift and go to state 41
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 112

    (68) while_statement -> WHILE parenthesized_condition block .

    CLOSE_TAG       reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    BREAK           reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    CONTINUE        reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    IF              reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    WHILE           reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    FUNCTION        reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    FSCANF          reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    FGETS           reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    NAME            reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    RETURN          reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    FOR             reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    TRUE            reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    FALSE           reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    PRINT           reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    ECHO            reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    ID              reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    INTEGER         reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    FLOAT           reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 68 (while_statement -> WHILE parenthesized_condition block .)


state 113

    (71) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    FUNCTION        reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    NAME            reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    RETURN          reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    TRUE            reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    FALSE           reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    LOGICAL_NOT     reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    LEFT_PAREN      reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    INTEGER         reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    FLOAT           reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 71 (for_statement -> for_part1 condition for_part3 .)


state 114

    (73) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (80) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 156
    COMMA           shift and go to state 157


state 115

    (74) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (75) for_part4 -> . block
    (76) for_part4 -> . SEMICOLON
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 158
    LEFT_BRACE      shift and go to state 111

    for_part4                      shift and go to state 159
    block                          shift and go to state 160

state 116

    (79) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 79 (statement_list -> statement .)
    COMMA           reduce using rule 79 (statement_list -> statement .)


state 117

    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (111) array_declaration_statement -> variable . EQUALS array
    (31) assignment_operator -> . EQUALS
    (32) assignment_operator -> . PLUS_EQUALS
    (33) assignment_operator -> . MINUS_EQUALS
    (34) assignment_operator -> . TIMES_EQUALS
    (35) assignment_operator -> . DIVIDE_EQUALS
    (36) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 83
    MINUS_MINUS     shift and go to state 84
    EQUALS          shift and go to state 85
    PLUS_EQUALS     shift and go to state 86
    MINUS_EQUALS    shift and go to state 87
    TIMES_EQUALS    shift and go to state 88
    DIVIDE_EQUALS   shift and go to state 89
    MOD_EQUALS      shift and go to state 90

    assignment_operator            shift and go to state 82

state 118

    (21) function_statement -> FUNCTION NAME LEFT_PAREN . arguments RIGHT_PAREN block
    (41) arguments -> . argument
    (42) arguments -> . arguments DOT argument
    (43) arguments -> . arguments COMMA argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    arguments                      shift and go to state 161
    argument                       shift and go to state 70
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 119

    (107) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (60) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (93) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (108) casting_type -> . INT_TYPE
    (109) casting_type -> . FLOAT_TYPE
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 128
    FLOAT_TYPE      shift and go to state 129
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    ID              shift and go to state 45

    casting_type                   shift and go to state 126
    expression                     shift and go to state 67
    condition                      shift and go to state 66
    term                           shift and go to state 46
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    factor                         shift and go to state 47
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41

state 120

    (110) function_call -> NAME LEFT_PAREN array_elements . RIGHT_PAREN
    (115) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 162
    COMMA           shift and go to state 163


state 121

    (114) array_elements -> argument .

    RIGHT_PAREN     reduce using rule 114 (array_elements -> argument .)
    COMMA           reduce using rule 114 (array_elements -> argument .)
    RIGHT_BRACKET   reduce using rule 114 (array_elements -> argument .)


state 122

    (93) parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .

    LOGICAL_AND     reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    CLOSE_TAG       reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    ONE_LINE_COMMENT reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MULTI_LINE_COMMENT reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    BREAK           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    CONTINUE        reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    IF              reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    WHILE           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    FUNCTION        reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    FSCANF          reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    FGETS           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NAME            reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RETURN          reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    FOR             reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    TRUE            reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    FALSE           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    PRINT           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    ECHO            reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    ID              reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    INTEGER         reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    FLOAT           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    TIMES           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIVIDE          reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    PLUS            reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MINUS           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_THAN       reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIFFERENT       reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    SEMICOLON       reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 93 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 123

    (60) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    CLOSE_TAG       reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    ONE_LINE_COMMENT reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MULTI_LINE_COMMENT reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    BREAK           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    CONTINUE        reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FUNCTION        reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FSCANF          reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FGETS           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NAME            reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RETURN          reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TRUE            reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FALSE           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PRINT           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    ECHO            reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    ID              reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FLOAT           reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 60 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 124

    (93) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (107) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (60) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (108) casting_type -> . INT_TYPE
    (109) casting_type -> . FLOAT_TYPE
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INT_TYPE        shift and go to state 128
    FLOAT_TYPE      shift and go to state 129
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 66
    casting_type                   shift and go to state 126
    expression                     shift and go to state 67
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    term                           shift and go to state 46
    variable                       shift and go to state 63
    relational_expression          shift and go to state 41
    factor                         shift and go to state 47

state 125

    (37) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (42) arguments -> arguments . DOT argument
    (43) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 164
    DOT             shift and go to state 131
    COMMA           shift and go to state 132


state 126

    (107) casting -> LEFT_PAREN casting_type . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 165


state 127

    (60) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (45) argument -> expression .
    (94) relational_expression -> expression . relational_operator expression
    (95) relational_operator -> . EQUAL_TO
    (96) relational_operator -> . NOT_EQUAL_TO
    (97) relational_operator -> . LESS_THAN
    (98) relational_operator -> . GREATER_THAN
    (99) relational_operator -> . LESS_EQUAL
    (100) relational_operator -> . GREATER_EQUAL
    (101) relational_operator -> . IDENTICAL_TO
    (102) relational_operator -> . NOT_IDENTICAL_TO
    (103) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 123
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    DOT             reduce using rule 45 (argument -> expression .)
    COMMA           reduce using rule 45 (argument -> expression .)
    EQUAL_TO        shift and go to state 96
    NOT_EQUAL_TO    shift and go to state 97
    LESS_THAN       shift and go to state 98
    GREATER_THAN    shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    IDENTICAL_TO    shift and go to state 102
    NOT_IDENTICAL_TO shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! RIGHT_PAREN     [ reduce using rule 45 (argument -> expression .) ]

    relational_operator            shift and go to state 93

state 128

    (108) casting_type -> INT_TYPE .

    RIGHT_PAREN     reduce using rule 108 (casting_type -> INT_TYPE .)


state 129

    (109) casting_type -> FLOAT_TYPE .

    RIGHT_PAREN     reduce using rule 109 (casting_type -> FLOAT_TYPE .)


state 130

    (89) simple_condition -> variable .
    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (116) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (31) assignment_operator -> . EQUALS
    (32) assignment_operator -> . PLUS_EQUALS
    (33) assignment_operator -> . MINUS_EQUALS
    (34) assignment_operator -> . TIMES_EQUALS
    (35) assignment_operator -> . DIVIDE_EQUALS
    (36) assignment_operator -> . MOD_EQUALS

    RIGHT_PAREN     reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 89 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 89 (simple_condition -> variable .)
    TIMES           reduce using rule 89 (simple_condition -> variable .)
    DIVIDE          reduce using rule 89 (simple_condition -> variable .)
    PLUS            reduce using rule 89 (simple_condition -> variable .)
    MINUS           reduce using rule 89 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 89 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 89 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 89 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 89 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 89 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 89 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 89 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 89 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 89 (simple_condition -> variable .)
    DOT             reduce using rule 89 (simple_condition -> variable .)
    COMMA           reduce using rule 89 (simple_condition -> variable .)
    PLUS_PLUS       shift and go to state 83
    MINUS_MINUS     shift and go to state 84
    LEFT_BRACKET    shift and go to state 134
    EQUALS          shift and go to state 135
    PLUS_EQUALS     shift and go to state 86
    MINUS_EQUALS    shift and go to state 87
    TIMES_EQUALS    shift and go to state 88
    DIVIDE_EQUALS   shift and go to state 89
    MOD_EQUALS      shift and go to state 90

    assignment_operator            shift and go to state 82

state 131

    (42) arguments -> arguments DOT . argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    argument                       shift and go to state 166
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 132

    (43) arguments -> arguments COMMA . argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    argument                       shift and go to state 167
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 133

    (50) argument -> casting argument .

    DOT             reduce using rule 50 (argument -> casting argument .)
    COMMA           reduce using rule 50 (argument -> casting argument .)
    SEMICOLON       reduce using rule 50 (argument -> casting argument .)
    RIGHT_PAREN     reduce using rule 50 (argument -> casting argument .)
    RIGHT_BRACKET   reduce using rule 50 (argument -> casting argument .)


state 134

    (116) array_indexing -> variable LEFT_BRACKET . INTEGER RIGHT_BRACKET

    INTEGER         shift and go to state 168


state 135

    (31) assignment_operator -> EQUALS .

    STRING          reduce using rule 31 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 31 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 31 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 31 (assignment_operator -> EQUALS .)
    ID              reduce using rule 31 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 31 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 31 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 31 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 31 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 31 (assignment_operator -> EQUALS .)


state 136

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 169


state 137

    (23) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 170


state 138

    (28) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)


state 139

    (111) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 111 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 111 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 111 (array_declaration_statement -> variable EQUALS array .)


state 140

    (112) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 171


state 141

    (113) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (114) array_elements -> . argument
    (115) array_elements -> . array_elements COMMA argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    array_elements                 shift and go to state 172
    argument                       shift and go to state 121
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 142

    (94) relational_expression -> expression relational_operator expression .
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (94) relational_expression -> expression . relational_operator expression
    (95) relational_operator -> . EQUAL_TO
    (96) relational_operator -> . NOT_EQUAL_TO
    (97) relational_operator -> . LESS_THAN
    (98) relational_operator -> . GREATER_THAN
    (99) relational_operator -> . LESS_EQUAL
    (100) relational_operator -> . GREATER_EQUAL
    (101) relational_operator -> . IDENTICAL_TO
    (102) relational_operator -> . NOT_IDENTICAL_TO
    (103) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL_TO resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for NOT_IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    LOGICAL_AND     reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    CLOSE_TAG       reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    ONE_LINE_COMMENT reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    MULTI_LINE_COMMENT reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    BREAK           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    CONTINUE        reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    IF              reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    WHILE           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    FUNCTION        reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    FSCANF          reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    FGETS           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    NAME            reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    RETURN          reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    FOR             reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    TRUE            reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    FALSE           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    LOGICAL_NOT     reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    LEFT_PAREN      reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    PRINT           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    ECHO            reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    ID              reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    INTEGER         reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    FLOAT           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    TIMES           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    DIVIDE          reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    SEMICOLON       reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    DOT             reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    COMMA           reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    RIGHT_BRACE     reduce using rule 94 (relational_expression -> expression relational_operator expression .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    EQUAL_TO        shift and go to state 96
    NOT_EQUAL_TO    shift and go to state 97
    LESS_THAN       shift and go to state 98
    GREATER_THAN    shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    IDENTICAL_TO    shift and go to state 102
    NOT_IDENTICAL_TO shift and go to state 103
    DIFFERENT       shift and go to state 104

  ! PLUS            [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! MINUS           [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! EQUAL_TO        [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_THAN       [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_THAN    [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_EQUAL      [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! IDENTICAL_TO    [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]
  ! DIFFERENT       [ reduce using rule 94 (relational_expression -> expression relational_operator expression .) ]

    relational_operator            shift and go to state 93

state 143

    (51) expression -> expression PLUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor
    (53) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 51 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 51 (expression -> expression PLUS term .)
    PLUS            reduce using rule 51 (expression -> expression PLUS term .)
    MINUS           reduce using rule 51 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 51 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 51 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 51 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 51 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 51 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 51 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 51 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 51 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 51 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 51 (expression -> expression PLUS term .)
    DOT             reduce using rule 51 (expression -> expression PLUS term .)
    COMMA           reduce using rule 51 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 51 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 51 (expression -> expression PLUS term .)
    CLOSE_TAG       reduce using rule 51 (expression -> expression PLUS term .)
    ONE_LINE_COMMENT reduce using rule 51 (expression -> expression PLUS term .)
    MULTI_LINE_COMMENT reduce using rule 51 (expression -> expression PLUS term .)
    BREAK           reduce using rule 51 (expression -> expression PLUS term .)
    CONTINUE        reduce using rule 51 (expression -> expression PLUS term .)
    IF              reduce using rule 51 (expression -> expression PLUS term .)
    WHILE           reduce using rule 51 (expression -> expression PLUS term .)
    FUNCTION        reduce using rule 51 (expression -> expression PLUS term .)
    FSCANF          reduce using rule 51 (expression -> expression PLUS term .)
    FGETS           reduce using rule 51 (expression -> expression PLUS term .)
    NAME            reduce using rule 51 (expression -> expression PLUS term .)
    RETURN          reduce using rule 51 (expression -> expression PLUS term .)
    FOR             reduce using rule 51 (expression -> expression PLUS term .)
    TRUE            reduce using rule 51 (expression -> expression PLUS term .)
    FALSE           reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_NOT     reduce using rule 51 (expression -> expression PLUS term .)
    LEFT_PAREN      reduce using rule 51 (expression -> expression PLUS term .)
    PRINT           reduce using rule 51 (expression -> expression PLUS term .)
    ECHO            reduce using rule 51 (expression -> expression PLUS term .)
    ID              reduce using rule 51 (expression -> expression PLUS term .)
    INTEGER         reduce using rule 51 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 51 (expression -> expression PLUS term .)
    RIGHT_BRACE     reduce using rule 51 (expression -> expression PLUS term .)
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 108

  ! TIMES           [ reduce using rule 51 (expression -> expression PLUS term .) ]
  ! DIVIDE          [ reduce using rule 51 (expression -> expression PLUS term .) ]
  ! PLUS            [ reduce using rule 53 (expression -> term .) ]
  ! MINUS           [ reduce using rule 53 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 53 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 53 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 53 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 53 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 53 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 53 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 53 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 53 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 53 (expression -> term .) ]


state 144

    (52) expression -> expression MINUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor
    (53) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 52 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 52 (expression -> expression MINUS term .)
    PLUS            reduce using rule 52 (expression -> expression MINUS term .)
    MINUS           reduce using rule 52 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 52 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 52 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 52 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 52 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 52 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 52 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 52 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 52 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 52 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 52 (expression -> expression MINUS term .)
    DOT             reduce using rule 52 (expression -> expression MINUS term .)
    COMMA           reduce using rule 52 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 52 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 52 (expression -> expression MINUS term .)
    CLOSE_TAG       reduce using rule 52 (expression -> expression MINUS term .)
    ONE_LINE_COMMENT reduce using rule 52 (expression -> expression MINUS term .)
    MULTI_LINE_COMMENT reduce using rule 52 (expression -> expression MINUS term .)
    BREAK           reduce using rule 52 (expression -> expression MINUS term .)
    CONTINUE        reduce using rule 52 (expression -> expression MINUS term .)
    IF              reduce using rule 52 (expression -> expression MINUS term .)
    WHILE           reduce using rule 52 (expression -> expression MINUS term .)
    FUNCTION        reduce using rule 52 (expression -> expression MINUS term .)
    FSCANF          reduce using rule 52 (expression -> expression MINUS term .)
    FGETS           reduce using rule 52 (expression -> expression MINUS term .)
    NAME            reduce using rule 52 (expression -> expression MINUS term .)
    RETURN          reduce using rule 52 (expression -> expression MINUS term .)
    FOR             reduce using rule 52 (expression -> expression MINUS term .)
    TRUE            reduce using rule 52 (expression -> expression MINUS term .)
    FALSE           reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_NOT     reduce using rule 52 (expression -> expression MINUS term .)
    LEFT_PAREN      reduce using rule 52 (expression -> expression MINUS term .)
    PRINT           reduce using rule 52 (expression -> expression MINUS term .)
    ECHO            reduce using rule 52 (expression -> expression MINUS term .)
    ID              reduce using rule 52 (expression -> expression MINUS term .)
    INTEGER         reduce using rule 52 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 52 (expression -> expression MINUS term .)
    RIGHT_BRACE     reduce using rule 52 (expression -> expression MINUS term .)
    TIMES           shift and go to state 107
    DIVIDE          shift and go to state 108

  ! TIMES           [ reduce using rule 52 (expression -> expression MINUS term .) ]
  ! DIVIDE          [ reduce using rule 52 (expression -> expression MINUS term .) ]
  ! PLUS            [ reduce using rule 53 (expression -> term .) ]
  ! MINUS           [ reduce using rule 53 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 53 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 53 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 53 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 53 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 53 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 53 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 53 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 53 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 53 (expression -> term .) ]


state 145

    (69) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (78) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 173
    COMMA           shift and go to state 174


state 146

    (70) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    SEMICOLON       reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    TRUE            reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 70 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 147

    (77) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 77 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 77 (assignment_list -> assignment_statement .)


state 148

    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (31) assignment_operator -> . EQUALS
    (32) assignment_operator -> . PLUS_EQUALS
    (33) assignment_operator -> . MINUS_EQUALS
    (34) assignment_operator -> . TIMES_EQUALS
    (35) assignment_operator -> . DIVIDE_EQUALS
    (36) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 83
    MINUS_MINUS     shift and go to state 84
    EQUALS          shift and go to state 135
    PLUS_EQUALS     shift and go to state 86
    MINUS_EQUALS    shift and go to state 87
    TIMES_EQUALS    shift and go to state 88
    DIVIDE_EQUALS   shift and go to state 89
    MOD_EQUALS      shift and go to state 90

    assignment_operator            shift and go to state 82

state 149

    (54) term -> term TIMES factor .
    (56) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 54 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 54 (term -> term TIMES factor .)
    TIMES           reduce using rule 54 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 54 (term -> term TIMES factor .)
    PLUS            reduce using rule 54 (term -> term TIMES factor .)
    MINUS           reduce using rule 54 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 54 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 54 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 54 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 54 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 54 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 54 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 54 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 54 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 54 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 54 (term -> term TIMES factor .)
    DOT             reduce using rule 54 (term -> term TIMES factor .)
    COMMA           reduce using rule 54 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 54 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 54 (term -> term TIMES factor .)
    CLOSE_TAG       reduce using rule 54 (term -> term TIMES factor .)
    ONE_LINE_COMMENT reduce using rule 54 (term -> term TIMES factor .)
    MULTI_LINE_COMMENT reduce using rule 54 (term -> term TIMES factor .)
    BREAK           reduce using rule 54 (term -> term TIMES factor .)
    CONTINUE        reduce using rule 54 (term -> term TIMES factor .)
    IF              reduce using rule 54 (term -> term TIMES factor .)
    WHILE           reduce using rule 54 (term -> term TIMES factor .)
    FUNCTION        reduce using rule 54 (term -> term TIMES factor .)
    FSCANF          reduce using rule 54 (term -> term TIMES factor .)
    FGETS           reduce using rule 54 (term -> term TIMES factor .)
    NAME            reduce using rule 54 (term -> term TIMES factor .)
    RETURN          reduce using rule 54 (term -> term TIMES factor .)
    FOR             reduce using rule 54 (term -> term TIMES factor .)
    TRUE            reduce using rule 54 (term -> term TIMES factor .)
    FALSE           reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_NOT     reduce using rule 54 (term -> term TIMES factor .)
    LEFT_PAREN      reduce using rule 54 (term -> term TIMES factor .)
    PRINT           reduce using rule 54 (term -> term TIMES factor .)
    ECHO            reduce using rule 54 (term -> term TIMES factor .)
    ID              reduce using rule 54 (term -> term TIMES factor .)
    INTEGER         reduce using rule 54 (term -> term TIMES factor .)
    FLOAT           reduce using rule 54 (term -> term TIMES factor .)
    RIGHT_BRACE     reduce using rule 54 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 56 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 56 (term -> factor .) ]
  ! PLUS            [ reduce using rule 56 (term -> factor .) ]
  ! MINUS           [ reduce using rule 56 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 56 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 56 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 56 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 56 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 56 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 56 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 56 (term -> factor .) ]


state 150

    (55) term -> term DIVIDE factor .
    (56) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 55 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 55 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 55 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 55 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 55 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 55 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 55 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 55 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 55 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 55 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 55 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 55 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 55 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 55 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 55 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 55 (term -> term DIVIDE factor .)
    DOT             reduce using rule 55 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 55 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 55 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 55 (term -> term DIVIDE factor .)
    CLOSE_TAG       reduce using rule 55 (term -> term DIVIDE factor .)
    ONE_LINE_COMMENT reduce using rule 55 (term -> term DIVIDE factor .)
    MULTI_LINE_COMMENT reduce using rule 55 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 55 (term -> term DIVIDE factor .)
    CONTINUE        reduce using rule 55 (term -> term DIVIDE factor .)
    IF              reduce using rule 55 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 55 (term -> term DIVIDE factor .)
    FUNCTION        reduce using rule 55 (term -> term DIVIDE factor .)
    FSCANF          reduce using rule 55 (term -> term DIVIDE factor .)
    FGETS           reduce using rule 55 (term -> term DIVIDE factor .)
    NAME            reduce using rule 55 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 55 (term -> term DIVIDE factor .)
    FOR             reduce using rule 55 (term -> term DIVIDE factor .)
    TRUE            reduce using rule 55 (term -> term DIVIDE factor .)
    FALSE           reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_NOT     reduce using rule 55 (term -> term DIVIDE factor .)
    LEFT_PAREN      reduce using rule 55 (term -> term DIVIDE factor .)
    PRINT           reduce using rule 55 (term -> term DIVIDE factor .)
    ECHO            reduce using rule 55 (term -> term DIVIDE factor .)
    ID              reduce using rule 55 (term -> term DIVIDE factor .)
    INTEGER         reduce using rule 55 (term -> term DIVIDE factor .)
    FLOAT           reduce using rule 55 (term -> term DIVIDE factor .)
    RIGHT_BRACE     reduce using rule 55 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 56 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 56 (term -> factor .) ]
  ! PLUS            [ reduce using rule 56 (term -> factor .) ]
  ! MINUS           [ reduce using rule 56 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 56 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 56 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 56 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 56 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 56 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 56 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 56 (term -> factor .) ]


state 151

    (61) if_statement -> IF parenthesized_condition block else_if_extended . if_part3
    (63) else_if_extended -> else_if_extended . if_part2
    (66) if_part3 -> . ELSE block
    (67) if_part3 -> .
    (64) if_part2 -> . ELSEIF parenthesized_condition block
    (65) if_part2 -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSEIF resolved as shift
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for ONE_LINE_COMMENT resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for MULTI_LINE_COMMENT resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for IF resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for FSCANF resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for FGETS resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for NAME resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for FOR resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for LOGICAL_NOT resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for LEFT_PAREN resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for ECHO resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for ID resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for INTEGER resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 65 (if_part2 -> .)
  ! reduce/reduce conflict for RIGHT_BRACE resolved using rule 65 (if_part2 -> .)
    ELSE            shift and go to state 177
    ELSEIF          shift and go to state 153
    CLOSE_TAG       reduce using rule 65 (if_part2 -> .)
    ONE_LINE_COMMENT reduce using rule 65 (if_part2 -> .)
    MULTI_LINE_COMMENT reduce using rule 65 (if_part2 -> .)
    BREAK           reduce using rule 65 (if_part2 -> .)
    CONTINUE        reduce using rule 65 (if_part2 -> .)
    IF              reduce using rule 65 (if_part2 -> .)
    WHILE           reduce using rule 65 (if_part2 -> .)
    FUNCTION        reduce using rule 65 (if_part2 -> .)
    FSCANF          reduce using rule 65 (if_part2 -> .)
    FGETS           reduce using rule 65 (if_part2 -> .)
    NAME            reduce using rule 65 (if_part2 -> .)
    RETURN          reduce using rule 65 (if_part2 -> .)
    FOR             reduce using rule 65 (if_part2 -> .)
    TRUE            reduce using rule 65 (if_part2 -> .)
    FALSE           reduce using rule 65 (if_part2 -> .)
    LOGICAL_NOT     reduce using rule 65 (if_part2 -> .)
    LEFT_PAREN      reduce using rule 65 (if_part2 -> .)
    PRINT           reduce using rule 65 (if_part2 -> .)
    ECHO            reduce using rule 65 (if_part2 -> .)
    ID              reduce using rule 65 (if_part2 -> .)
    INTEGER         reduce using rule 65 (if_part2 -> .)
    FLOAT           reduce using rule 65 (if_part2 -> .)
    RIGHT_BRACE     reduce using rule 65 (if_part2 -> .)

  ! CLOSE_TAG       [ reduce using rule 67 (if_part3 -> .) ]
  ! ONE_LINE_COMMENT [ reduce using rule 67 (if_part3 -> .) ]
  ! MULTI_LINE_COMMENT [ reduce using rule 67 (if_part3 -> .) ]
  ! BREAK           [ reduce using rule 67 (if_part3 -> .) ]
  ! CONTINUE        [ reduce using rule 67 (if_part3 -> .) ]
  ! IF              [ reduce using rule 67 (if_part3 -> .) ]
  ! WHILE           [ reduce using rule 67 (if_part3 -> .) ]
  ! FUNCTION        [ reduce using rule 67 (if_part3 -> .) ]
  ! FSCANF          [ reduce using rule 67 (if_part3 -> .) ]
  ! FGETS           [ reduce using rule 67 (if_part3 -> .) ]
  ! NAME            [ reduce using rule 67 (if_part3 -> .) ]
  ! RETURN          [ reduce using rule 67 (if_part3 -> .) ]
  ! FOR             [ reduce using rule 67 (if_part3 -> .) ]
  ! TRUE            [ reduce using rule 67 (if_part3 -> .) ]
  ! FALSE           [ reduce using rule 67 (if_part3 -> .) ]
  ! LOGICAL_NOT     [ reduce using rule 67 (if_part3 -> .) ]
  ! LEFT_PAREN      [ reduce using rule 67 (if_part3 -> .) ]
  ! PRINT           [ reduce using rule 67 (if_part3 -> .) ]
  ! ECHO            [ reduce using rule 67 (if_part3 -> .) ]
  ! ID              [ reduce using rule 67 (if_part3 -> .) ]
  ! INTEGER         [ reduce using rule 67 (if_part3 -> .) ]
  ! FLOAT           [ reduce using rule 67 (if_part3 -> .) ]
  ! RIGHT_BRACE     [ reduce using rule 67 (if_part3 -> .) ]
  ! ELSE            [ reduce using rule 65 (if_part2 -> .) ]
  ! ELSEIF          [ reduce using rule 65 (if_part2 -> .) ]

    if_part3                       shift and go to state 175
    if_part2                       shift and go to state 176

state 152

    (62) else_if_extended -> if_part2 .

    ELSE            reduce using rule 62 (else_if_extended -> if_part2 .)
    ELSEIF          reduce using rule 62 (else_if_extended -> if_part2 .)
    CLOSE_TAG       reduce using rule 62 (else_if_extended -> if_part2 .)
    ONE_LINE_COMMENT reduce using rule 62 (else_if_extended -> if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 62 (else_if_extended -> if_part2 .)
    BREAK           reduce using rule 62 (else_if_extended -> if_part2 .)
    CONTINUE        reduce using rule 62 (else_if_extended -> if_part2 .)
    IF              reduce using rule 62 (else_if_extended -> if_part2 .)
    WHILE           reduce using rule 62 (else_if_extended -> if_part2 .)
    FUNCTION        reduce using rule 62 (else_if_extended -> if_part2 .)
    FSCANF          reduce using rule 62 (else_if_extended -> if_part2 .)
    FGETS           reduce using rule 62 (else_if_extended -> if_part2 .)
    NAME            reduce using rule 62 (else_if_extended -> if_part2 .)
    RETURN          reduce using rule 62 (else_if_extended -> if_part2 .)
    FOR             reduce using rule 62 (else_if_extended -> if_part2 .)
    TRUE            reduce using rule 62 (else_if_extended -> if_part2 .)
    FALSE           reduce using rule 62 (else_if_extended -> if_part2 .)
    LOGICAL_NOT     reduce using rule 62 (else_if_extended -> if_part2 .)
    LEFT_PAREN      reduce using rule 62 (else_if_extended -> if_part2 .)
    PRINT           reduce using rule 62 (else_if_extended -> if_part2 .)
    ECHO            reduce using rule 62 (else_if_extended -> if_part2 .)
    ID              reduce using rule 62 (else_if_extended -> if_part2 .)
    INTEGER         reduce using rule 62 (else_if_extended -> if_part2 .)
    FLOAT           reduce using rule 62 (else_if_extended -> if_part2 .)
    RIGHT_BRACE     reduce using rule 62 (else_if_extended -> if_part2 .)


state 153

    (64) if_part2 -> ELSEIF . parenthesized_condition block
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 58

    parenthesized_condition        shift and go to state 178

state 154

    (81) block -> LEFT_BRACE statements . RIGHT_BRACE
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . condition
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . statement_return
    (61) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (68) while_statement -> . WHILE parenthesized_condition block
    (71) for_statement -> . for_part1 condition for_part3
    (72) for_statement -> . for_part1 for_part3
    (21) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (111) array_declaration_statement -> . variable EQUALS array
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (22) statement_return -> . RETURN expression
    (69) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (70) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID
    (94) relational_expression -> . expression relational_operator expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN

    RIGHT_BRACE     shift and go to state 179
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 22
    WHILE           shift and go to state 24
    FUNCTION        shift and go to state 26
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    NAME            shift and go to state 27
    RETURN          shift and go to state 36
    FOR             shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42
    LEFT_PAREN      shift and go to state 28
    PRINT           shift and go to state 43
    ECHO            shift and go to state 44
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    statement2                     shift and go to state 51
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    condition                      shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    statement_return               shift and go to state 21
    parenthesized_condition        shift and go to state 23
    for_part1                      shift and go to state 25
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    expression                     shift and go to state 37
    relational_expression          shift and go to state 41
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 155

    (82) block -> LEFT_BRACE RIGHT_BRACE .

    ELSEIF          reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSE            reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    TRUE            reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    FALSE           reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    INTEGER         reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    FLOAT           reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 82 (block -> LEFT_BRACE RIGHT_BRACE .)


state 156

    (73) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (75) for_part4 -> . block
    (76) for_part4 -> . SEMICOLON
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 158
    LEFT_BRACE      shift and go to state 111

    for_part4                      shift and go to state 180
    block                          shift and go to state 160

state 157

    (80) statement_list -> statement_list COMMA . statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . statement_return
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (111) array_declaration_statement -> . variable EQUALS array
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (22) statement_return -> . RETURN expression
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    NAME            shift and go to state 27
    RETURN          shift and go to state 36
    PRINT           shift and go to state 43
    ECHO            shift and go to state 44
    ID              shift and go to state 45

    statement                      shift and go to state 181
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    statement_return               shift and go to state 21
    print_function                 shift and go to state 32
    variable                       shift and go to state 117

state 158

    (76) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 76 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 76 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 76 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 76 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 76 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 76 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 76 (for_part4 -> SEMICOLON .)
    FUNCTION        reduce using rule 76 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 76 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 76 (for_part4 -> SEMICOLON .)
    NAME            reduce using rule 76 (for_part4 -> SEMICOLON .)
    RETURN          reduce using rule 76 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 76 (for_part4 -> SEMICOLON .)
    TRUE            reduce using rule 76 (for_part4 -> SEMICOLON .)
    FALSE           reduce using rule 76 (for_part4 -> SEMICOLON .)
    LOGICAL_NOT     reduce using rule 76 (for_part4 -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 76 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 76 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 76 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 76 (for_part4 -> SEMICOLON .)
    INTEGER         reduce using rule 76 (for_part4 -> SEMICOLON .)
    FLOAT           reduce using rule 76 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 76 (for_part4 -> SEMICOLON .)


state 159

    (74) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    TRUE            reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FALSE           reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    LOGICAL_NOT     reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    LEFT_PAREN      reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    INTEGER         reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FLOAT           reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 74 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 160

    (75) for_part4 -> block .

    CLOSE_TAG       reduce using rule 75 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 75 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 75 (for_part4 -> block .)
    BREAK           reduce using rule 75 (for_part4 -> block .)
    CONTINUE        reduce using rule 75 (for_part4 -> block .)
    IF              reduce using rule 75 (for_part4 -> block .)
    WHILE           reduce using rule 75 (for_part4 -> block .)
    FUNCTION        reduce using rule 75 (for_part4 -> block .)
    FSCANF          reduce using rule 75 (for_part4 -> block .)
    FGETS           reduce using rule 75 (for_part4 -> block .)
    NAME            reduce using rule 75 (for_part4 -> block .)
    RETURN          reduce using rule 75 (for_part4 -> block .)
    FOR             reduce using rule 75 (for_part4 -> block .)
    TRUE            reduce using rule 75 (for_part4 -> block .)
    FALSE           reduce using rule 75 (for_part4 -> block .)
    LOGICAL_NOT     reduce using rule 75 (for_part4 -> block .)
    LEFT_PAREN      reduce using rule 75 (for_part4 -> block .)
    PRINT           reduce using rule 75 (for_part4 -> block .)
    ECHO            reduce using rule 75 (for_part4 -> block .)
    ID              reduce using rule 75 (for_part4 -> block .)
    INTEGER         reduce using rule 75 (for_part4 -> block .)
    FLOAT           reduce using rule 75 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 75 (for_part4 -> block .)


state 161

    (21) function_statement -> FUNCTION NAME LEFT_PAREN arguments . RIGHT_PAREN block
    (42) arguments -> arguments . DOT argument
    (43) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 182
    DOT             shift and go to state 131
    COMMA           shift and go to state 132


state 162

    (110) function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 110 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    DOT             reduce using rule 110 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 110 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 110 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 110 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)


state 163

    (115) array_elements -> array_elements COMMA . argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    argument                       shift and go to state 183
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 164

    (37) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 37 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 37 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 37 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 165

    (107) casting -> LEFT_PAREN casting_type RIGHT_PAREN .

    STRING          reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NAME            reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FGETS           reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ID              reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    INTEGER         reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FLOAT           reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    TRUE            reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FALSE           reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 107 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)


state 166

    (42) arguments -> arguments DOT argument .

    DOT             reduce using rule 42 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 42 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 42 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 42 (arguments -> arguments DOT argument .)


state 167

    (43) arguments -> arguments COMMA argument .

    DOT             reduce using rule 43 (arguments -> arguments COMMA argument .)
    COMMA           reduce using rule 43 (arguments -> arguments COMMA argument .)
    SEMICOLON       reduce using rule 43 (arguments -> arguments COMMA argument .)
    RIGHT_PAREN     reduce using rule 43 (arguments -> arguments COMMA argument .)


state 168

    (116) array_indexing -> variable LEFT_BRACKET INTEGER . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 184


state 169

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 185


state 170

    (23) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    DOT             reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)


state 171

    (112) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (114) array_elements -> . argument
    (115) array_elements -> . array_elements COMMA argument
    (44) argument -> . STRING
    (45) argument -> . expression
    (46) argument -> . assignment_statement
    (47) argument -> . function_call
    (48) argument -> . fgets_statement
    (49) argument -> . array_indexing
    (50) argument -> . casting argument
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (110) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (116) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (107) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . condition
    (60) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (83) condition -> . simple_condition
    (84) condition -> . negated_condition
    (85) condition -> . complex_condition
    (86) condition -> . parenthesized_condition
    (87) simple_condition -> . TRUE
    (88) simple_condition -> . FALSE
    (89) simple_condition -> . variable
    (90) simple_condition -> . relational_expression
    (91) negated_condition -> . LOGICAL_NOT condition
    (92) complex_condition -> . condition logical_operator condition
    (93) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (94) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 71
    NAME            shift and go to state 27
    FGETS           shift and go to state 34
    LEFT_PAREN      shift and go to state 119
    ID              shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    LOGICAL_NOT     shift and go to state 42

    array_elements                 shift and go to state 186
    argument                       shift and go to state 121
    expression                     shift and go to state 72
    assignment_statement           shift and go to state 73
    function_call                  shift and go to state 74
    fgets_statement                shift and go to state 75
    array_indexing                 shift and go to state 76
    casting                        shift and go to state 77
    term                           shift and go to state 46
    variable                       shift and go to state 78
    factor                         shift and go to state 47
    condition                      shift and go to state 79
    simple_condition               shift and go to state 29
    negated_condition              shift and go to state 30
    complex_condition              shift and go to state 31
    parenthesized_condition        shift and go to state 23
    relational_expression          shift and go to state 41

state 172

    (113) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (115) array_elements -> array_elements . COMMA argument

    RIGHT_BRACKET   shift and go to state 187
    COMMA           shift and go to state 163


state 173

    (69) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    SEMICOLON       reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    TRUE            reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 69 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)


state 174

    (78) assignment_list -> assignment_list COMMA . assignment_statement
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (27) variable -> . ID

    ID              shift and go to state 45

    assignment_statement           shift and go to state 188
    variable                       shift and go to state 148

state 175

    (61) if_statement -> IF parenthesized_condition block else_if_extended if_part3 .

    CLOSE_TAG       reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ONE_LINE_COMMENT reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    BREAK           reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CONTINUE        reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    IF              reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    WHILE           reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FUNCTION        reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FSCANF          reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FGETS           reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    NAME            reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RETURN          reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FOR             reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    TRUE            reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FALSE           reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    LOGICAL_NOT     reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    LEFT_PAREN      reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    PRINT           reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ECHO            reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ID              reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    INTEGER         reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FLOAT           reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RIGHT_BRACE     reduce using rule 61 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)


state 176

    (63) else_if_extended -> else_if_extended if_part2 .

    ELSE            reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    ELSEIF          reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    CLOSE_TAG       reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    ONE_LINE_COMMENT reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    BREAK           reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    CONTINUE        reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    IF              reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    WHILE           reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    FUNCTION        reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    FSCANF          reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    FGETS           reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    NAME            reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    RETURN          reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    FOR             reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    TRUE            reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    FALSE           reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    LOGICAL_NOT     reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    LEFT_PAREN      reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    PRINT           reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    ECHO            reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    ID              reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    INTEGER         reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    FLOAT           reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)
    RIGHT_BRACE     reduce using rule 63 (else_if_extended -> else_if_extended if_part2 .)


state 177

    (66) if_part3 -> ELSE . block
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 111

    block                          shift and go to state 189

state 178

    (64) if_part2 -> ELSEIF parenthesized_condition . block
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 111

    block                          shift and go to state 190

state 179

    (81) block -> LEFT_BRACE statements RIGHT_BRACE .

    ELSEIF          reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSE            reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    NAME            reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RETURN          reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    TRUE            reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FALSE           reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    INTEGER         reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FLOAT           reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 81 (block -> LEFT_BRACE statements RIGHT_BRACE .)


state 180

    (73) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    TRUE            reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FALSE           reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    LOGICAL_NOT     reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    LEFT_PAREN      reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    INTEGER         reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FLOAT           reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 73 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)


state 181

    (80) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 80 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 80 (statement_list -> statement_list COMMA statement .)


state 182

    (21) function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN . block
    (81) block -> . LEFT_BRACE statements RIGHT_BRACE
    (82) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 111

    block                          shift and go to state 191

state 183

    (115) array_elements -> array_elements COMMA argument .

    RIGHT_PAREN     reduce using rule 115 (array_elements -> array_elements COMMA argument .)
    COMMA           reduce using rule 115 (array_elements -> array_elements COMMA argument .)
    RIGHT_BRACKET   reduce using rule 115 (array_elements -> array_elements COMMA argument .)


state 184

    (116) array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .

    DOT             reduce using rule 116 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    COMMA           reduce using rule 116 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 116 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 116 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 116 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)


state 185

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 192


state 186

    (112) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (115) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 193
    COMMA           shift and go to state 163


state 187

    (113) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    SEMICOLON       reduce using rule 113 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 113 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 113 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)


state 188

    (78) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 78 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 78 (assignment_list -> assignment_list COMMA assignment_statement .)


state 189

    (66) if_part3 -> ELSE block .

    CLOSE_TAG       reduce using rule 66 (if_part3 -> ELSE block .)
    ONE_LINE_COMMENT reduce using rule 66 (if_part3 -> ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 66 (if_part3 -> ELSE block .)
    BREAK           reduce using rule 66 (if_part3 -> ELSE block .)
    CONTINUE        reduce using rule 66 (if_part3 -> ELSE block .)
    IF              reduce using rule 66 (if_part3 -> ELSE block .)
    WHILE           reduce using rule 66 (if_part3 -> ELSE block .)
    FUNCTION        reduce using rule 66 (if_part3 -> ELSE block .)
    FSCANF          reduce using rule 66 (if_part3 -> ELSE block .)
    FGETS           reduce using rule 66 (if_part3 -> ELSE block .)
    NAME            reduce using rule 66 (if_part3 -> ELSE block .)
    RETURN          reduce using rule 66 (if_part3 -> ELSE block .)
    FOR             reduce using rule 66 (if_part3 -> ELSE block .)
    TRUE            reduce using rule 66 (if_part3 -> ELSE block .)
    FALSE           reduce using rule 66 (if_part3 -> ELSE block .)
    LOGICAL_NOT     reduce using rule 66 (if_part3 -> ELSE block .)
    LEFT_PAREN      reduce using rule 66 (if_part3 -> ELSE block .)
    PRINT           reduce using rule 66 (if_part3 -> ELSE block .)
    ECHO            reduce using rule 66 (if_part3 -> ELSE block .)
    ID              reduce using rule 66 (if_part3 -> ELSE block .)
    INTEGER         reduce using rule 66 (if_part3 -> ELSE block .)
    FLOAT           reduce using rule 66 (if_part3 -> ELSE block .)
    RIGHT_BRACE     reduce using rule 66 (if_part3 -> ELSE block .)


state 190

    (64) if_part2 -> ELSEIF parenthesized_condition block .

    ELSE            reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    ELSEIF          reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLOSE_TAG       reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    BREAK           reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    CONTINUE        reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    IF              reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    WHILE           reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    FUNCTION        reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    FSCANF          reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    FGETS           reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    NAME            reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    RETURN          reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    FOR             reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    TRUE            reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    FALSE           reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    PRINT           reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    ECHO            reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    ID              reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    INTEGER         reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    FLOAT           reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 64 (if_part2 -> ELSEIF parenthesized_condition block .)


state 191

    (21) function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    BREAK           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    CONTINUE        reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    IF              reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    WHILE           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FUNCTION        reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FSCANF          reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FGETS           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    NAME            reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    RETURN          reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FOR             reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    TRUE            reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FALSE           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    LOGICAL_NOT     reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    PRINT           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    ECHO            reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    ID              reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    INTEGER         reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FLOAT           reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 21 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)


state 192

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (25) variable_list -> . variable
    (26) variable_list -> . variable_list COMMA variable
    (27) variable -> . ID

    ID              shift and go to state 45

    variable_list                  shift and go to state 194
    variable                       shift and go to state 195

state 193

    (112) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 112 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 112 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 112 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 194

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (26) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 197
    COMMA           shift and go to state 196


state 195

    (25) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 25 (variable_list -> variable .)
    COMMA           reduce using rule 25 (variable_list -> variable .)


state 196

    (26) variable_list -> variable_list COMMA . variable
    (27) variable -> . ID

    ID              shift and go to state 45

    variable                       shift and go to state 198

state 197

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 24 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 24 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 24 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)


state 198

    (26) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 26 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 26 (variable_list -> variable_list COMMA variable .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TIMES in state 46 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 46 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 66 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 69 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 79 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 79 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 79 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 109 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 110 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 142 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL_TO in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for IDENTICAL_TO in state 142 resolved as shift
WARNING: shift/reduce conflict for NOT_IDENTICAL_TO in state 142 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 144 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 144 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 151 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 151 resolved as shift
WARNING: reduce/reduce conflict in state 106 resolved using rule (factor -> condition)
WARNING: rejected rule (negated_condition -> LOGICAL_NOT condition) in state 106
WARNING: reduce/reduce conflict in state 109 resolved using rule (factor -> condition)
WARNING: rejected rule (complex_condition -> condition logical_operator condition) in state 109
WARNING: reduce/reduce conflict in state 143 resolved using rule (expression -> expression PLUS term)
WARNING: rejected rule (expression -> term) in state 143
WARNING: reduce/reduce conflict in state 144 resolved using rule (expression -> expression MINUS term)
WARNING: rejected rule (expression -> term) in state 144
WARNING: reduce/reduce conflict in state 149 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 149
WARNING: reduce/reduce conflict in state 150 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 150
WARNING: reduce/reduce conflict in state 151 resolved using rule (if_part2 -> <empty>)
WARNING: rejected rule (if_part3 -> <empty>) in state 151
WARNING: Rule (if_part3 -> <empty>) is never reduced
