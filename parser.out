Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    AS
    ASYNC
    AWAIT
    BOOL
    BREAK
    CALL
    CALLABLE
    CASE
    CATCH
    CLASS
    CLONE
    CLOSE_TAG
    COLON
    CONST
    CONTINUE
    DECLARE
    DEFAULT
    DIE
    DIVIDE_EQUALS
    DO
    ELSEIF
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FGETS
    FINAL
    FINALLY
    FN
    FOR
    FOREACH
    FUNCTION
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    KEY_VALUE
    LEFT_BRACKET
    LIST
    LPAREN
    MATCH
    MINUS_EQUALS
    MINUS_MINUS
    MIXED
    MOD
    MOD_EQUALS
    MULTI_LINE_COMMENT
    NAME
    NAMESPACE
    NEW
    NULL
    OBJECT
    ONE_LINE_COMMENT
    OPEN_TAG
    OR
    PLUS_EQUALS
    PLUS_PLUS
    POWER
    PRIVATE
    PROTECTED
    PUBLIC
    REQUIRE
    REQUIRE_ONCE
    RETURN
    RIGHT_BRACKET
    RPAREN
    SELF
    STATIC
    SWITCH
    THROW
    TIMES_EQUALS
    TRAIT
    TRY
    UNSET
    USE
    VAR
    VOID
    WHILE
    XOR
    YIELD
    YIELD_FROM

Grammar

Rule 0     S' -> statement
Rule 1     statement -> print_statement
Rule 2     statement -> fscanf_statement
Rule 3     statement -> assignment_statement
Rule 4     statement -> if_statement
Rule 5     statement -> array_declaration_statement
Rule 6     fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON
Rule 7     variable_list -> variable
Rule 8     variable_list -> variable_list COMMA variable
Rule 9     variable -> ID
Rule 10    print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 11    print_statement -> ECHO arguments SEMICOLON
Rule 12    print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 13    print_statement -> PRINT arguments SEMICOLON
Rule 14    arguments -> argument
Rule 15    arguments -> arguments DOT argument
Rule 16    argument -> INTEGER
Rule 17    argument -> FLOAT
Rule 18    argument -> variable
Rule 19    argument -> TRUE
Rule 20    argument -> FALSE
Rule 21    argument -> STRING
Rule 22    argument -> expression
Rule 23    assignment_statement -> variable EQUALS argument SEMICOLON
Rule 24    expression -> expression PLUS term
Rule 25    expression -> expression MINUS term
Rule 26    expression -> term
Rule 27    term -> term TIMES factor
Rule 28    term -> term DIVIDE factor
Rule 29    term -> factor
Rule 30    factor -> INTEGER
Rule 31    factor -> FLOAT
Rule 32    factor -> variable
Rule 33    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 34    if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block
Rule 35    if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
Rule 36    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 37    statements -> statement
Rule 38    statements -> statements statement
Rule 39    relational_operator -> EQUAL_TO
Rule 40    relational_operator -> NOT_EQUAL_TO
Rule 41    relational_operator -> LESS_THAN
Rule 42    relational_operator -> GREATER_THAN
Rule 43    relational_operator -> LESS_EQUAL
Rule 44    relational_operator -> GREATER_EQUAL
Rule 45    relational_operator -> IDENTICAL_TO
Rule 46    relational_operator -> NOT_IDENTICAL_TO
Rule 47    relational_operator -> DIFFERENT
Rule 48    condition -> TRUE
Rule 49    condition -> FALSE
Rule 50    condition -> expression relational_operator expression
Rule 51    condition -> condition LOGICAL_AND condition
Rule 52    condition -> condition LOGICAL_OR condition
Rule 53    condition -> condition LOGICAL_XOR condition
Rule 54    condition -> LOGICAL_NOT condition
Rule 55    array_declaration_statement -> variable EQUALS array SEMICOLON
Rule 56    array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 57    array_elements -> argument
Rule 58    array_elements -> array_elements COMMA argument

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
ARRAY                : 56
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 
CALL                 : 
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 
COLON                : 
COMMA                : 6 6 8 58
CONST                : 
CONTINUE             : 
DECLARE              : 
DEFAULT              : 
DIE                  : 
DIFFERENT            : 47
DIVIDE               : 28
DIVIDE_EQUALS        : 
DO                   : 
DOT                  : 15
ECHO                 : 10 11
ELSE                 : 35
ELSEIF               : 
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENUM                 : 
EQUALS               : 23 55
EQUAL_TO             : 39
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 20 49
FGETS                : 
FINAL                : 
FINALLY              : 
FLOAT                : 17 31
FN                   : 
FOR                  : 
FOREACH              : 
FSCANF               : 6
FUNCTION             : 
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 44
GREATER_THAN         : 42
HALT_COMPILER        : 
ID                   : 9
IDENTICAL_TO         : 45
IF                   : 34 35
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 16 30
INTERFACE            : 
ISSET                : 
ITERABLE             : 
KEY_VALUE            : 
LEFT_BRACE           : 36
LEFT_BRACKET         : 
LEFT_PAREN           : 6 10 12 33 34 35 56
LESS_EQUAL           : 43
LESS_THAN            : 41
LIST                 : 
LOGICAL_AND          : 51
LOGICAL_NOT          : 54
LOGICAL_OR           : 52
LOGICAL_XOR          : 53
LPAREN               : 
MATCH                : 
MINUS                : 25
MINUS_EQUALS         : 
MINUS_MINUS          : 
MIXED                : 
MOD                  : 
MOD_EQUALS           : 
MULTI_LINE_COMMENT   : 
NAME                 : 
NAMESPACE            : 
NEW                  : 
NOT_EQUAL_TO         : 40
NOT_IDENTICAL_TO     : 46
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 
OPEN_TAG             : 
OR                   : 
PLUS                 : 24
PLUS_EQUALS          : 
PLUS_PLUS            : 
POWER                : 
PRINT                : 12 13
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 
RIGHT_BRACE          : 36
RIGHT_BRACKET        : 
RIGHT_PAREN          : 6 10 12 33 34 35 56
RPAREN               : 
SELF                 : 
SEMICOLON            : 6 10 11 12 13 23 55
STATIC               : 
STDIN                : 6
STRING               : 6 21
SWITCH               : 
THROW                : 
TIMES                : 27
TIMES_EQUALS         : 
TRAIT                : 
TRUE                 : 19 48
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
VOID                 : 
WHILE                : 
XOR                  : 
YIELD                : 
YIELD_FROM           : 
error                : 

Nonterminals, with rules where they appear

argument             : 14 15 23 57 58
arguments            : 10 11 12 13 15
array                : 55
array_declaration_statement : 5
array_elements       : 56 58
assignment_statement : 3
block                : 34 35 35
condition            : 34 35 51 51 52 52 53 53 54
expression           : 22 24 25 33 50 50
factor               : 27 28 29
fscanf_statement     : 2
if_statement         : 4
print_statement      : 1
relational_operator  : 50
statement            : 37 38 0
statements           : 36 38
term                 : 24 25 26 27 28
variable             : 7 8 18 23 32 55
variable_list        : 6 8

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . print_statement
    (2) statement -> . fscanf_statement
    (3) statement -> . assignment_statement
    (4) statement -> . if_statement
    (5) statement -> . array_declaration_statement
    (10) print_statement -> . ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) print_statement -> . ECHO arguments SEMICOLON
    (12) print_statement -> . PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (13) print_statement -> . PRINT arguments SEMICOLON
    (6) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON
    (23) assignment_statement -> . variable EQUALS argument SEMICOLON
    (34) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (35) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (55) array_declaration_statement -> . variable EQUALS array SEMICOLON
    (9) variable -> . ID

    ECHO            shift and go to state 7
    PRINT           shift and go to state 8
    FSCANF          shift and go to state 9
    IF              shift and go to state 11
    ID              shift and go to state 12

    statement                      shift and go to state 1
    print_statement                shift and go to state 2
    fscanf_statement               shift and go to state 3
    assignment_statement           shift and go to state 4
    if_statement                   shift and go to state 5
    array_declaration_statement    shift and go to state 6
    variable                       shift and go to state 10

state 1

    (0) S' -> statement .



state 2

    (1) statement -> print_statement .

    $end            reduce using rule 1 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 1 (statement -> print_statement .)
    ECHO            reduce using rule 1 (statement -> print_statement .)
    PRINT           reduce using rule 1 (statement -> print_statement .)
    FSCANF          reduce using rule 1 (statement -> print_statement .)
    IF              reduce using rule 1 (statement -> print_statement .)
    ID              reduce using rule 1 (statement -> print_statement .)


state 3

    (2) statement -> fscanf_statement .

    $end            reduce using rule 2 (statement -> fscanf_statement .)
    RIGHT_BRACE     reduce using rule 2 (statement -> fscanf_statement .)
    ECHO            reduce using rule 2 (statement -> fscanf_statement .)
    PRINT           reduce using rule 2 (statement -> fscanf_statement .)
    FSCANF          reduce using rule 2 (statement -> fscanf_statement .)
    IF              reduce using rule 2 (statement -> fscanf_statement .)
    ID              reduce using rule 2 (statement -> fscanf_statement .)


state 4

    (3) statement -> assignment_statement .

    $end            reduce using rule 3 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 3 (statement -> assignment_statement .)
    ECHO            reduce using rule 3 (statement -> assignment_statement .)
    PRINT           reduce using rule 3 (statement -> assignment_statement .)
    FSCANF          reduce using rule 3 (statement -> assignment_statement .)
    IF              reduce using rule 3 (statement -> assignment_statement .)
    ID              reduce using rule 3 (statement -> assignment_statement .)


state 5

    (4) statement -> if_statement .

    $end            reduce using rule 4 (statement -> if_statement .)
    RIGHT_BRACE     reduce using rule 4 (statement -> if_statement .)
    ECHO            reduce using rule 4 (statement -> if_statement .)
    PRINT           reduce using rule 4 (statement -> if_statement .)
    FSCANF          reduce using rule 4 (statement -> if_statement .)
    IF              reduce using rule 4 (statement -> if_statement .)
    ID              reduce using rule 4 (statement -> if_statement .)


state 6

    (5) statement -> array_declaration_statement .

    $end            reduce using rule 5 (statement -> array_declaration_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement -> array_declaration_statement .)
    ECHO            reduce using rule 5 (statement -> array_declaration_statement .)
    PRINT           reduce using rule 5 (statement -> array_declaration_statement .)
    FSCANF          reduce using rule 5 (statement -> array_declaration_statement .)
    IF              reduce using rule 5 (statement -> array_declaration_statement .)
    ID              reduce using rule 5 (statement -> array_declaration_statement .)


state 7

    (10) print_statement -> ECHO . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) print_statement -> ECHO . arguments SEMICOLON
    (14) arguments -> . argument
    (15) arguments -> . arguments DOT argument
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (9) variable -> . ID
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 13
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12

    arguments                      shift and go to state 14
    argument                       shift and go to state 15
    variable                       shift and go to state 18
    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 8

    (12) print_statement -> PRINT . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (13) print_statement -> PRINT . arguments SEMICOLON
    (14) arguments -> . argument
    (15) arguments -> . arguments DOT argument
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (9) variable -> . ID
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 25
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12

    arguments                      shift and go to state 26
    argument                       shift and go to state 15
    variable                       shift and go to state 18
    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 9

    (6) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 27


state 10

    (23) assignment_statement -> variable . EQUALS argument SEMICOLON
    (55) array_declaration_statement -> variable . EQUALS array SEMICOLON

    EQUALS          shift and go to state 28


state 11

    (34) if_statement -> IF . LEFT_PAREN condition RIGHT_PAREN block
    (35) if_statement -> IF . LEFT_PAREN condition RIGHT_PAREN block ELSE block

    LEFT_PAREN      shift and go to state 29


state 12

    (9) variable -> ID .

    EQUALS          reduce using rule 9 (variable -> ID .)
    SEMICOLON       reduce using rule 9 (variable -> ID .)
    DOT             reduce using rule 9 (variable -> ID .)
    TIMES           reduce using rule 9 (variable -> ID .)
    DIVIDE          reduce using rule 9 (variable -> ID .)
    PLUS            reduce using rule 9 (variable -> ID .)
    MINUS           reduce using rule 9 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 9 (variable -> ID .)
    EQUAL_TO        reduce using rule 9 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 9 (variable -> ID .)
    LESS_THAN       reduce using rule 9 (variable -> ID .)
    GREATER_THAN    reduce using rule 9 (variable -> ID .)
    LESS_EQUAL      reduce using rule 9 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 9 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 9 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 9 (variable -> ID .)
    DIFFERENT       reduce using rule 9 (variable -> ID .)
    COMMA           reduce using rule 9 (variable -> ID .)
    LOGICAL_AND     reduce using rule 9 (variable -> ID .)
    LOGICAL_OR      reduce using rule 9 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 9 (variable -> ID .)


state 13

    (10) print_statement -> ECHO LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (33) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (14) arguments -> . argument
    (15) arguments -> . arguments DOT argument
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (9) variable -> . ID
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12
    LEFT_PAREN      shift and go to state 30

    arguments                      shift and go to state 31
    expression                     shift and go to state 32
    argument                       shift and go to state 15
    term                           shift and go to state 23
    variable                       shift and go to state 18
    factor                         shift and go to state 24

state 14

    (11) print_statement -> ECHO arguments . SEMICOLON
    (15) arguments -> arguments . DOT argument

    SEMICOLON       shift and go to state 33
    DOT             shift and go to state 34


state 15

    (14) arguments -> argument .

    SEMICOLON       reduce using rule 14 (arguments -> argument .)
    DOT             reduce using rule 14 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 14 (arguments -> argument .)


state 16

    (16) argument -> INTEGER .
    (30) factor -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 16 (argument -> INTEGER .)
  ! reduce/reduce conflict for DOT resolved using rule 16 (argument -> INTEGER .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 16 (argument -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 16 (argument -> INTEGER .)
    SEMICOLON       reduce using rule 16 (argument -> INTEGER .)
    DOT             reduce using rule 16 (argument -> INTEGER .)
    RIGHT_PAREN     reduce using rule 16 (argument -> INTEGER .)
    COMMA           reduce using rule 16 (argument -> INTEGER .)
    TIMES           reduce using rule 30 (factor -> INTEGER .)
    DIVIDE          reduce using rule 30 (factor -> INTEGER .)
    PLUS            reduce using rule 30 (factor -> INTEGER .)
    MINUS           reduce using rule 30 (factor -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 30 (factor -> INTEGER .) ]
  ! DOT             [ reduce using rule 30 (factor -> INTEGER .) ]
  ! RIGHT_PAREN     [ reduce using rule 30 (factor -> INTEGER .) ]
  ! COMMA           [ reduce using rule 30 (factor -> INTEGER .) ]


state 17

    (17) argument -> FLOAT .
    (31) factor -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 17 (argument -> FLOAT .)
  ! reduce/reduce conflict for DOT resolved using rule 17 (argument -> FLOAT .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 17 (argument -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 17 (argument -> FLOAT .)
    SEMICOLON       reduce using rule 17 (argument -> FLOAT .)
    DOT             reduce using rule 17 (argument -> FLOAT .)
    RIGHT_PAREN     reduce using rule 17 (argument -> FLOAT .)
    COMMA           reduce using rule 17 (argument -> FLOAT .)
    TIMES           reduce using rule 31 (factor -> FLOAT .)
    DIVIDE          reduce using rule 31 (factor -> FLOAT .)
    PLUS            reduce using rule 31 (factor -> FLOAT .)
    MINUS           reduce using rule 31 (factor -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 31 (factor -> FLOAT .) ]
  ! DOT             [ reduce using rule 31 (factor -> FLOAT .) ]
  ! RIGHT_PAREN     [ reduce using rule 31 (factor -> FLOAT .) ]
  ! COMMA           [ reduce using rule 31 (factor -> FLOAT .) ]


state 18

    (18) argument -> variable .
    (32) factor -> variable .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 18 (argument -> variable .)
  ! reduce/reduce conflict for DOT resolved using rule 18 (argument -> variable .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 18 (argument -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 18 (argument -> variable .)
    SEMICOLON       reduce using rule 18 (argument -> variable .)
    DOT             reduce using rule 18 (argument -> variable .)
    RIGHT_PAREN     reduce using rule 18 (argument -> variable .)
    COMMA           reduce using rule 18 (argument -> variable .)
    TIMES           reduce using rule 32 (factor -> variable .)
    DIVIDE          reduce using rule 32 (factor -> variable .)
    PLUS            reduce using rule 32 (factor -> variable .)
    MINUS           reduce using rule 32 (factor -> variable .)

  ! SEMICOLON       [ reduce using rule 32 (factor -> variable .) ]
  ! DOT             [ reduce using rule 32 (factor -> variable .) ]
  ! RIGHT_PAREN     [ reduce using rule 32 (factor -> variable .) ]
  ! COMMA           [ reduce using rule 32 (factor -> variable .) ]


state 19

    (19) argument -> TRUE .

    SEMICOLON       reduce using rule 19 (argument -> TRUE .)
    DOT             reduce using rule 19 (argument -> TRUE .)
    RIGHT_PAREN     reduce using rule 19 (argument -> TRUE .)
    COMMA           reduce using rule 19 (argument -> TRUE .)


state 20

    (20) argument -> FALSE .

    SEMICOLON       reduce using rule 20 (argument -> FALSE .)
    DOT             reduce using rule 20 (argument -> FALSE .)
    RIGHT_PAREN     reduce using rule 20 (argument -> FALSE .)
    COMMA           reduce using rule 20 (argument -> FALSE .)


state 21

    (21) argument -> STRING .

    SEMICOLON       reduce using rule 21 (argument -> STRING .)
    DOT             reduce using rule 21 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 21 (argument -> STRING .)
    COMMA           reduce using rule 21 (argument -> STRING .)


state 22

    (22) argument -> expression .
    (24) expression -> expression . PLUS term
    (25) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 22 (argument -> expression .)
    DOT             reduce using rule 22 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 22 (argument -> expression .)
    COMMA           reduce using rule 22 (argument -> expression .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 23

    (26) expression -> term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor

    PLUS            reduce using rule 26 (expression -> term .)
    MINUS           reduce using rule 26 (expression -> term .)
    SEMICOLON       reduce using rule 26 (expression -> term .)
    DOT             reduce using rule 26 (expression -> term .)
    RIGHT_PAREN     reduce using rule 26 (expression -> term .)
    EQUAL_TO        reduce using rule 26 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 26 (expression -> term .)
    LESS_THAN       reduce using rule 26 (expression -> term .)
    GREATER_THAN    reduce using rule 26 (expression -> term .)
    LESS_EQUAL      reduce using rule 26 (expression -> term .)
    GREATER_EQUAL   reduce using rule 26 (expression -> term .)
    IDENTICAL_TO    reduce using rule 26 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 26 (expression -> term .)
    DIFFERENT       reduce using rule 26 (expression -> term .)
    COMMA           reduce using rule 26 (expression -> term .)
    LOGICAL_AND     reduce using rule 26 (expression -> term .)
    LOGICAL_OR      reduce using rule 26 (expression -> term .)
    LOGICAL_XOR     reduce using rule 26 (expression -> term .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38


state 24

    (29) term -> factor .

    TIMES           reduce using rule 29 (term -> factor .)
    DIVIDE          reduce using rule 29 (term -> factor .)
    PLUS            reduce using rule 29 (term -> factor .)
    MINUS           reduce using rule 29 (term -> factor .)
    SEMICOLON       reduce using rule 29 (term -> factor .)
    DOT             reduce using rule 29 (term -> factor .)
    RIGHT_PAREN     reduce using rule 29 (term -> factor .)
    EQUAL_TO        reduce using rule 29 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 29 (term -> factor .)
    LESS_THAN       reduce using rule 29 (term -> factor .)
    GREATER_THAN    reduce using rule 29 (term -> factor .)
    LESS_EQUAL      reduce using rule 29 (term -> factor .)
    GREATER_EQUAL   reduce using rule 29 (term -> factor .)
    IDENTICAL_TO    reduce using rule 29 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 29 (term -> factor .)
    DIFFERENT       reduce using rule 29 (term -> factor .)
    COMMA           reduce using rule 29 (term -> factor .)
    LOGICAL_AND     reduce using rule 29 (term -> factor .)
    LOGICAL_OR      reduce using rule 29 (term -> factor .)
    LOGICAL_XOR     reduce using rule 29 (term -> factor .)


state 25

    (12) print_statement -> PRINT LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (33) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (14) arguments -> . argument
    (15) arguments -> . arguments DOT argument
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (9) variable -> . ID
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12
    LEFT_PAREN      shift and go to state 30

    arguments                      shift and go to state 39
    expression                     shift and go to state 32
    argument                       shift and go to state 15
    term                           shift and go to state 23
    variable                       shift and go to state 18
    factor                         shift and go to state 24

state 26

    (13) print_statement -> PRINT arguments . SEMICOLON
    (15) arguments -> arguments . DOT argument

    SEMICOLON       shift and go to state 40
    DOT             shift and go to state 34


state 27

    (6) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON

    STDIN           shift and go to state 41


state 28

    (23) assignment_statement -> variable EQUALS . argument SEMICOLON
    (55) array_declaration_statement -> variable EQUALS . array SEMICOLON
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (56) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (9) variable -> . ID
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ARRAY           shift and go to state 44
    ID              shift and go to state 12
    LEFT_PAREN      shift and go to state 30

    variable                       shift and go to state 18
    argument                       shift and go to state 42
    array                          shift and go to state 43
    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 29

    (34) if_statement -> IF LEFT_PAREN . condition RIGHT_PAREN block
    (35) if_statement -> IF LEFT_PAREN . condition RIGHT_PAREN block ELSE block
    (48) condition -> . TRUE
    (49) condition -> . FALSE
    (50) condition -> . expression relational_operator expression
    (51) condition -> . condition LOGICAL_AND condition
    (52) condition -> . condition LOGICAL_OR condition
    (53) condition -> . condition LOGICAL_XOR condition
    (54) condition -> . LOGICAL_NOT condition
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    LOGICAL_NOT     shift and go to state 49
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    condition                      shift and go to state 45
    expression                     shift and go to state 48
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 30

    (33) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    expression                     shift and go to state 53
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 31

    (10) print_statement -> ECHO LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON
    (15) arguments -> arguments . DOT argument

    RIGHT_PAREN     shift and go to state 54
    DOT             shift and go to state 34


state 32

    (33) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (24) expression -> expression . PLUS term
    (25) expression -> expression . MINUS term
    (22) argument -> expression .

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 55
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    DOT             reduce using rule 22 (argument -> expression .)

  ! RIGHT_PAREN     [ reduce using rule 22 (argument -> expression .) ]


state 33

    (11) print_statement -> ECHO arguments SEMICOLON .

    $end            reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)
    RIGHT_BRACE     reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)
    ECHO            reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)
    PRINT           reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)
    FSCANF          reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)
    IF              reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)
    ID              reduce using rule 11 (print_statement -> ECHO arguments SEMICOLON .)


state 34

    (15) arguments -> arguments DOT . argument
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (9) variable -> . ID
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12
    LEFT_PAREN      shift and go to state 30

    argument                       shift and go to state 56
    variable                       shift and go to state 18
    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 35

    (24) expression -> expression PLUS . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    term                           shift and go to state 57
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 36

    (25) expression -> expression MINUS . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    term                           shift and go to state 58
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 37

    (27) term -> term TIMES . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    factor                         shift and go to state 59
    variable                       shift and go to state 52

state 38

    (28) term -> term DIVIDE . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    factor                         shift and go to state 60
    variable                       shift and go to state 52

state 39

    (12) print_statement -> PRINT LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON
    (15) arguments -> arguments . DOT argument

    RIGHT_PAREN     shift and go to state 61
    DOT             shift and go to state 34


state 40

    (13) print_statement -> PRINT arguments SEMICOLON .

    $end            reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)
    RIGHT_BRACE     reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)
    ECHO            reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)
    PRINT           reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)
    FSCANF          reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)
    IF              reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)
    ID              reduce using rule 13 (print_statement -> PRINT arguments SEMICOLON .)


state 41

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON

    COMMA           shift and go to state 62


state 42

    (23) assignment_statement -> variable EQUALS argument . SEMICOLON

    SEMICOLON       shift and go to state 63


state 43

    (55) array_declaration_statement -> variable EQUALS array . SEMICOLON

    SEMICOLON       shift and go to state 64


state 44

    (56) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 65


state 45

    (34) if_statement -> IF LEFT_PAREN condition . RIGHT_PAREN block
    (35) if_statement -> IF LEFT_PAREN condition . RIGHT_PAREN block ELSE block
    (51) condition -> condition . LOGICAL_AND condition
    (52) condition -> condition . LOGICAL_OR condition
    (53) condition -> condition . LOGICAL_XOR condition

    RIGHT_PAREN     shift and go to state 66
    LOGICAL_AND     shift and go to state 67
    LOGICAL_OR      shift and go to state 68
    LOGICAL_XOR     shift and go to state 69


state 46

    (48) condition -> TRUE .

    RIGHT_PAREN     reduce using rule 48 (condition -> TRUE .)
    LOGICAL_AND     reduce using rule 48 (condition -> TRUE .)
    LOGICAL_OR      reduce using rule 48 (condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 48 (condition -> TRUE .)


state 47

    (49) condition -> FALSE .

    RIGHT_PAREN     reduce using rule 49 (condition -> FALSE .)
    LOGICAL_AND     reduce using rule 49 (condition -> FALSE .)
    LOGICAL_OR      reduce using rule 49 (condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 49 (condition -> FALSE .)


state 48

    (50) condition -> expression . relational_operator expression
    (24) expression -> expression . PLUS term
    (25) expression -> expression . MINUS term
    (39) relational_operator -> . EQUAL_TO
    (40) relational_operator -> . NOT_EQUAL_TO
    (41) relational_operator -> . LESS_THAN
    (42) relational_operator -> . GREATER_THAN
    (43) relational_operator -> . LESS_EQUAL
    (44) relational_operator -> . GREATER_EQUAL
    (45) relational_operator -> . IDENTICAL_TO
    (46) relational_operator -> . NOT_IDENTICAL_TO
    (47) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    EQUAL_TO        shift and go to state 71
    NOT_EQUAL_TO    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_THAN    shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    IDENTICAL_TO    shift and go to state 77
    NOT_IDENTICAL_TO shift and go to state 78
    DIFFERENT       shift and go to state 79

    relational_operator            shift and go to state 70

state 49

    (54) condition -> LOGICAL_NOT . condition
    (48) condition -> . TRUE
    (49) condition -> . FALSE
    (50) condition -> . expression relational_operator expression
    (51) condition -> . condition LOGICAL_AND condition
    (52) condition -> . condition LOGICAL_OR condition
    (53) condition -> . condition LOGICAL_XOR condition
    (54) condition -> . LOGICAL_NOT condition
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    LOGICAL_NOT     shift and go to state 49
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    condition                      shift and go to state 80
    expression                     shift and go to state 48
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 50

    (30) factor -> INTEGER .

    TIMES           reduce using rule 30 (factor -> INTEGER .)
    DIVIDE          reduce using rule 30 (factor -> INTEGER .)
    PLUS            reduce using rule 30 (factor -> INTEGER .)
    MINUS           reduce using rule 30 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 30 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 30 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 30 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 30 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 30 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 30 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 30 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 30 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 30 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 30 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 30 (factor -> INTEGER .)
    DOT             reduce using rule 30 (factor -> INTEGER .)
    COMMA           reduce using rule 30 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 30 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 30 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 30 (factor -> INTEGER .)


state 51

    (31) factor -> FLOAT .

    TIMES           reduce using rule 31 (factor -> FLOAT .)
    DIVIDE          reduce using rule 31 (factor -> FLOAT .)
    PLUS            reduce using rule 31 (factor -> FLOAT .)
    MINUS           reduce using rule 31 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 31 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 31 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 31 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 31 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 31 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 31 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 31 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 31 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 31 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 31 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 31 (factor -> FLOAT .)
    DOT             reduce using rule 31 (factor -> FLOAT .)
    COMMA           reduce using rule 31 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 31 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 31 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 31 (factor -> FLOAT .)


state 52

    (32) factor -> variable .

    TIMES           reduce using rule 32 (factor -> variable .)
    DIVIDE          reduce using rule 32 (factor -> variable .)
    PLUS            reduce using rule 32 (factor -> variable .)
    MINUS           reduce using rule 32 (factor -> variable .)
    EQUAL_TO        reduce using rule 32 (factor -> variable .)
    NOT_EQUAL_TO    reduce using rule 32 (factor -> variable .)
    LESS_THAN       reduce using rule 32 (factor -> variable .)
    GREATER_THAN    reduce using rule 32 (factor -> variable .)
    LESS_EQUAL      reduce using rule 32 (factor -> variable .)
    GREATER_EQUAL   reduce using rule 32 (factor -> variable .)
    IDENTICAL_TO    reduce using rule 32 (factor -> variable .)
    NOT_IDENTICAL_TO reduce using rule 32 (factor -> variable .)
    DIFFERENT       reduce using rule 32 (factor -> variable .)
    RIGHT_PAREN     reduce using rule 32 (factor -> variable .)
    SEMICOLON       reduce using rule 32 (factor -> variable .)
    DOT             reduce using rule 32 (factor -> variable .)
    COMMA           reduce using rule 32 (factor -> variable .)
    LOGICAL_AND     reduce using rule 32 (factor -> variable .)
    LOGICAL_OR      reduce using rule 32 (factor -> variable .)
    LOGICAL_XOR     reduce using rule 32 (factor -> variable .)


state 53

    (33) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (24) expression -> expression . PLUS term
    (25) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 55
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 54

    (10) print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 81


state 55

    (33) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 33 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 56

    (15) arguments -> arguments DOT argument .

    SEMICOLON       reduce using rule 15 (arguments -> arguments DOT argument .)
    DOT             reduce using rule 15 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 15 (arguments -> arguments DOT argument .)


state 57

    (24) expression -> expression PLUS term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor

    PLUS            reduce using rule 24 (expression -> expression PLUS term .)
    MINUS           reduce using rule 24 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 24 (expression -> expression PLUS term .)
    DOT             reduce using rule 24 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 24 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 24 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 24 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 24 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 24 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 24 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 24 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 24 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 24 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 24 (expression -> expression PLUS term .)
    COMMA           reduce using rule 24 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 24 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 24 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 24 (expression -> expression PLUS term .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38


state 58

    (25) expression -> expression MINUS term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor

    PLUS            reduce using rule 25 (expression -> expression MINUS term .)
    MINUS           reduce using rule 25 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 25 (expression -> expression MINUS term .)
    DOT             reduce using rule 25 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 25 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 25 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 25 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 25 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 25 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 25 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 25 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 25 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 25 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 25 (expression -> expression MINUS term .)
    COMMA           reduce using rule 25 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 25 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 25 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 25 (expression -> expression MINUS term .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38


state 59

    (27) term -> term TIMES factor .

    TIMES           reduce using rule 27 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 27 (term -> term TIMES factor .)
    PLUS            reduce using rule 27 (term -> term TIMES factor .)
    MINUS           reduce using rule 27 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 27 (term -> term TIMES factor .)
    DOT             reduce using rule 27 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 27 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 27 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 27 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 27 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 27 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 27 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 27 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 27 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 27 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 27 (term -> term TIMES factor .)
    COMMA           reduce using rule 27 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 27 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 27 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 27 (term -> term TIMES factor .)


state 60

    (28) term -> term DIVIDE factor .

    TIMES           reduce using rule 28 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 28 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 28 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 28 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 28 (term -> term DIVIDE factor .)
    DOT             reduce using rule 28 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 28 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 28 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 28 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 28 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 28 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 28 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 28 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 28 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 28 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 28 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 28 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 28 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 28 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 28 (term -> term DIVIDE factor .)


state 61

    (12) print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 82


state 62

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN SEMICOLON

    STRING          shift and go to state 83


state 63

    (23) assignment_statement -> variable EQUALS argument SEMICOLON .

    $end            reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)
    RIGHT_BRACE     reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)
    ECHO            reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)
    PRINT           reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)
    FSCANF          reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)
    IF              reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)
    ID              reduce using rule 23 (assignment_statement -> variable EQUALS argument SEMICOLON .)


state 64

    (55) array_declaration_statement -> variable EQUALS array SEMICOLON .

    $end            reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)
    RIGHT_BRACE     reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)
    ECHO            reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)
    PRINT           reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)
    FSCANF          reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)
    IF              reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)
    ID              reduce using rule 55 (array_declaration_statement -> variable EQUALS array SEMICOLON .)


state 65

    (56) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (57) array_elements -> . argument
    (58) array_elements -> . array_elements COMMA argument
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (9) variable -> . ID
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12
    LEFT_PAREN      shift and go to state 30

    array_elements                 shift and go to state 84
    argument                       shift and go to state 85
    variable                       shift and go to state 18
    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 66

    (34) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN . block
    (35) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN . block ELSE block
    (36) block -> . LEFT_BRACE statements RIGHT_BRACE

    LEFT_BRACE      shift and go to state 87

    block                          shift and go to state 86

state 67

    (51) condition -> condition LOGICAL_AND . condition
    (48) condition -> . TRUE
    (49) condition -> . FALSE
    (50) condition -> . expression relational_operator expression
    (51) condition -> . condition LOGICAL_AND condition
    (52) condition -> . condition LOGICAL_OR condition
    (53) condition -> . condition LOGICAL_XOR condition
    (54) condition -> . LOGICAL_NOT condition
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    LOGICAL_NOT     shift and go to state 49
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    condition                      shift and go to state 88
    expression                     shift and go to state 48
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 68

    (52) condition -> condition LOGICAL_OR . condition
    (48) condition -> . TRUE
    (49) condition -> . FALSE
    (50) condition -> . expression relational_operator expression
    (51) condition -> . condition LOGICAL_AND condition
    (52) condition -> . condition LOGICAL_OR condition
    (53) condition -> . condition LOGICAL_XOR condition
    (54) condition -> . LOGICAL_NOT condition
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    LOGICAL_NOT     shift and go to state 49
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    condition                      shift and go to state 89
    expression                     shift and go to state 48
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 69

    (53) condition -> condition LOGICAL_XOR . condition
    (48) condition -> . TRUE
    (49) condition -> . FALSE
    (50) condition -> . expression relational_operator expression
    (51) condition -> . condition LOGICAL_AND condition
    (52) condition -> . condition LOGICAL_OR condition
    (53) condition -> . condition LOGICAL_XOR condition
    (54) condition -> . LOGICAL_NOT condition
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    LOGICAL_NOT     shift and go to state 49
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    condition                      shift and go to state 90
    expression                     shift and go to state 48
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 70

    (50) condition -> expression relational_operator . expression
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (9) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    LEFT_PAREN      shift and go to state 30
    ID              shift and go to state 12

    expression                     shift and go to state 91
    term                           shift and go to state 23
    factor                         shift and go to state 24
    variable                       shift and go to state 52

state 71

    (39) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 39 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 39 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 39 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 39 (relational_operator -> EQUAL_TO .)


state 72

    (40) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 40 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 40 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 40 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 40 (relational_operator -> NOT_EQUAL_TO .)


state 73

    (41) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 41 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 41 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 41 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 41 (relational_operator -> LESS_THAN .)


state 74

    (42) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 42 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 42 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 42 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 42 (relational_operator -> GREATER_THAN .)


state 75

    (43) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 43 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 43 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 43 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 43 (relational_operator -> LESS_EQUAL .)


state 76

    (44) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 44 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 44 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 44 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 44 (relational_operator -> GREATER_EQUAL .)


state 77

    (45) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 45 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 45 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 45 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 45 (relational_operator -> IDENTICAL_TO .)


state 78

    (46) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 46 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 46 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 46 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 46 (relational_operator -> NOT_IDENTICAL_TO .)


state 79

    (47) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 47 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 47 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 47 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 47 (relational_operator -> DIFFERENT .)


state 80

    (54) condition -> LOGICAL_NOT condition .
    (51) condition -> condition . LOGICAL_AND condition
    (52) condition -> condition . LOGICAL_OR condition
    (53) condition -> condition . LOGICAL_XOR condition

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    RIGHT_PAREN     reduce using rule 54 (condition -> LOGICAL_NOT condition .)
    LOGICAL_AND     shift and go to state 67
    LOGICAL_OR      shift and go to state 68
    LOGICAL_XOR     shift and go to state 69

  ! LOGICAL_AND     [ reduce using rule 54 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 54 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 54 (condition -> LOGICAL_NOT condition .) ]


state 81

    (10) print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    $end            reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    ECHO            reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PRINT           reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FSCANF          reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    ID              reduce using rule 10 (print_statement -> ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 82

    (12) print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    $end            reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    ECHO            reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PRINT           reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FSCANF          reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    ID              reduce using rule 12 (print_statement -> PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 83

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN SEMICOLON

    COMMA           shift and go to state 92


state 84

    (56) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (58) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 93
    COMMA           shift and go to state 94


state 85

    (57) array_elements -> argument .

    RIGHT_PAREN     reduce using rule 57 (array_elements -> argument .)
    COMMA           reduce using rule 57 (array_elements -> argument .)


state 86

    (34) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .
    (35) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block . ELSE block

    $end            reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ECHO            reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    PRINT           reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FSCANF          reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    IF              reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ID              reduce using rule 34 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ELSE            shift and go to state 95


state 87

    (36) block -> LEFT_BRACE . statements RIGHT_BRACE
    (37) statements -> . statement
    (38) statements -> . statements statement
    (1) statement -> . print_statement
    (2) statement -> . fscanf_statement
    (3) statement -> . assignment_statement
    (4) statement -> . if_statement
    (5) statement -> . array_declaration_statement
    (10) print_statement -> . ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) print_statement -> . ECHO arguments SEMICOLON
    (12) print_statement -> . PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (13) print_statement -> . PRINT arguments SEMICOLON
    (6) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON
    (23) assignment_statement -> . variable EQUALS argument SEMICOLON
    (34) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (35) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (55) array_declaration_statement -> . variable EQUALS array SEMICOLON
    (9) variable -> . ID

    ECHO            shift and go to state 7
    PRINT           shift and go to state 8
    FSCANF          shift and go to state 9
    IF              shift and go to state 11
    ID              shift and go to state 12

    statements                     shift and go to state 96
    statement                      shift and go to state 97
    print_statement                shift and go to state 2
    fscanf_statement               shift and go to state 3
    assignment_statement           shift and go to state 4
    if_statement                   shift and go to state 5
    array_declaration_statement    shift and go to state 6
    variable                       shift and go to state 10

state 88

    (51) condition -> condition LOGICAL_AND condition .
    (51) condition -> condition . LOGICAL_AND condition
    (52) condition -> condition . LOGICAL_OR condition
    (53) condition -> condition . LOGICAL_XOR condition

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    RIGHT_PAREN     reduce using rule 51 (condition -> condition LOGICAL_AND condition .)
    LOGICAL_AND     shift and go to state 67
    LOGICAL_OR      shift and go to state 68
    LOGICAL_XOR     shift and go to state 69

  ! LOGICAL_AND     [ reduce using rule 51 (condition -> condition LOGICAL_AND condition .) ]
  ! LOGICAL_OR      [ reduce using rule 51 (condition -> condition LOGICAL_AND condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 51 (condition -> condition LOGICAL_AND condition .) ]


state 89

    (52) condition -> condition LOGICAL_OR condition .
    (51) condition -> condition . LOGICAL_AND condition
    (52) condition -> condition . LOGICAL_OR condition
    (53) condition -> condition . LOGICAL_XOR condition

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    RIGHT_PAREN     reduce using rule 52 (condition -> condition LOGICAL_OR condition .)
    LOGICAL_AND     shift and go to state 67
    LOGICAL_OR      shift and go to state 68
    LOGICAL_XOR     shift and go to state 69

  ! LOGICAL_AND     [ reduce using rule 52 (condition -> condition LOGICAL_OR condition .) ]
  ! LOGICAL_OR      [ reduce using rule 52 (condition -> condition LOGICAL_OR condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 52 (condition -> condition LOGICAL_OR condition .) ]


state 90

    (53) condition -> condition LOGICAL_XOR condition .
    (51) condition -> condition . LOGICAL_AND condition
    (52) condition -> condition . LOGICAL_OR condition
    (53) condition -> condition . LOGICAL_XOR condition

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    RIGHT_PAREN     reduce using rule 53 (condition -> condition LOGICAL_XOR condition .)
    LOGICAL_AND     shift and go to state 67
    LOGICAL_OR      shift and go to state 68
    LOGICAL_XOR     shift and go to state 69

  ! LOGICAL_AND     [ reduce using rule 53 (condition -> condition LOGICAL_XOR condition .) ]
  ! LOGICAL_OR      [ reduce using rule 53 (condition -> condition LOGICAL_XOR condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 53 (condition -> condition LOGICAL_XOR condition .) ]


state 91

    (50) condition -> expression relational_operator expression .
    (24) expression -> expression . PLUS term
    (25) expression -> expression . MINUS term

    RIGHT_PAREN     reduce using rule 50 (condition -> expression relational_operator expression .)
    LOGICAL_AND     reduce using rule 50 (condition -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 50 (condition -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 50 (condition -> expression relational_operator expression .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 92

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN SEMICOLON
    (7) variable_list -> . variable
    (8) variable_list -> . variable_list COMMA variable
    (9) variable -> . ID

    ID              shift and go to state 12

    variable_list                  shift and go to state 98
    variable                       shift and go to state 99

state 93

    (56) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 56 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 94

    (58) array_elements -> array_elements COMMA . argument
    (16) argument -> . INTEGER
    (17) argument -> . FLOAT
    (18) argument -> . variable
    (19) argument -> . TRUE
    (20) argument -> . FALSE
    (21) argument -> . STRING
    (22) argument -> . expression
    (9) variable -> . ID
    (24) expression -> . expression PLUS term
    (25) expression -> . expression MINUS term
    (26) expression -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . INTEGER
    (31) factor -> . FLOAT
    (32) factor -> . variable
    (33) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 19
    FALSE           shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 12
    LEFT_PAREN      shift and go to state 30

    argument                       shift and go to state 100
    variable                       shift and go to state 18
    expression                     shift and go to state 22
    term                           shift and go to state 23
    factor                         shift and go to state 24

state 95

    (35) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE . block
    (36) block -> . LEFT_BRACE statements RIGHT_BRACE

    LEFT_BRACE      shift and go to state 87

    block                          shift and go to state 101

state 96

    (36) block -> LEFT_BRACE statements . RIGHT_BRACE
    (38) statements -> statements . statement
    (1) statement -> . print_statement
    (2) statement -> . fscanf_statement
    (3) statement -> . assignment_statement
    (4) statement -> . if_statement
    (5) statement -> . array_declaration_statement
    (10) print_statement -> . ECHO LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) print_statement -> . ECHO arguments SEMICOLON
    (12) print_statement -> . PRINT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (13) print_statement -> . PRINT arguments SEMICOLON
    (6) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON
    (23) assignment_statement -> . variable EQUALS argument SEMICOLON
    (34) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (35) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (55) array_declaration_statement -> . variable EQUALS array SEMICOLON
    (9) variable -> . ID

    RIGHT_BRACE     shift and go to state 102
    ECHO            shift and go to state 7
    PRINT           shift and go to state 8
    FSCANF          shift and go to state 9
    IF              shift and go to state 11
    ID              shift and go to state 12

    statement                      shift and go to state 103
    print_statement                shift and go to state 2
    fscanf_statement               shift and go to state 3
    assignment_statement           shift and go to state 4
    if_statement                   shift and go to state 5
    array_declaration_statement    shift and go to state 6
    variable                       shift and go to state 10

state 97

    (37) statements -> statement .

    RIGHT_BRACE     reduce using rule 37 (statements -> statement .)
    ECHO            reduce using rule 37 (statements -> statement .)
    PRINT           reduce using rule 37 (statements -> statement .)
    FSCANF          reduce using rule 37 (statements -> statement .)
    IF              reduce using rule 37 (statements -> statement .)
    ID              reduce using rule 37 (statements -> statement .)


state 98

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN SEMICOLON
    (8) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 105
    COMMA           shift and go to state 104


state 99

    (7) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 7 (variable_list -> variable .)
    COMMA           reduce using rule 7 (variable_list -> variable .)


state 100

    (58) array_elements -> array_elements COMMA argument .

    RIGHT_PAREN     reduce using rule 58 (array_elements -> array_elements COMMA argument .)
    COMMA           reduce using rule 58 (array_elements -> array_elements COMMA argument .)


state 101

    (35) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .

    $end            reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    RIGHT_BRACE     reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ECHO            reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    PRINT           reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FSCANF          reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    IF              reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ID              reduce using rule 35 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)


state 102

    (36) block -> LEFT_BRACE statements RIGHT_BRACE .

    ELSE            reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    $end            reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 36 (block -> LEFT_BRACE statements RIGHT_BRACE .)


state 103

    (38) statements -> statements statement .

    RIGHT_BRACE     reduce using rule 38 (statements -> statements statement .)
    ECHO            reduce using rule 38 (statements -> statements statement .)
    PRINT           reduce using rule 38 (statements -> statements statement .)
    FSCANF          reduce using rule 38 (statements -> statements statement .)
    IF              reduce using rule 38 (statements -> statements statement .)
    ID              reduce using rule 38 (statements -> statements statement .)


state 104

    (8) variable_list -> variable_list COMMA . variable
    (9) variable -> . ID

    ID              shift and go to state 12

    variable                       shift and go to state 106

state 105

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 107


state 106

    (8) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 8 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 8 (variable_list -> variable_list COMMA variable .)


state 107

    (6) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .

    $end            reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)
    ECHO            reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)
    PRINT           reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)
    FSCANF          reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)
    ID              reduce using rule 6 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RIGHT_PAREN in state 32 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 80 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 80 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 80 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 89 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 89 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 89 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 90 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 90 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 90 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (argument -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 16
WARNING: reduce/reduce conflict in state 17 resolved using rule (argument -> FLOAT)
WARNING: rejected rule (factor -> FLOAT) in state 17
WARNING: reduce/reduce conflict in state 18 resolved using rule (argument -> variable)
WARNING: rejected rule (factor -> variable) in state 18
