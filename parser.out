Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASYNC
    AWAIT
    BOOL
    CALLABLE
    CASE
    CATCH
    CLONE
    COLON
    CONST
    DECLARE
    DEFAULT
    DIE
    DO
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FINAL
    FINALLY
    FN
    FOREACH
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    LIST
    LPAREN
    MATCH
    MIXED
    NAMESPACE
    NULL
    OBJECT
    REQUIRE
    REQUIRE_ONCE
    RPAREN
    SELF
    STATIC
    SWITCH
    THROW
    TRAIT
    TRY
    USE
    VAR
    VOID
    YIELD
    YIELD_FROM

Grammar

Rule 0     S' -> program
Rule 1     program -> OPEN_TAG statements CLOSE_TAG
Rule 2     statements -> statement2
Rule 3     statements -> statements statement2
Rule 4     statement2 -> statement SEMICOLON
Rule 5     statement2 -> if_statement
Rule 6     statement2 -> while_statement
Rule 7     statement2 -> for_statement
Rule 8     statement2 -> function_statement
Rule 9     statement2 -> ONE_LINE_COMMENT
Rule 10    statement2 -> MULTI_LINE_COMMENT
Rule 11    statement2 -> class_declaration
Rule 12    statement -> print_statement
Rule 13    statement -> fscanf_statement
Rule 14    statement -> fgets_statement
Rule 15    statement -> assignment_statement
Rule 16    statement -> array_declaration_statement
Rule 17    statement -> BREAK
Rule 18    statement -> CONTINUE
Rule 19    statement -> function_call
Rule 20    statement -> return_statement
Rule 21    statement -> array_indexing
Rule 22    statement -> array_add_element
Rule 23    statement -> array_modify_element
Rule 24    statement -> array_remove_element
Rule 25    statement -> array_count_elements
Rule 26    statement -> expression
Rule 27    function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block
Rule 28    function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
Rule 29    anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
Rule 30    anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block
Rule 31    parameters -> parameter
Rule 32    parameters -> parameters COMMA parameter
Rule 33    parameter -> variable
Rule 34    parameter -> variable EQUALS argument
Rule 35    return_statement -> RETURN arguments
Rule 36    function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN
Rule 37    function_call -> NAME LEFT_PAREN RIGHT_PAREN
Rule 38    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 39    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 40    variable_list -> variable
Rule 41    variable_list -> variable_list COMMA variable
Rule 42    variable -> ID
Rule 43    variable -> ID CALL NAME
Rule 44    assignment_statement -> variable assignment_operator argument
Rule 45    assignment_statement -> variable PLUS_PLUS
Rule 46    assignment_statement -> variable MINUS_MINUS
Rule 47    assignment_operator -> EQUALS
Rule 48    assignment_operator -> PLUS_EQUALS
Rule 49    assignment_operator -> MINUS_EQUALS
Rule 50    assignment_operator -> TIMES_EQUALS
Rule 51    assignment_operator -> DIVIDE_EQUALS
Rule 52    assignment_operator -> MOD_EQUALS
Rule 53    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 54    print_statement -> print_function arguments
Rule 55    print_function -> PRINT
Rule 56    print_function -> ECHO
Rule 57    arguments -> argument
Rule 58    arguments -> arguments DOT argument
Rule 59    arguments -> arguments COMMA argument
Rule 60    argument -> STRING
Rule 61    argument -> expression
Rule 62    argument -> array
Rule 63    argument -> array_indexing
Rule 64    argument -> function_call
Rule 65    argument -> ID CALL function_call
Rule 66    argument -> anonymous_function
Rule 67    argument -> assignment_statement
Rule 68    argument -> fgets_statement
Rule 69    argument -> object_creation
Rule 70    argument -> casting argument
Rule 71    expression -> expression PLUS term
Rule 72    expression -> expression MINUS term
Rule 73    expression -> term
Rule 74    term -> term TIMES factor
Rule 75    term -> term DIVIDE factor
Rule 76    term -> term MOD factor
Rule 77    term -> term POWER factor
Rule 78    term -> factor
Rule 79    factor -> INTEGER
Rule 80    factor -> FLOAT
Rule 81    factor -> condition
Rule 82    factor -> STRING
Rule 83    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 84    if_statement -> IF parenthesized_condition block
Rule 85    if_statement -> IF parenthesized_condition block else_if_extended
Rule 86    if_statement -> IF parenthesized_condition block else_if_extended if_part3
Rule 87    if_statement -> IF parenthesized_condition block if_part3
Rule 88    else_if_extended -> if_part2
Rule 89    else_if_extended -> else_if_extended if_part2
Rule 90    if_part2 -> ELSEIF parenthesized_condition block
Rule 91    if_part3 -> ELSE block
Rule 92    while_statement -> WHILE parenthesized_condition block
Rule 93    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 94    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 95    for_statement -> for_part1 condition for_part3
Rule 96    for_statement -> for_part1 for_part3
Rule 97    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 98    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 99    for_part4 -> block
Rule 100   for_part4 -> SEMICOLON
Rule 101   assignment_list -> assignment_statement
Rule 102   assignment_list -> assignment_list COMMA assignment_statement
Rule 103   statement_list -> statement
Rule 104   statement_list -> statement_list COMMA statement
Rule 105   block -> LEFT_BRACE statements RIGHT_BRACE
Rule 106   block -> LEFT_BRACE RIGHT_BRACE
Rule 107   condition -> simple_condition
Rule 108   condition -> negated_condition
Rule 109   condition -> complex_condition
Rule 110   condition -> parenthesized_condition
Rule 111   simple_condition -> TRUE
Rule 112   simple_condition -> FALSE
Rule 113   simple_condition -> variable
Rule 114   simple_condition -> relational_expression
Rule 115   negated_condition -> LOGICAL_NOT condition
Rule 116   complex_condition -> condition logical_operator condition
Rule 117   parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 118   relational_expression -> expression relational_operator expression
Rule 119   relational_operator -> EQUAL_TO
Rule 120   relational_operator -> NOT_EQUAL_TO
Rule 121   relational_operator -> LESS_THAN
Rule 122   relational_operator -> GREATER_THAN
Rule 123   relational_operator -> LESS_EQUAL
Rule 124   relational_operator -> GREATER_EQUAL
Rule 125   relational_operator -> IDENTICAL_TO
Rule 126   relational_operator -> NOT_IDENTICAL_TO
Rule 127   relational_operator -> DIFFERENT
Rule 128   logical_operator -> LOGICAL_AND
Rule 129   logical_operator -> LOGICAL_OR
Rule 130   logical_operator -> LOGICAL_XOR
Rule 131   casting -> LEFT_PAREN casting_type RIGHT_PAREN
Rule 132   casting_type -> INT_TYPE
Rule 133   casting_type -> FLOAT_TYPE
Rule 134   array_declaration_statement -> variable EQUALS array
Rule 135   array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 136   array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 137   array_elements -> array_argument
Rule 138   array_elements -> array_elements COMMA array_argument
Rule 139   array_argument -> argument
Rule 140   array_argument -> clave KEY_VALUE argument
Rule 141   clave -> STRING
Rule 142   clave -> INTEGER
Rule 143   array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET
Rule 144   array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
Rule 145   array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
Rule 146   array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
Rule 147   array_count_elements -> COUNT LEFT_PAREN variable RIGHT_PAREN
Rule 148   class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
Rule 149   class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE
Rule 150   class_statements -> class_statement
Rule 151   class_statements -> class_statements class_statement
Rule 152   class_statement -> method_declaration
Rule 153   class_statement -> property_declaration
Rule 154   class_statement -> ONE_LINE_COMMENT
Rule 155   class_statement -> MULTI_LINE_COMMENT
Rule 156   method_declaration -> visibility_operator function_statement
Rule 157   property_declaration -> visibility_operator variable SEMICOLON
Rule 158   visibility_operator -> PUBLIC
Rule 159   visibility_operator -> PRIVATE
Rule 160   visibility_operator -> PROTECTED
Rule 161   object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN
Rule 162   object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN

Terminals, with rules where they appear

ABSTRACT             : 
ARRAY                : 135
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 17
CALL                 : 43 65
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 148 149
CLONE                : 
CLOSE_TAG            : 1
COLON                : 
COMMA                : 32 39 39 41 59 102 104 138
CONST                : 
CONTINUE             : 18
COUNT                : 147
DECLARE              : 
DEFAULT              : 
DIE                  : 
DIFFERENT            : 127
DIVIDE               : 75
DIVIDE_EQUALS        : 51
DO                   : 
DOT                  : 58
ECHO                 : 56
ELSE                 : 91
ELSEIF               : 90
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENUM                 : 
EQUALS               : 34 47 134 144 145
EQUAL_TO             : 119
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 112
FGETS                : 38
FINAL                : 
FINALLY              : 
FLOAT                : 80
FLOAT_TYPE           : 133
FN                   : 
FOR                  : 93 94
FOREACH              : 
FSCANF               : 39
FUNCTION             : 27 28 29 30
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 124
GREATER_THAN         : 122
HALT_COMPILER        : 
ID                   : 42 43 65
IDENTICAL_TO         : 125
IF                   : 84 85 86 87
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 79 142
INTERFACE            : 
INT_TYPE             : 132
ISSET                : 
ITERABLE             : 
KEY_VALUE            : 140
LEFT_BRACE           : 105 106 148 149
LEFT_BRACKET         : 136 143 144 145 146
LEFT_PAREN           : 27 28 29 30 36 37 38 39 53 83 93 94 117 131 135 146 147 161 162
LESS_EQUAL           : 123
LESS_THAN            : 121
LIST                 : 
LOGICAL_AND          : 128
LOGICAL_NOT          : 115
LOGICAL_OR           : 129
LOGICAL_XOR          : 130
LPAREN               : 
MATCH                : 
MINUS                : 72
MINUS_EQUALS         : 49
MINUS_MINUS          : 46
MIXED                : 
MOD                  : 76
MOD_EQUALS           : 52
MULTI_LINE_COMMENT   : 10 155
NAME                 : 27 28 36 37 43 148 149 161 162
NAMESPACE            : 
NEW                  : 161 162
NOT_EQUAL_TO         : 120
NOT_IDENTICAL_TO     : 126
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 9 154
OPEN_TAG             : 1
PLUS                 : 71
PLUS_EQUALS          : 48
PLUS_PLUS            : 45
POWER                : 77
PRINT                : 55
PRIVATE              : 159
PROTECTED            : 160
PUBLIC               : 158
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 35
RIGHT_BRACE          : 105 106 148 149
RIGHT_BRACKET        : 136 143 144 145 146
RIGHT_PAREN          : 27 28 29 30 36 37 38 39 53 83 97 98 117 131 135 146 147 161 162
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 93 94 97 98 100 157
STATIC               : 
STDIN                : 38 39
STRING               : 39 60 82 141
SWITCH               : 
THROW                : 
TIMES                : 74
TIMES_EQUALS         : 50
TRAIT                : 
TRUE                 : 111
TRY                  : 
UNSET                : 146
USE                  : 
VAR                  : 
VOID                 : 
WHILE                : 92
YIELD                : 
YIELD_FROM           : 
error                : 

Nonterminals, with rules where they appear

anonymous_function   : 66
argument             : 34 44 57 58 59 70 139 140 144 145
arguments            : 35 36 53 54 58 59 162
array                : 62 134
array_add_element    : 22
array_argument       : 137 138
array_count_elements : 25
array_declaration_statement : 16
array_elements       : 135 136 138
array_indexing       : 21 63
array_modify_element : 23
array_remove_element : 24
assignment_list      : 93 102
assignment_operator  : 44
assignment_statement : 15 67 101 102
block                : 27 28 29 30 84 85 86 87 90 91 92 99
casting              : 70
casting_type         : 131
class_declaration    : 11
class_statement      : 150 151
class_statements     : 148 151
clave                : 140 143 145 146
complex_condition    : 109
condition            : 81 95 115 116 116 117
else_if_extended     : 85 86 89
expression           : 26 61 71 72 83 118 118
factor               : 74 75 76 77 78
fgets_statement      : 14 68
for_part1            : 95 96
for_part3            : 95 96
for_part4            : 97 98
for_statement        : 7
fscanf_statement     : 13
function_call        : 19 64 65
function_statement   : 8 156
if_part2             : 88 89
if_part3             : 86 87
if_statement         : 5
logical_operator     : 116
method_declaration   : 152
negated_condition    : 108
object_creation      : 69
parameter            : 31 32
parameters           : 27 29 32
parenthesized_condition : 84 85 86 87 90 92 110
print_function       : 53 54
print_statement      : 12
program              : 0
property_declaration : 153
relational_expression : 114
relational_operator  : 118
return_statement     : 20
simple_condition     : 107
statement            : 4 103 104
statement2           : 2 3
statement_list       : 97 104
statements           : 1 3 105
term                 : 71 72 73 74 75 76 77
variable             : 33 34 40 41 44 45 46 113 134 143 144 145 146 147 157
variable_list        : 39 41
visibility_operator  : 156 157
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . OPEN_TAG statements CLOSE_TAG

    OPEN_TAG        shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> OPEN_TAG . statements CLOSE_TAG
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . array_indexing
    (22) statement -> . array_add_element
    (23) statement -> . array_modify_element
    (24) statement -> . array_remove_element
    (25) statement -> . array_count_elements
    (26) statement -> . expression
    (84) if_statement -> . IF parenthesized_condition block
    (85) if_statement -> . IF parenthesized_condition block else_if_extended
    (86) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (87) if_statement -> . IF parenthesized_condition block if_part3
    (92) while_statement -> . WHILE parenthesized_condition block
    (95) for_statement -> . for_part1 condition for_part3
    (96) for_statement -> . for_part1 for_part3
    (27) function_statement -> . FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (148) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (149) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (53) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> . print_function arguments
    (39) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (134) array_declaration_statement -> . variable EQUALS array
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (35) return_statement -> . RETURN arguments
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> . variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> . variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (146) array_remove_element -> . UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (147) array_count_elements -> . COUNT LEFT_PAREN variable RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (93) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (94) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (55) print_function -> . PRINT
    (56) print_function -> . ECHO
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 28
    WHILE           shift and go to state 30
    FUNCTION        shift and go to state 33
    CLASS           shift and go to state 36
    FSCANF          shift and go to state 38
    FGETS           shift and go to state 40
    NAME            shift and go to state 34
    RETURN          shift and go to state 42
    UNSET           shift and go to state 43
    COUNT           shift and go to state 44
    FOR             shift and go to state 46
    PRINT           shift and go to state 47
    ECHO            shift and go to state 48
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    statements                     shift and go to state 3
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    array_indexing                 shift and go to state 22
    array_add_element              shift and go to state 23
    array_modify_element           shift and go to state 24
    array_remove_element           shift and go to state 25
    array_count_elements           shift and go to state 26
    expression                     shift and go to state 27
    parenthesized_condition        shift and go to state 29
    for_part1                      shift and go to state 31
    condition                      shift and go to state 32
    print_function                 shift and go to state 37
    variable                       shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 50
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    relational_expression          shift and go to state 58

state 3

    (1) program -> OPEN_TAG statements . CLOSE_TAG
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . array_indexing
    (22) statement -> . array_add_element
    (23) statement -> . array_modify_element
    (24) statement -> . array_remove_element
    (25) statement -> . array_count_elements
    (26) statement -> . expression
    (84) if_statement -> . IF parenthesized_condition block
    (85) if_statement -> . IF parenthesized_condition block else_if_extended
    (86) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (87) if_statement -> . IF parenthesized_condition block if_part3
    (92) while_statement -> . WHILE parenthesized_condition block
    (95) for_statement -> . for_part1 condition for_part3
    (96) for_statement -> . for_part1 for_part3
    (27) function_statement -> . FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (148) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (149) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (53) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> . print_function arguments
    (39) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (134) array_declaration_statement -> . variable EQUALS array
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (35) return_statement -> . RETURN arguments
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> . variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> . variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (146) array_remove_element -> . UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (147) array_count_elements -> . COUNT LEFT_PAREN variable RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (93) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (94) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (55) print_function -> . PRINT
    (56) print_function -> . ECHO
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    CLOSE_TAG       shift and go to state 60
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 28
    WHILE           shift and go to state 30
    FUNCTION        shift and go to state 33
    CLASS           shift and go to state 36
    FSCANF          shift and go to state 38
    FGETS           shift and go to state 40
    NAME            shift and go to state 34
    RETURN          shift and go to state 42
    UNSET           shift and go to state 43
    COUNT           shift and go to state 44
    FOR             shift and go to state 46
    PRINT           shift and go to state 47
    ECHO            shift and go to state 48
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    statement2                     shift and go to state 61
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    array_indexing                 shift and go to state 22
    array_add_element              shift and go to state 23
    array_modify_element           shift and go to state 24
    array_remove_element           shift and go to state 25
    array_count_elements           shift and go to state 26
    expression                     shift and go to state 27
    parenthesized_condition        shift and go to state 29
    for_part1                      shift and go to state 31
    condition                      shift and go to state 32
    print_function                 shift and go to state 37
    variable                       shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 50
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    relational_expression          shift and go to state 58

state 4

    (2) statements -> statement2 .

    CLOSE_TAG       reduce using rule 2 (statements -> statement2 .)
    ONE_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    MULTI_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    BREAK           reduce using rule 2 (statements -> statement2 .)
    CONTINUE        reduce using rule 2 (statements -> statement2 .)
    IF              reduce using rule 2 (statements -> statement2 .)
    WHILE           reduce using rule 2 (statements -> statement2 .)
    FUNCTION        reduce using rule 2 (statements -> statement2 .)
    CLASS           reduce using rule 2 (statements -> statement2 .)
    FSCANF          reduce using rule 2 (statements -> statement2 .)
    FGETS           reduce using rule 2 (statements -> statement2 .)
    NAME            reduce using rule 2 (statements -> statement2 .)
    RETURN          reduce using rule 2 (statements -> statement2 .)
    UNSET           reduce using rule 2 (statements -> statement2 .)
    COUNT           reduce using rule 2 (statements -> statement2 .)
    FOR             reduce using rule 2 (statements -> statement2 .)
    PRINT           reduce using rule 2 (statements -> statement2 .)
    ECHO            reduce using rule 2 (statements -> statement2 .)
    ID              reduce using rule 2 (statements -> statement2 .)
    INTEGER         reduce using rule 2 (statements -> statement2 .)
    FLOAT           reduce using rule 2 (statements -> statement2 .)
    STRING          reduce using rule 2 (statements -> statement2 .)
    LEFT_PAREN      reduce using rule 2 (statements -> statement2 .)
    TRUE            reduce using rule 2 (statements -> statement2 .)
    FALSE           reduce using rule 2 (statements -> statement2 .)
    LOGICAL_NOT     reduce using rule 2 (statements -> statement2 .)
    RIGHT_BRACE     reduce using rule 2 (statements -> statement2 .)


state 5

    (4) statement2 -> statement . SEMICOLON

    SEMICOLON       shift and go to state 62


state 6

    (5) statement2 -> if_statement .

    CLOSE_TAG       reduce using rule 5 (statement2 -> if_statement .)
    ONE_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    MULTI_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    BREAK           reduce using rule 5 (statement2 -> if_statement .)
    CONTINUE        reduce using rule 5 (statement2 -> if_statement .)
    IF              reduce using rule 5 (statement2 -> if_statement .)
    WHILE           reduce using rule 5 (statement2 -> if_statement .)
    FUNCTION        reduce using rule 5 (statement2 -> if_statement .)
    CLASS           reduce using rule 5 (statement2 -> if_statement .)
    FSCANF          reduce using rule 5 (statement2 -> if_statement .)
    FGETS           reduce using rule 5 (statement2 -> if_statement .)
    NAME            reduce using rule 5 (statement2 -> if_statement .)
    RETURN          reduce using rule 5 (statement2 -> if_statement .)
    UNSET           reduce using rule 5 (statement2 -> if_statement .)
    COUNT           reduce using rule 5 (statement2 -> if_statement .)
    FOR             reduce using rule 5 (statement2 -> if_statement .)
    PRINT           reduce using rule 5 (statement2 -> if_statement .)
    ECHO            reduce using rule 5 (statement2 -> if_statement .)
    ID              reduce using rule 5 (statement2 -> if_statement .)
    INTEGER         reduce using rule 5 (statement2 -> if_statement .)
    FLOAT           reduce using rule 5 (statement2 -> if_statement .)
    STRING          reduce using rule 5 (statement2 -> if_statement .)
    LEFT_PAREN      reduce using rule 5 (statement2 -> if_statement .)
    TRUE            reduce using rule 5 (statement2 -> if_statement .)
    FALSE           reduce using rule 5 (statement2 -> if_statement .)
    LOGICAL_NOT     reduce using rule 5 (statement2 -> if_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement2 -> if_statement .)


state 7

    (6) statement2 -> while_statement .

    CLOSE_TAG       reduce using rule 6 (statement2 -> while_statement .)
    ONE_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    MULTI_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    BREAK           reduce using rule 6 (statement2 -> while_statement .)
    CONTINUE        reduce using rule 6 (statement2 -> while_statement .)
    IF              reduce using rule 6 (statement2 -> while_statement .)
    WHILE           reduce using rule 6 (statement2 -> while_statement .)
    FUNCTION        reduce using rule 6 (statement2 -> while_statement .)
    CLASS           reduce using rule 6 (statement2 -> while_statement .)
    FSCANF          reduce using rule 6 (statement2 -> while_statement .)
    FGETS           reduce using rule 6 (statement2 -> while_statement .)
    NAME            reduce using rule 6 (statement2 -> while_statement .)
    RETURN          reduce using rule 6 (statement2 -> while_statement .)
    UNSET           reduce using rule 6 (statement2 -> while_statement .)
    COUNT           reduce using rule 6 (statement2 -> while_statement .)
    FOR             reduce using rule 6 (statement2 -> while_statement .)
    PRINT           reduce using rule 6 (statement2 -> while_statement .)
    ECHO            reduce using rule 6 (statement2 -> while_statement .)
    ID              reduce using rule 6 (statement2 -> while_statement .)
    INTEGER         reduce using rule 6 (statement2 -> while_statement .)
    FLOAT           reduce using rule 6 (statement2 -> while_statement .)
    STRING          reduce using rule 6 (statement2 -> while_statement .)
    LEFT_PAREN      reduce using rule 6 (statement2 -> while_statement .)
    TRUE            reduce using rule 6 (statement2 -> while_statement .)
    FALSE           reduce using rule 6 (statement2 -> while_statement .)
    LOGICAL_NOT     reduce using rule 6 (statement2 -> while_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement2 -> while_statement .)


state 8

    (7) statement2 -> for_statement .

    CLOSE_TAG       reduce using rule 7 (statement2 -> for_statement .)
    ONE_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    MULTI_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    BREAK           reduce using rule 7 (statement2 -> for_statement .)
    CONTINUE        reduce using rule 7 (statement2 -> for_statement .)
    IF              reduce using rule 7 (statement2 -> for_statement .)
    WHILE           reduce using rule 7 (statement2 -> for_statement .)
    FUNCTION        reduce using rule 7 (statement2 -> for_statement .)
    CLASS           reduce using rule 7 (statement2 -> for_statement .)
    FSCANF          reduce using rule 7 (statement2 -> for_statement .)
    FGETS           reduce using rule 7 (statement2 -> for_statement .)
    NAME            reduce using rule 7 (statement2 -> for_statement .)
    RETURN          reduce using rule 7 (statement2 -> for_statement .)
    UNSET           reduce using rule 7 (statement2 -> for_statement .)
    COUNT           reduce using rule 7 (statement2 -> for_statement .)
    FOR             reduce using rule 7 (statement2 -> for_statement .)
    PRINT           reduce using rule 7 (statement2 -> for_statement .)
    ECHO            reduce using rule 7 (statement2 -> for_statement .)
    ID              reduce using rule 7 (statement2 -> for_statement .)
    INTEGER         reduce using rule 7 (statement2 -> for_statement .)
    FLOAT           reduce using rule 7 (statement2 -> for_statement .)
    STRING          reduce using rule 7 (statement2 -> for_statement .)
    LEFT_PAREN      reduce using rule 7 (statement2 -> for_statement .)
    TRUE            reduce using rule 7 (statement2 -> for_statement .)
    FALSE           reduce using rule 7 (statement2 -> for_statement .)
    LOGICAL_NOT     reduce using rule 7 (statement2 -> for_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement2 -> for_statement .)


state 9

    (8) statement2 -> function_statement .

    CLOSE_TAG       reduce using rule 8 (statement2 -> function_statement .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    BREAK           reduce using rule 8 (statement2 -> function_statement .)
    CONTINUE        reduce using rule 8 (statement2 -> function_statement .)
    IF              reduce using rule 8 (statement2 -> function_statement .)
    WHILE           reduce using rule 8 (statement2 -> function_statement .)
    FUNCTION        reduce using rule 8 (statement2 -> function_statement .)
    CLASS           reduce using rule 8 (statement2 -> function_statement .)
    FSCANF          reduce using rule 8 (statement2 -> function_statement .)
    FGETS           reduce using rule 8 (statement2 -> function_statement .)
    NAME            reduce using rule 8 (statement2 -> function_statement .)
    RETURN          reduce using rule 8 (statement2 -> function_statement .)
    UNSET           reduce using rule 8 (statement2 -> function_statement .)
    COUNT           reduce using rule 8 (statement2 -> function_statement .)
    FOR             reduce using rule 8 (statement2 -> function_statement .)
    PRINT           reduce using rule 8 (statement2 -> function_statement .)
    ECHO            reduce using rule 8 (statement2 -> function_statement .)
    ID              reduce using rule 8 (statement2 -> function_statement .)
    INTEGER         reduce using rule 8 (statement2 -> function_statement .)
    FLOAT           reduce using rule 8 (statement2 -> function_statement .)
    STRING          reduce using rule 8 (statement2 -> function_statement .)
    LEFT_PAREN      reduce using rule 8 (statement2 -> function_statement .)
    TRUE            reduce using rule 8 (statement2 -> function_statement .)
    FALSE           reduce using rule 8 (statement2 -> function_statement .)
    LOGICAL_NOT     reduce using rule 8 (statement2 -> function_statement .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> function_statement .)


state 10

    (9) statement2 -> ONE_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FUNCTION        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CLASS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    NAME            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RETURN          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    UNSET           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    COUNT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    INTEGER         reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FLOAT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    STRING          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    LEFT_PAREN      reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    TRUE            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FALSE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    LOGICAL_NOT     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)


state 11

    (10) statement2 -> MULTI_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FUNCTION        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CLASS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    NAME            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RETURN          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    UNSET           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    COUNT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    INTEGER         reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FLOAT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    STRING          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    LEFT_PAREN      reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    TRUE            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FALSE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    LOGICAL_NOT     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)


state 12

    (11) statement2 -> class_declaration .

    CLOSE_TAG       reduce using rule 11 (statement2 -> class_declaration .)
    ONE_LINE_COMMENT reduce using rule 11 (statement2 -> class_declaration .)
    MULTI_LINE_COMMENT reduce using rule 11 (statement2 -> class_declaration .)
    BREAK           reduce using rule 11 (statement2 -> class_declaration .)
    CONTINUE        reduce using rule 11 (statement2 -> class_declaration .)
    IF              reduce using rule 11 (statement2 -> class_declaration .)
    WHILE           reduce using rule 11 (statement2 -> class_declaration .)
    FUNCTION        reduce using rule 11 (statement2 -> class_declaration .)
    CLASS           reduce using rule 11 (statement2 -> class_declaration .)
    FSCANF          reduce using rule 11 (statement2 -> class_declaration .)
    FGETS           reduce using rule 11 (statement2 -> class_declaration .)
    NAME            reduce using rule 11 (statement2 -> class_declaration .)
    RETURN          reduce using rule 11 (statement2 -> class_declaration .)
    UNSET           reduce using rule 11 (statement2 -> class_declaration .)
    COUNT           reduce using rule 11 (statement2 -> class_declaration .)
    FOR             reduce using rule 11 (statement2 -> class_declaration .)
    PRINT           reduce using rule 11 (statement2 -> class_declaration .)
    ECHO            reduce using rule 11 (statement2 -> class_declaration .)
    ID              reduce using rule 11 (statement2 -> class_declaration .)
    INTEGER         reduce using rule 11 (statement2 -> class_declaration .)
    FLOAT           reduce using rule 11 (statement2 -> class_declaration .)
    STRING          reduce using rule 11 (statement2 -> class_declaration .)
    LEFT_PAREN      reduce using rule 11 (statement2 -> class_declaration .)
    TRUE            reduce using rule 11 (statement2 -> class_declaration .)
    FALSE           reduce using rule 11 (statement2 -> class_declaration .)
    LOGICAL_NOT     reduce using rule 11 (statement2 -> class_declaration .)
    RIGHT_BRACE     reduce using rule 11 (statement2 -> class_declaration .)


state 13

    (12) statement -> print_statement .

    SEMICOLON       reduce using rule 12 (statement -> print_statement .)
    RIGHT_PAREN     reduce using rule 12 (statement -> print_statement .)
    COMMA           reduce using rule 12 (statement -> print_statement .)


state 14

    (13) statement -> fscanf_statement .

    SEMICOLON       reduce using rule 13 (statement -> fscanf_statement .)
    RIGHT_PAREN     reduce using rule 13 (statement -> fscanf_statement .)
    COMMA           reduce using rule 13 (statement -> fscanf_statement .)


state 15

    (14) statement -> fgets_statement .

    SEMICOLON       reduce using rule 14 (statement -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 14 (statement -> fgets_statement .)
    COMMA           reduce using rule 14 (statement -> fgets_statement .)


state 16

    (15) statement -> assignment_statement .

    SEMICOLON       reduce using rule 15 (statement -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 15 (statement -> assignment_statement .)
    COMMA           reduce using rule 15 (statement -> assignment_statement .)


state 17

    (16) statement -> array_declaration_statement .

    SEMICOLON       reduce using rule 16 (statement -> array_declaration_statement .)
    RIGHT_PAREN     reduce using rule 16 (statement -> array_declaration_statement .)
    COMMA           reduce using rule 16 (statement -> array_declaration_statement .)


state 18

    (17) statement -> BREAK .

    SEMICOLON       reduce using rule 17 (statement -> BREAK .)
    RIGHT_PAREN     reduce using rule 17 (statement -> BREAK .)
    COMMA           reduce using rule 17 (statement -> BREAK .)


state 19

    (18) statement -> CONTINUE .

    SEMICOLON       reduce using rule 18 (statement -> CONTINUE .)
    RIGHT_PAREN     reduce using rule 18 (statement -> CONTINUE .)
    COMMA           reduce using rule 18 (statement -> CONTINUE .)


state 20

    (19) statement -> function_call .

    SEMICOLON       reduce using rule 19 (statement -> function_call .)
    RIGHT_PAREN     reduce using rule 19 (statement -> function_call .)
    COMMA           reduce using rule 19 (statement -> function_call .)


state 21

    (20) statement -> return_statement .

    SEMICOLON       reduce using rule 20 (statement -> return_statement .)
    RIGHT_PAREN     reduce using rule 20 (statement -> return_statement .)
    COMMA           reduce using rule 20 (statement -> return_statement .)


state 22

    (21) statement -> array_indexing .

    SEMICOLON       reduce using rule 21 (statement -> array_indexing .)
    RIGHT_PAREN     reduce using rule 21 (statement -> array_indexing .)
    COMMA           reduce using rule 21 (statement -> array_indexing .)


state 23

    (22) statement -> array_add_element .

    SEMICOLON       reduce using rule 22 (statement -> array_add_element .)
    RIGHT_PAREN     reduce using rule 22 (statement -> array_add_element .)
    COMMA           reduce using rule 22 (statement -> array_add_element .)


state 24

    (23) statement -> array_modify_element .

    SEMICOLON       reduce using rule 23 (statement -> array_modify_element .)
    RIGHT_PAREN     reduce using rule 23 (statement -> array_modify_element .)
    COMMA           reduce using rule 23 (statement -> array_modify_element .)


state 25

    (24) statement -> array_remove_element .

    SEMICOLON       reduce using rule 24 (statement -> array_remove_element .)
    RIGHT_PAREN     reduce using rule 24 (statement -> array_remove_element .)
    COMMA           reduce using rule 24 (statement -> array_remove_element .)


state 26

    (25) statement -> array_count_elements .

    SEMICOLON       reduce using rule 25 (statement -> array_count_elements .)
    RIGHT_PAREN     reduce using rule 25 (statement -> array_count_elements .)
    COMMA           reduce using rule 25 (statement -> array_count_elements .)


state 27

    (26) statement -> expression .
    (71) expression -> expression . PLUS term
    (72) expression -> expression . MINUS term
    (118) relational_expression -> expression . relational_operator expression
    (119) relational_operator -> . EQUAL_TO
    (120) relational_operator -> . NOT_EQUAL_TO
    (121) relational_operator -> . LESS_THAN
    (122) relational_operator -> . GREATER_THAN
    (123) relational_operator -> . LESS_EQUAL
    (124) relational_operator -> . GREATER_EQUAL
    (125) relational_operator -> . IDENTICAL_TO
    (126) relational_operator -> . NOT_IDENTICAL_TO
    (127) relational_operator -> . DIFFERENT

    SEMICOLON       reduce using rule 26 (statement -> expression .)
    RIGHT_PAREN     reduce using rule 26 (statement -> expression .)
    COMMA           reduce using rule 26 (statement -> expression .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL_TO    shift and go to state 67
    LESS_THAN       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    IDENTICAL_TO    shift and go to state 72
    NOT_IDENTICAL_TO shift and go to state 73
    DIFFERENT       shift and go to state 74

    relational_operator            shift and go to state 65

state 28

    (84) if_statement -> IF . parenthesized_condition block
    (85) if_statement -> IF . parenthesized_condition block else_if_extended
    (86) if_statement -> IF . parenthesized_condition block else_if_extended if_part3
    (87) if_statement -> IF . parenthesized_condition block if_part3
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 76

    parenthesized_condition        shift and go to state 75

state 29

    (110) condition -> parenthesized_condition .

    LOGICAL_AND     reduce using rule 110 (condition -> parenthesized_condition .)
    LOGICAL_OR      reduce using rule 110 (condition -> parenthesized_condition .)
    LOGICAL_XOR     reduce using rule 110 (condition -> parenthesized_condition .)
    TIMES           reduce using rule 110 (condition -> parenthesized_condition .)
    DIVIDE          reduce using rule 110 (condition -> parenthesized_condition .)
    MOD             reduce using rule 110 (condition -> parenthesized_condition .)
    POWER           reduce using rule 110 (condition -> parenthesized_condition .)
    PLUS            reduce using rule 110 (condition -> parenthesized_condition .)
    MINUS           reduce using rule 110 (condition -> parenthesized_condition .)
    EQUAL_TO        reduce using rule 110 (condition -> parenthesized_condition .)
    NOT_EQUAL_TO    reduce using rule 110 (condition -> parenthesized_condition .)
    LESS_THAN       reduce using rule 110 (condition -> parenthesized_condition .)
    GREATER_THAN    reduce using rule 110 (condition -> parenthesized_condition .)
    LESS_EQUAL      reduce using rule 110 (condition -> parenthesized_condition .)
    GREATER_EQUAL   reduce using rule 110 (condition -> parenthesized_condition .)
    IDENTICAL_TO    reduce using rule 110 (condition -> parenthesized_condition .)
    NOT_IDENTICAL_TO reduce using rule 110 (condition -> parenthesized_condition .)
    DIFFERENT       reduce using rule 110 (condition -> parenthesized_condition .)
    SEMICOLON       reduce using rule 110 (condition -> parenthesized_condition .)
    RIGHT_PAREN     reduce using rule 110 (condition -> parenthesized_condition .)
    DOT             reduce using rule 110 (condition -> parenthesized_condition .)
    COMMA           reduce using rule 110 (condition -> parenthesized_condition .)
    RIGHT_BRACKET   reduce using rule 110 (condition -> parenthesized_condition .)


state 30

    (92) while_statement -> WHILE . parenthesized_condition block
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 76

    parenthesized_condition        shift and go to state 77

state 31

    (95) for_statement -> for_part1 . condition for_part3
    (96) for_statement -> for_part1 . for_part3
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (97) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (98) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN

    SEMICOLON       shift and go to state 80
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39

    condition                      shift and go to state 78
    for_part3                      shift and go to state 79
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58
    expression                     shift and go to state 83
    term                           shift and go to state 45
    factor                         shift and go to state 50

state 32

    (81) factor -> condition .
    (116) complex_condition -> condition . logical_operator condition
    (128) logical_operator -> . LOGICAL_AND
    (129) logical_operator -> . LOGICAL_OR
    (130) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    TIMES           reduce using rule 81 (factor -> condition .)
    DIVIDE          reduce using rule 81 (factor -> condition .)
    MOD             reduce using rule 81 (factor -> condition .)
    POWER           reduce using rule 81 (factor -> condition .)
    PLUS            reduce using rule 81 (factor -> condition .)
    MINUS           reduce using rule 81 (factor -> condition .)
    EQUAL_TO        reduce using rule 81 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 81 (factor -> condition .)
    LESS_THAN       reduce using rule 81 (factor -> condition .)
    GREATER_THAN    reduce using rule 81 (factor -> condition .)
    LESS_EQUAL      reduce using rule 81 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 81 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 81 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 81 (factor -> condition .)
    DIFFERENT       reduce using rule 81 (factor -> condition .)
    SEMICOLON       reduce using rule 81 (factor -> condition .)
    DOT             reduce using rule 81 (factor -> condition .)
    COMMA           reduce using rule 81 (factor -> condition .)
    RIGHT_PAREN     reduce using rule 81 (factor -> condition .)
    RIGHT_BRACKET   reduce using rule 81 (factor -> condition .)
    LOGICAL_AND     shift and go to state 85
    LOGICAL_OR      shift and go to state 86
    LOGICAL_XOR     shift and go to state 87

  ! LOGICAL_AND     [ reduce using rule 81 (factor -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 81 (factor -> condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 81 (factor -> condition .) ]

    logical_operator               shift and go to state 84

state 33

    (27) function_statement -> FUNCTION . NAME LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> FUNCTION . NAME LEFT_PAREN RIGHT_PAREN block

    NAME            shift and go to state 88


state 34

    (36) function_call -> NAME . LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> NAME . LEFT_PAREN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 89


state 35

    (83) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (117) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression

    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    ID              shift and go to state 49

    expression                     shift and go to state 90
    condition                      shift and go to state 91
    term                           shift and go to state 45
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    factor                         shift and go to state 50
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 36

    (148) class_declaration -> CLASS . NAME LEFT_BRACE class_statements RIGHT_BRACE
    (149) class_declaration -> CLASS . NAME LEFT_BRACE RIGHT_BRACE

    NAME            shift and go to state 92


state 37

    (53) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> print_function . arguments
    (57) arguments -> . argument
    (58) arguments -> . arguments DOT argument
    (59) arguments -> . arguments COMMA argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    LEFT_PAREN      shift and go to state 93
    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    arguments                      shift and go to state 94
    argument                       shift and go to state 95
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 38

    (39) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 112


state 39

    (82) factor -> STRING .

    TIMES           reduce using rule 82 (factor -> STRING .)
    DIVIDE          reduce using rule 82 (factor -> STRING .)
    MOD             reduce using rule 82 (factor -> STRING .)
    POWER           reduce using rule 82 (factor -> STRING .)
    PLUS            reduce using rule 82 (factor -> STRING .)
    MINUS           reduce using rule 82 (factor -> STRING .)
    EQUAL_TO        reduce using rule 82 (factor -> STRING .)
    NOT_EQUAL_TO    reduce using rule 82 (factor -> STRING .)
    LESS_THAN       reduce using rule 82 (factor -> STRING .)
    GREATER_THAN    reduce using rule 82 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 82 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 82 (factor -> STRING .)
    IDENTICAL_TO    reduce using rule 82 (factor -> STRING .)
    NOT_IDENTICAL_TO reduce using rule 82 (factor -> STRING .)
    DIFFERENT       reduce using rule 82 (factor -> STRING .)
    SEMICOLON       reduce using rule 82 (factor -> STRING .)
    RIGHT_PAREN     reduce using rule 82 (factor -> STRING .)
    LOGICAL_AND     reduce using rule 82 (factor -> STRING .)
    LOGICAL_OR      reduce using rule 82 (factor -> STRING .)
    LOGICAL_XOR     reduce using rule 82 (factor -> STRING .)
    DOT             reduce using rule 82 (factor -> STRING .)
    COMMA           reduce using rule 82 (factor -> STRING .)
    RIGHT_BRACKET   reduce using rule 82 (factor -> STRING .)


state 40

    (38) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 113


state 41

    (44) assignment_statement -> variable . assignment_operator argument
    (45) assignment_statement -> variable . PLUS_PLUS
    (46) assignment_statement -> variable . MINUS_MINUS
    (134) array_declaration_statement -> variable . EQUALS array
    (143) array_indexing -> variable . LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> variable . LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> variable . LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (113) simple_condition -> variable .
    (47) assignment_operator -> . EQUALS
    (48) assignment_operator -> . PLUS_EQUALS
    (49) assignment_operator -> . MINUS_EQUALS
    (50) assignment_operator -> . TIMES_EQUALS
    (51) assignment_operator -> . DIVIDE_EQUALS
    (52) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 115
    MINUS_MINUS     shift and go to state 116
    EQUALS          shift and go to state 117
    LEFT_BRACKET    shift and go to state 118
    LOGICAL_AND     reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 113 (simple_condition -> variable .)
    TIMES           reduce using rule 113 (simple_condition -> variable .)
    DIVIDE          reduce using rule 113 (simple_condition -> variable .)
    MOD             reduce using rule 113 (simple_condition -> variable .)
    POWER           reduce using rule 113 (simple_condition -> variable .)
    PLUS            reduce using rule 113 (simple_condition -> variable .)
    MINUS           reduce using rule 113 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 113 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 113 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 113 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 113 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 113 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 113 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 113 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 113 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 113 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 113 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 113 (simple_condition -> variable .)
    COMMA           reduce using rule 113 (simple_condition -> variable .)
    PLUS_EQUALS     shift and go to state 119
    MINUS_EQUALS    shift and go to state 120
    TIMES_EQUALS    shift and go to state 121
    DIVIDE_EQUALS   shift and go to state 122
    MOD_EQUALS      shift and go to state 123

    assignment_operator            shift and go to state 114

state 42

    (35) return_statement -> RETURN . arguments
    (57) arguments -> . argument
    (58) arguments -> . arguments DOT argument
    (59) arguments -> . arguments COMMA argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    arguments                      shift and go to state 124
    argument                       shift and go to state 95
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 43

    (146) array_remove_element -> UNSET . LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN

    LEFT_PAREN      shift and go to state 126


state 44

    (147) array_count_elements -> COUNT . LEFT_PAREN variable RIGHT_PAREN

    LEFT_PAREN      shift and go to state 127


state 45

    (73) expression -> term .
    (74) term -> term . TIMES factor
    (75) term -> term . DIVIDE factor
    (76) term -> term . MOD factor
    (77) term -> term . POWER factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    PLUS            reduce using rule 73 (expression -> term .)
    MINUS           reduce using rule 73 (expression -> term .)
    EQUAL_TO        reduce using rule 73 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 73 (expression -> term .)
    LESS_THAN       reduce using rule 73 (expression -> term .)
    GREATER_THAN    reduce using rule 73 (expression -> term .)
    LESS_EQUAL      reduce using rule 73 (expression -> term .)
    GREATER_EQUAL   reduce using rule 73 (expression -> term .)
    IDENTICAL_TO    reduce using rule 73 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 73 (expression -> term .)
    DIFFERENT       reduce using rule 73 (expression -> term .)
    SEMICOLON       reduce using rule 73 (expression -> term .)
    RIGHT_PAREN     reduce using rule 73 (expression -> term .)
    DOT             reduce using rule 73 (expression -> term .)
    COMMA           reduce using rule 73 (expression -> term .)
    LOGICAL_AND     reduce using rule 73 (expression -> term .)
    LOGICAL_OR      reduce using rule 73 (expression -> term .)
    LOGICAL_XOR     reduce using rule 73 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 73 (expression -> term .)
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    MOD             shift and go to state 130
    POWER           shift and go to state 131

  ! TIMES           [ reduce using rule 73 (expression -> term .) ]
  ! DIVIDE          [ reduce using rule 73 (expression -> term .) ]
  ! MOD             [ reduce using rule 73 (expression -> term .) ]
  ! POWER           [ reduce using rule 73 (expression -> term .) ]


state 46

    (93) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (94) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 132


state 47

    (55) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 55 (print_function -> PRINT .)
    STRING          reduce using rule 55 (print_function -> PRINT .)
    ID              reduce using rule 55 (print_function -> PRINT .)
    ARRAY           reduce using rule 55 (print_function -> PRINT .)
    LEFT_BRACKET    reduce using rule 55 (print_function -> PRINT .)
    NAME            reduce using rule 55 (print_function -> PRINT .)
    FUNCTION        reduce using rule 55 (print_function -> PRINT .)
    FGETS           reduce using rule 55 (print_function -> PRINT .)
    NEW             reduce using rule 55 (print_function -> PRINT .)
    INTEGER         reduce using rule 55 (print_function -> PRINT .)
    FLOAT           reduce using rule 55 (print_function -> PRINT .)
    TRUE            reduce using rule 55 (print_function -> PRINT .)
    FALSE           reduce using rule 55 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 55 (print_function -> PRINT .)


state 48

    (56) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 56 (print_function -> ECHO .)
    STRING          reduce using rule 56 (print_function -> ECHO .)
    ID              reduce using rule 56 (print_function -> ECHO .)
    ARRAY           reduce using rule 56 (print_function -> ECHO .)
    LEFT_BRACKET    reduce using rule 56 (print_function -> ECHO .)
    NAME            reduce using rule 56 (print_function -> ECHO .)
    FUNCTION        reduce using rule 56 (print_function -> ECHO .)
    FGETS           reduce using rule 56 (print_function -> ECHO .)
    NEW             reduce using rule 56 (print_function -> ECHO .)
    INTEGER         reduce using rule 56 (print_function -> ECHO .)
    FLOAT           reduce using rule 56 (print_function -> ECHO .)
    TRUE            reduce using rule 56 (print_function -> ECHO .)
    FALSE           reduce using rule 56 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 56 (print_function -> ECHO .)


state 49

    (42) variable -> ID .
    (43) variable -> ID . CALL NAME

    PLUS_PLUS       reduce using rule 42 (variable -> ID .)
    MINUS_MINUS     reduce using rule 42 (variable -> ID .)
    EQUALS          reduce using rule 42 (variable -> ID .)
    LEFT_BRACKET    reduce using rule 42 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 42 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 42 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 42 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 42 (variable -> ID .)
    MOD_EQUALS      reduce using rule 42 (variable -> ID .)
    LOGICAL_AND     reduce using rule 42 (variable -> ID .)
    LOGICAL_OR      reduce using rule 42 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 42 (variable -> ID .)
    TIMES           reduce using rule 42 (variable -> ID .)
    DIVIDE          reduce using rule 42 (variable -> ID .)
    MOD             reduce using rule 42 (variable -> ID .)
    POWER           reduce using rule 42 (variable -> ID .)
    PLUS            reduce using rule 42 (variable -> ID .)
    MINUS           reduce using rule 42 (variable -> ID .)
    EQUAL_TO        reduce using rule 42 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 42 (variable -> ID .)
    LESS_THAN       reduce using rule 42 (variable -> ID .)
    GREATER_THAN    reduce using rule 42 (variable -> ID .)
    LESS_EQUAL      reduce using rule 42 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 42 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 42 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 42 (variable -> ID .)
    DIFFERENT       reduce using rule 42 (variable -> ID .)
    SEMICOLON       reduce using rule 42 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 42 (variable -> ID .)
    DOT             reduce using rule 42 (variable -> ID .)
    COMMA           reduce using rule 42 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 42 (variable -> ID .)
    CALL            shift and go to state 133


state 50

    (78) term -> factor .

    TIMES           reduce using rule 78 (term -> factor .)
    DIVIDE          reduce using rule 78 (term -> factor .)
    MOD             reduce using rule 78 (term -> factor .)
    POWER           reduce using rule 78 (term -> factor .)
    PLUS            reduce using rule 78 (term -> factor .)
    MINUS           reduce using rule 78 (term -> factor .)
    EQUAL_TO        reduce using rule 78 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 78 (term -> factor .)
    LESS_THAN       reduce using rule 78 (term -> factor .)
    GREATER_THAN    reduce using rule 78 (term -> factor .)
    LESS_EQUAL      reduce using rule 78 (term -> factor .)
    GREATER_EQUAL   reduce using rule 78 (term -> factor .)
    IDENTICAL_TO    reduce using rule 78 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 78 (term -> factor .)
    DIFFERENT       reduce using rule 78 (term -> factor .)
    SEMICOLON       reduce using rule 78 (term -> factor .)
    RIGHT_PAREN     reduce using rule 78 (term -> factor .)
    DOT             reduce using rule 78 (term -> factor .)
    COMMA           reduce using rule 78 (term -> factor .)
    LOGICAL_AND     reduce using rule 78 (term -> factor .)
    LOGICAL_OR      reduce using rule 78 (term -> factor .)
    LOGICAL_XOR     reduce using rule 78 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 78 (term -> factor .)


state 51

    (79) factor -> INTEGER .

    TIMES           reduce using rule 79 (factor -> INTEGER .)
    DIVIDE          reduce using rule 79 (factor -> INTEGER .)
    MOD             reduce using rule 79 (factor -> INTEGER .)
    POWER           reduce using rule 79 (factor -> INTEGER .)
    PLUS            reduce using rule 79 (factor -> INTEGER .)
    MINUS           reduce using rule 79 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 79 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 79 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 79 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 79 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 79 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 79 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 79 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 79 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 79 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 79 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 79 (factor -> INTEGER .)
    DOT             reduce using rule 79 (factor -> INTEGER .)
    COMMA           reduce using rule 79 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 79 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 79 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 79 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 79 (factor -> INTEGER .)


state 52

    (80) factor -> FLOAT .

    TIMES           reduce using rule 80 (factor -> FLOAT .)
    DIVIDE          reduce using rule 80 (factor -> FLOAT .)
    MOD             reduce using rule 80 (factor -> FLOAT .)
    POWER           reduce using rule 80 (factor -> FLOAT .)
    PLUS            reduce using rule 80 (factor -> FLOAT .)
    MINUS           reduce using rule 80 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 80 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 80 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 80 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 80 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 80 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 80 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 80 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 80 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 80 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 80 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 80 (factor -> FLOAT .)
    DOT             reduce using rule 80 (factor -> FLOAT .)
    COMMA           reduce using rule 80 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 80 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 80 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 80 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 80 (factor -> FLOAT .)


state 53

    (107) condition -> simple_condition .

    LOGICAL_AND     reduce using rule 107 (condition -> simple_condition .)
    LOGICAL_OR      reduce using rule 107 (condition -> simple_condition .)
    LOGICAL_XOR     reduce using rule 107 (condition -> simple_condition .)
    TIMES           reduce using rule 107 (condition -> simple_condition .)
    DIVIDE          reduce using rule 107 (condition -> simple_condition .)
    MOD             reduce using rule 107 (condition -> simple_condition .)
    POWER           reduce using rule 107 (condition -> simple_condition .)
    PLUS            reduce using rule 107 (condition -> simple_condition .)
    MINUS           reduce using rule 107 (condition -> simple_condition .)
    EQUAL_TO        reduce using rule 107 (condition -> simple_condition .)
    NOT_EQUAL_TO    reduce using rule 107 (condition -> simple_condition .)
    LESS_THAN       reduce using rule 107 (condition -> simple_condition .)
    GREATER_THAN    reduce using rule 107 (condition -> simple_condition .)
    LESS_EQUAL      reduce using rule 107 (condition -> simple_condition .)
    GREATER_EQUAL   reduce using rule 107 (condition -> simple_condition .)
    IDENTICAL_TO    reduce using rule 107 (condition -> simple_condition .)
    NOT_IDENTICAL_TO reduce using rule 107 (condition -> simple_condition .)
    DIFFERENT       reduce using rule 107 (condition -> simple_condition .)
    SEMICOLON       reduce using rule 107 (condition -> simple_condition .)
    RIGHT_PAREN     reduce using rule 107 (condition -> simple_condition .)
    DOT             reduce using rule 107 (condition -> simple_condition .)
    COMMA           reduce using rule 107 (condition -> simple_condition .)
    RIGHT_BRACKET   reduce using rule 107 (condition -> simple_condition .)


state 54

    (108) condition -> negated_condition .

    LOGICAL_AND     reduce using rule 108 (condition -> negated_condition .)
    LOGICAL_OR      reduce using rule 108 (condition -> negated_condition .)
    LOGICAL_XOR     reduce using rule 108 (condition -> negated_condition .)
    TIMES           reduce using rule 108 (condition -> negated_condition .)
    DIVIDE          reduce using rule 108 (condition -> negated_condition .)
    MOD             reduce using rule 108 (condition -> negated_condition .)
    POWER           reduce using rule 108 (condition -> negated_condition .)
    PLUS            reduce using rule 108 (condition -> negated_condition .)
    MINUS           reduce using rule 108 (condition -> negated_condition .)
    EQUAL_TO        reduce using rule 108 (condition -> negated_condition .)
    NOT_EQUAL_TO    reduce using rule 108 (condition -> negated_condition .)
    LESS_THAN       reduce using rule 108 (condition -> negated_condition .)
    GREATER_THAN    reduce using rule 108 (condition -> negated_condition .)
    LESS_EQUAL      reduce using rule 108 (condition -> negated_condition .)
    GREATER_EQUAL   reduce using rule 108 (condition -> negated_condition .)
    IDENTICAL_TO    reduce using rule 108 (condition -> negated_condition .)
    NOT_IDENTICAL_TO reduce using rule 108 (condition -> negated_condition .)
    DIFFERENT       reduce using rule 108 (condition -> negated_condition .)
    SEMICOLON       reduce using rule 108 (condition -> negated_condition .)
    RIGHT_PAREN     reduce using rule 108 (condition -> negated_condition .)
    DOT             reduce using rule 108 (condition -> negated_condition .)
    COMMA           reduce using rule 108 (condition -> negated_condition .)
    RIGHT_BRACKET   reduce using rule 108 (condition -> negated_condition .)


state 55

    (109) condition -> complex_condition .

    LOGICAL_AND     reduce using rule 109 (condition -> complex_condition .)
    LOGICAL_OR      reduce using rule 109 (condition -> complex_condition .)
    LOGICAL_XOR     reduce using rule 109 (condition -> complex_condition .)
    TIMES           reduce using rule 109 (condition -> complex_condition .)
    DIVIDE          reduce using rule 109 (condition -> complex_condition .)
    MOD             reduce using rule 109 (condition -> complex_condition .)
    POWER           reduce using rule 109 (condition -> complex_condition .)
    PLUS            reduce using rule 109 (condition -> complex_condition .)
    MINUS           reduce using rule 109 (condition -> complex_condition .)
    EQUAL_TO        reduce using rule 109 (condition -> complex_condition .)
    NOT_EQUAL_TO    reduce using rule 109 (condition -> complex_condition .)
    LESS_THAN       reduce using rule 109 (condition -> complex_condition .)
    GREATER_THAN    reduce using rule 109 (condition -> complex_condition .)
    LESS_EQUAL      reduce using rule 109 (condition -> complex_condition .)
    GREATER_EQUAL   reduce using rule 109 (condition -> complex_condition .)
    IDENTICAL_TO    reduce using rule 109 (condition -> complex_condition .)
    NOT_IDENTICAL_TO reduce using rule 109 (condition -> complex_condition .)
    DIFFERENT       reduce using rule 109 (condition -> complex_condition .)
    SEMICOLON       reduce using rule 109 (condition -> complex_condition .)
    RIGHT_PAREN     reduce using rule 109 (condition -> complex_condition .)
    DOT             reduce using rule 109 (condition -> complex_condition .)
    COMMA           reduce using rule 109 (condition -> complex_condition .)
    RIGHT_BRACKET   reduce using rule 109 (condition -> complex_condition .)


state 56

    (111) simple_condition -> TRUE .

    LOGICAL_AND     reduce using rule 111 (simple_condition -> TRUE .)
    LOGICAL_OR      reduce using rule 111 (simple_condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 111 (simple_condition -> TRUE .)
    TIMES           reduce using rule 111 (simple_condition -> TRUE .)
    DIVIDE          reduce using rule 111 (simple_condition -> TRUE .)
    MOD             reduce using rule 111 (simple_condition -> TRUE .)
    POWER           reduce using rule 111 (simple_condition -> TRUE .)
    PLUS            reduce using rule 111 (simple_condition -> TRUE .)
    MINUS           reduce using rule 111 (simple_condition -> TRUE .)
    EQUAL_TO        reduce using rule 111 (simple_condition -> TRUE .)
    NOT_EQUAL_TO    reduce using rule 111 (simple_condition -> TRUE .)
    LESS_THAN       reduce using rule 111 (simple_condition -> TRUE .)
    GREATER_THAN    reduce using rule 111 (simple_condition -> TRUE .)
    LESS_EQUAL      reduce using rule 111 (simple_condition -> TRUE .)
    GREATER_EQUAL   reduce using rule 111 (simple_condition -> TRUE .)
    IDENTICAL_TO    reduce using rule 111 (simple_condition -> TRUE .)
    NOT_IDENTICAL_TO reduce using rule 111 (simple_condition -> TRUE .)
    DIFFERENT       reduce using rule 111 (simple_condition -> TRUE .)
    SEMICOLON       reduce using rule 111 (simple_condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 111 (simple_condition -> TRUE .)
    DOT             reduce using rule 111 (simple_condition -> TRUE .)
    COMMA           reduce using rule 111 (simple_condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 111 (simple_condition -> TRUE .)


state 57

    (112) simple_condition -> FALSE .

    LOGICAL_AND     reduce using rule 112 (simple_condition -> FALSE .)
    LOGICAL_OR      reduce using rule 112 (simple_condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 112 (simple_condition -> FALSE .)
    TIMES           reduce using rule 112 (simple_condition -> FALSE .)
    DIVIDE          reduce using rule 112 (simple_condition -> FALSE .)
    MOD             reduce using rule 112 (simple_condition -> FALSE .)
    POWER           reduce using rule 112 (simple_condition -> FALSE .)
    PLUS            reduce using rule 112 (simple_condition -> FALSE .)
    MINUS           reduce using rule 112 (simple_condition -> FALSE .)
    EQUAL_TO        reduce using rule 112 (simple_condition -> FALSE .)
    NOT_EQUAL_TO    reduce using rule 112 (simple_condition -> FALSE .)
    LESS_THAN       reduce using rule 112 (simple_condition -> FALSE .)
    GREATER_THAN    reduce using rule 112 (simple_condition -> FALSE .)
    LESS_EQUAL      reduce using rule 112 (simple_condition -> FALSE .)
    GREATER_EQUAL   reduce using rule 112 (simple_condition -> FALSE .)
    IDENTICAL_TO    reduce using rule 112 (simple_condition -> FALSE .)
    NOT_IDENTICAL_TO reduce using rule 112 (simple_condition -> FALSE .)
    DIFFERENT       reduce using rule 112 (simple_condition -> FALSE .)
    SEMICOLON       reduce using rule 112 (simple_condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 112 (simple_condition -> FALSE .)
    DOT             reduce using rule 112 (simple_condition -> FALSE .)
    COMMA           reduce using rule 112 (simple_condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 112 (simple_condition -> FALSE .)


state 58

    (114) simple_condition -> relational_expression .

    LOGICAL_AND     reduce using rule 114 (simple_condition -> relational_expression .)
    LOGICAL_OR      reduce using rule 114 (simple_condition -> relational_expression .)
    LOGICAL_XOR     reduce using rule 114 (simple_condition -> relational_expression .)
    TIMES           reduce using rule 114 (simple_condition -> relational_expression .)
    DIVIDE          reduce using rule 114 (simple_condition -> relational_expression .)
    MOD             reduce using rule 114 (simple_condition -> relational_expression .)
    POWER           reduce using rule 114 (simple_condition -> relational_expression .)
    PLUS            reduce using rule 114 (simple_condition -> relational_expression .)
    MINUS           reduce using rule 114 (simple_condition -> relational_expression .)
    EQUAL_TO        reduce using rule 114 (simple_condition -> relational_expression .)
    NOT_EQUAL_TO    reduce using rule 114 (simple_condition -> relational_expression .)
    LESS_THAN       reduce using rule 114 (simple_condition -> relational_expression .)
    GREATER_THAN    reduce using rule 114 (simple_condition -> relational_expression .)
    LESS_EQUAL      reduce using rule 114 (simple_condition -> relational_expression .)
    GREATER_EQUAL   reduce using rule 114 (simple_condition -> relational_expression .)
    IDENTICAL_TO    reduce using rule 114 (simple_condition -> relational_expression .)
    NOT_IDENTICAL_TO reduce using rule 114 (simple_condition -> relational_expression .)
    DIFFERENT       reduce using rule 114 (simple_condition -> relational_expression .)
    SEMICOLON       reduce using rule 114 (simple_condition -> relational_expression .)
    RIGHT_PAREN     reduce using rule 114 (simple_condition -> relational_expression .)
    DOT             reduce using rule 114 (simple_condition -> relational_expression .)
    COMMA           reduce using rule 114 (simple_condition -> relational_expression .)
    RIGHT_BRACKET   reduce using rule 114 (simple_condition -> relational_expression .)


state 59

    (115) negated_condition -> LOGICAL_NOT . condition
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39

    condition                      shift and go to state 134
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58
    expression                     shift and go to state 83
    term                           shift and go to state 45
    factor                         shift and go to state 50

state 60

    (1) program -> OPEN_TAG statements CLOSE_TAG .

    $end            reduce using rule 1 (program -> OPEN_TAG statements CLOSE_TAG .)


state 61

    (3) statements -> statements statement2 .

    CLOSE_TAG       reduce using rule 3 (statements -> statements statement2 .)
    ONE_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    MULTI_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    BREAK           reduce using rule 3 (statements -> statements statement2 .)
    CONTINUE        reduce using rule 3 (statements -> statements statement2 .)
    IF              reduce using rule 3 (statements -> statements statement2 .)
    WHILE           reduce using rule 3 (statements -> statements statement2 .)
    FUNCTION        reduce using rule 3 (statements -> statements statement2 .)
    CLASS           reduce using rule 3 (statements -> statements statement2 .)
    FSCANF          reduce using rule 3 (statements -> statements statement2 .)
    FGETS           reduce using rule 3 (statements -> statements statement2 .)
    NAME            reduce using rule 3 (statements -> statements statement2 .)
    RETURN          reduce using rule 3 (statements -> statements statement2 .)
    UNSET           reduce using rule 3 (statements -> statements statement2 .)
    COUNT           reduce using rule 3 (statements -> statements statement2 .)
    FOR             reduce using rule 3 (statements -> statements statement2 .)
    PRINT           reduce using rule 3 (statements -> statements statement2 .)
    ECHO            reduce using rule 3 (statements -> statements statement2 .)
    ID              reduce using rule 3 (statements -> statements statement2 .)
    INTEGER         reduce using rule 3 (statements -> statements statement2 .)
    FLOAT           reduce using rule 3 (statements -> statements statement2 .)
    STRING          reduce using rule 3 (statements -> statements statement2 .)
    LEFT_PAREN      reduce using rule 3 (statements -> statements statement2 .)
    TRUE            reduce using rule 3 (statements -> statements statement2 .)
    FALSE           reduce using rule 3 (statements -> statements statement2 .)
    LOGICAL_NOT     reduce using rule 3 (statements -> statements statement2 .)
    RIGHT_BRACE     reduce using rule 3 (statements -> statements statement2 .)


state 62

    (4) statement2 -> statement SEMICOLON .

    CLOSE_TAG       reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    BREAK           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    IF              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CLASS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FSCANF          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FGETS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    NAME            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RETURN          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    UNSET           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    COUNT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FOR             reduce using rule 4 (statement2 -> statement SEMICOLON .)
    PRINT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ECHO            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ID              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    INTEGER         reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FLOAT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    STRING          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    LEFT_PAREN      reduce using rule 4 (statement2 -> statement SEMICOLON .)
    TRUE            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FALSE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    LOGICAL_NOT     reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RIGHT_BRACE     reduce using rule 4 (statement2 -> statement SEMICOLON .)


state 63

    (71) expression -> expression PLUS . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    expression                     shift and go to state 83
    term                           shift and go to state 135
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 64

    (72) expression -> expression MINUS . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    expression                     shift and go to state 83
    term                           shift and go to state 136
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 65

    (118) relational_expression -> expression relational_operator . expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    expression                     shift and go to state 137
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 66

    (119) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 119 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 119 (relational_operator -> EQUAL_TO .)
    STRING          reduce using rule 119 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 119 (relational_operator -> EQUAL_TO .)
    TRUE            reduce using rule 119 (relational_operator -> EQUAL_TO .)
    FALSE           reduce using rule 119 (relational_operator -> EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 119 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 119 (relational_operator -> EQUAL_TO .)


state 67

    (120) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    STRING          reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    TRUE            reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    FALSE           reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 120 (relational_operator -> NOT_EQUAL_TO .)


state 68

    (121) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 121 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 121 (relational_operator -> LESS_THAN .)
    STRING          reduce using rule 121 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 121 (relational_operator -> LESS_THAN .)
    TRUE            reduce using rule 121 (relational_operator -> LESS_THAN .)
    FALSE           reduce using rule 121 (relational_operator -> LESS_THAN .)
    LOGICAL_NOT     reduce using rule 121 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 121 (relational_operator -> LESS_THAN .)


state 69

    (122) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 122 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 122 (relational_operator -> GREATER_THAN .)
    STRING          reduce using rule 122 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 122 (relational_operator -> GREATER_THAN .)
    TRUE            reduce using rule 122 (relational_operator -> GREATER_THAN .)
    FALSE           reduce using rule 122 (relational_operator -> GREATER_THAN .)
    LOGICAL_NOT     reduce using rule 122 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 122 (relational_operator -> GREATER_THAN .)


state 70

    (123) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    STRING          reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    TRUE            reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    FALSE           reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    LOGICAL_NOT     reduce using rule 123 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 123 (relational_operator -> LESS_EQUAL .)


state 71

    (124) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    STRING          reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    TRUE            reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    FALSE           reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    LOGICAL_NOT     reduce using rule 124 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 124 (relational_operator -> GREATER_EQUAL .)


state 72

    (125) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    STRING          reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    TRUE            reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    FALSE           reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 125 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 125 (relational_operator -> IDENTICAL_TO .)


state 73

    (126) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    STRING          reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    TRUE            reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    FALSE           reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 126 (relational_operator -> NOT_IDENTICAL_TO .)


state 74

    (127) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 127 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 127 (relational_operator -> DIFFERENT .)
    STRING          reduce using rule 127 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 127 (relational_operator -> DIFFERENT .)
    TRUE            reduce using rule 127 (relational_operator -> DIFFERENT .)
    FALSE           reduce using rule 127 (relational_operator -> DIFFERENT .)
    LOGICAL_NOT     reduce using rule 127 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 127 (relational_operator -> DIFFERENT .)


state 75

    (84) if_statement -> IF parenthesized_condition . block
    (85) if_statement -> IF parenthesized_condition . block else_if_extended
    (86) if_statement -> IF parenthesized_condition . block else_if_extended if_part3
    (87) if_statement -> IF parenthesized_condition . block if_part3
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 138

state 76

    (117) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39

    condition                      shift and go to state 91
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58
    expression                     shift and go to state 83
    term                           shift and go to state 45
    factor                         shift and go to state 50

state 77

    (92) while_statement -> WHILE parenthesized_condition . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 140

state 78

    (95) for_statement -> for_part1 condition . for_part3
    (116) complex_condition -> condition . logical_operator condition
    (81) factor -> condition .
    (97) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (98) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (128) logical_operator -> . LOGICAL_AND
    (129) logical_operator -> . LOGICAL_OR
    (130) logical_operator -> . LOGICAL_XOR

    TIMES           reduce using rule 81 (factor -> condition .)
    DIVIDE          reduce using rule 81 (factor -> condition .)
    MOD             reduce using rule 81 (factor -> condition .)
    POWER           reduce using rule 81 (factor -> condition .)
    PLUS            reduce using rule 81 (factor -> condition .)
    MINUS           reduce using rule 81 (factor -> condition .)
    EQUAL_TO        reduce using rule 81 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 81 (factor -> condition .)
    LESS_THAN       reduce using rule 81 (factor -> condition .)
    GREATER_THAN    reduce using rule 81 (factor -> condition .)
    LESS_EQUAL      reduce using rule 81 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 81 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 81 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 81 (factor -> condition .)
    DIFFERENT       reduce using rule 81 (factor -> condition .)
    SEMICOLON       shift and go to state 80
    LOGICAL_AND     shift and go to state 85
    LOGICAL_OR      shift and go to state 86
    LOGICAL_XOR     shift and go to state 87

    for_part3                      shift and go to state 141
    logical_operator               shift and go to state 84

state 79

    (96) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    FUNCTION        reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    CLASS           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    NAME            reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    RETURN          reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    UNSET           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    COUNT           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    INTEGER         reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    FLOAT           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    STRING          reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    LEFT_PAREN      reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    TRUE            reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    FALSE           reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    LOGICAL_NOT     reduce using rule 96 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 96 (for_statement -> for_part1 for_part3 .)


state 80

    (97) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (98) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (103) statement_list -> . statement
    (104) statement_list -> . statement_list COMMA statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . array_indexing
    (22) statement -> . array_add_element
    (23) statement -> . array_modify_element
    (24) statement -> . array_remove_element
    (25) statement -> . array_count_elements
    (26) statement -> . expression
    (53) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> . print_function arguments
    (39) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (134) array_declaration_statement -> . variable EQUALS array
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (35) return_statement -> . RETURN arguments
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> . variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> . variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (146) array_remove_element -> . UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (147) array_count_elements -> . COUNT LEFT_PAREN variable RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (55) print_function -> . PRINT
    (56) print_function -> . ECHO
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 143
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 38
    FGETS           shift and go to state 40
    NAME            shift and go to state 34
    RETURN          shift and go to state 42
    UNSET           shift and go to state 43
    COUNT           shift and go to state 44
    PRINT           shift and go to state 47
    ECHO            shift and go to state 48
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    statement_list                 shift and go to state 142
    statement                      shift and go to state 144
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    array_indexing                 shift and go to state 22
    array_add_element              shift and go to state 23
    array_modify_element           shift and go to state 24
    array_remove_element           shift and go to state 25
    array_count_elements           shift and go to state 26
    expression                     shift and go to state 27
    print_function                 shift and go to state 37
    variable                       shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 81

    (113) simple_condition -> variable .

    SEMICOLON       reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 113 (simple_condition -> variable .)
    TIMES           reduce using rule 113 (simple_condition -> variable .)
    DIVIDE          reduce using rule 113 (simple_condition -> variable .)
    MOD             reduce using rule 113 (simple_condition -> variable .)
    POWER           reduce using rule 113 (simple_condition -> variable .)
    PLUS            reduce using rule 113 (simple_condition -> variable .)
    MINUS           reduce using rule 113 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 113 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 113 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 113 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 113 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 113 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 113 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 113 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 113 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 113 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 113 (simple_condition -> variable .)
    DOT             reduce using rule 113 (simple_condition -> variable .)
    COMMA           reduce using rule 113 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 113 (simple_condition -> variable .)


state 82

    (117) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (83) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39

    condition                      shift and go to state 91
    expression                     shift and go to state 90
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    term                           shift and go to state 45
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58
    factor                         shift and go to state 50

state 83

    (118) relational_expression -> expression . relational_operator expression
    (71) expression -> expression . PLUS term
    (72) expression -> expression . MINUS term
    (119) relational_operator -> . EQUAL_TO
    (120) relational_operator -> . NOT_EQUAL_TO
    (121) relational_operator -> . LESS_THAN
    (122) relational_operator -> . GREATER_THAN
    (123) relational_operator -> . LESS_EQUAL
    (124) relational_operator -> . GREATER_EQUAL
    (125) relational_operator -> . IDENTICAL_TO
    (126) relational_operator -> . NOT_IDENTICAL_TO
    (127) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL_TO    shift and go to state 67
    LESS_THAN       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    IDENTICAL_TO    shift and go to state 72
    NOT_IDENTICAL_TO shift and go to state 73
    DIFFERENT       shift and go to state 74

    relational_operator            shift and go to state 65

state 84

    (116) complex_condition -> condition logical_operator . condition
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39

    condition                      shift and go to state 145
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58
    expression                     shift and go to state 83
    term                           shift and go to state 45
    factor                         shift and go to state 50

state 85

    (128) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 128 (logical_operator -> LOGICAL_AND .)
    STRING          reduce using rule 128 (logical_operator -> LOGICAL_AND .)


state 86

    (129) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 129 (logical_operator -> LOGICAL_OR .)
    STRING          reduce using rule 129 (logical_operator -> LOGICAL_OR .)


state 87

    (130) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 130 (logical_operator -> LOGICAL_XOR .)
    STRING          reduce using rule 130 (logical_operator -> LOGICAL_XOR .)


state 88

    (27) function_statement -> FUNCTION NAME . LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> FUNCTION NAME . LEFT_PAREN RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 146


state 89

    (36) function_call -> NAME LEFT_PAREN . arguments RIGHT_PAREN
    (37) function_call -> NAME LEFT_PAREN . RIGHT_PAREN
    (57) arguments -> . argument
    (58) arguments -> . arguments DOT argument
    (59) arguments -> . arguments COMMA argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 148
    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    arguments                      shift and go to state 147
    argument                       shift and go to state 95
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 90

    (83) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (71) expression -> expression . PLUS term
    (72) expression -> expression . MINUS term
    (118) relational_expression -> expression . relational_operator expression
    (119) relational_operator -> . EQUAL_TO
    (120) relational_operator -> . NOT_EQUAL_TO
    (121) relational_operator -> . LESS_THAN
    (122) relational_operator -> . GREATER_THAN
    (123) relational_operator -> . LESS_EQUAL
    (124) relational_operator -> . GREATER_EQUAL
    (125) relational_operator -> . IDENTICAL_TO
    (126) relational_operator -> . NOT_IDENTICAL_TO
    (127) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 149
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL_TO    shift and go to state 67
    LESS_THAN       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    IDENTICAL_TO    shift and go to state 72
    NOT_IDENTICAL_TO shift and go to state 73
    DIFFERENT       shift and go to state 74

    relational_operator            shift and go to state 65

state 91

    (117) parenthesized_condition -> LEFT_PAREN condition . RIGHT_PAREN
    (116) complex_condition -> condition . logical_operator condition
    (81) factor -> condition .
    (128) logical_operator -> . LOGICAL_AND
    (129) logical_operator -> . LOGICAL_OR
    (130) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 150
    TIMES           reduce using rule 81 (factor -> condition .)
    DIVIDE          reduce using rule 81 (factor -> condition .)
    MOD             reduce using rule 81 (factor -> condition .)
    POWER           reduce using rule 81 (factor -> condition .)
    PLUS            reduce using rule 81 (factor -> condition .)
    MINUS           reduce using rule 81 (factor -> condition .)
    EQUAL_TO        reduce using rule 81 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 81 (factor -> condition .)
    LESS_THAN       reduce using rule 81 (factor -> condition .)
    GREATER_THAN    reduce using rule 81 (factor -> condition .)
    LESS_EQUAL      reduce using rule 81 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 81 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 81 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 81 (factor -> condition .)
    DIFFERENT       reduce using rule 81 (factor -> condition .)
    DOT             reduce using rule 81 (factor -> condition .)
    COMMA           reduce using rule 81 (factor -> condition .)
    LOGICAL_AND     shift and go to state 85
    LOGICAL_OR      shift and go to state 86
    LOGICAL_XOR     shift and go to state 87

  ! RIGHT_PAREN     [ reduce using rule 81 (factor -> condition .) ]

    logical_operator               shift and go to state 84

state 92

    (148) class_declaration -> CLASS NAME . LEFT_BRACE class_statements RIGHT_BRACE
    (149) class_declaration -> CLASS NAME . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 151


state 93

    (53) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (131) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (83) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (117) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (57) arguments -> . argument
    (58) arguments -> . arguments DOT argument
    (59) arguments -> . arguments COMMA argument
    (132) casting_type -> . INT_TYPE
    (133) casting_type -> . FLOAT_TYPE
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 156
    FLOAT_TYPE      shift and go to state 157
    STRING          shift and go to state 96
    ID              shift and go to state 101
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 152
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52

    arguments                      shift and go to state 153
    casting_type                   shift and go to state 154
    expression                     shift and go to state 155
    condition                      shift and go to state 91
    argument                       shift and go to state 95
    term                           shift and go to state 45
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    factor                         shift and go to state 50
    variable                       shift and go to state 158
    relational_expression          shift and go to state 58

state 94

    (54) print_statement -> print_function arguments .
    (58) arguments -> arguments . DOT argument
    (59) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 54 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 54 (print_statement -> print_function arguments .)
    DOT             shift and go to state 159
    COMMA           shift and go to state 160

  ! COMMA           [ reduce using rule 54 (print_statement -> print_function arguments .) ]


state 95

    (57) arguments -> argument .

    DOT             reduce using rule 57 (arguments -> argument .)
    COMMA           reduce using rule 57 (arguments -> argument .)
    SEMICOLON       reduce using rule 57 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 57 (arguments -> argument .)


state 96

    (60) argument -> STRING .
    (82) factor -> STRING .

  ! reduce/reduce conflict for DOT resolved using rule 60 (argument -> STRING .)
  ! reduce/reduce conflict for COMMA resolved using rule 60 (argument -> STRING .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 60 (argument -> STRING .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 60 (argument -> STRING .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 60 (argument -> STRING .)
    DOT             reduce using rule 60 (argument -> STRING .)
    COMMA           reduce using rule 60 (argument -> STRING .)
    SEMICOLON       reduce using rule 60 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 60 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 60 (argument -> STRING .)
    TIMES           reduce using rule 82 (factor -> STRING .)
    DIVIDE          reduce using rule 82 (factor -> STRING .)
    MOD             reduce using rule 82 (factor -> STRING .)
    POWER           reduce using rule 82 (factor -> STRING .)
    PLUS            reduce using rule 82 (factor -> STRING .)
    MINUS           reduce using rule 82 (factor -> STRING .)
    EQUAL_TO        reduce using rule 82 (factor -> STRING .)
    NOT_EQUAL_TO    reduce using rule 82 (factor -> STRING .)
    LESS_THAN       reduce using rule 82 (factor -> STRING .)
    GREATER_THAN    reduce using rule 82 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 82 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 82 (factor -> STRING .)
    IDENTICAL_TO    reduce using rule 82 (factor -> STRING .)
    NOT_IDENTICAL_TO reduce using rule 82 (factor -> STRING .)
    DIFFERENT       reduce using rule 82 (factor -> STRING .)

  ! DOT             [ reduce using rule 82 (factor -> STRING .) ]
  ! COMMA           [ reduce using rule 82 (factor -> STRING .) ]
  ! SEMICOLON       [ reduce using rule 82 (factor -> STRING .) ]
  ! RIGHT_PAREN     [ reduce using rule 82 (factor -> STRING .) ]
  ! RIGHT_BRACKET   [ reduce using rule 82 (factor -> STRING .) ]


state 97

    (61) argument -> expression .
    (71) expression -> expression . PLUS term
    (72) expression -> expression . MINUS term
    (118) relational_expression -> expression . relational_operator expression
    (119) relational_operator -> . EQUAL_TO
    (120) relational_operator -> . NOT_EQUAL_TO
    (121) relational_operator -> . LESS_THAN
    (122) relational_operator -> . GREATER_THAN
    (123) relational_operator -> . LESS_EQUAL
    (124) relational_operator -> . GREATER_EQUAL
    (125) relational_operator -> . IDENTICAL_TO
    (126) relational_operator -> . NOT_IDENTICAL_TO
    (127) relational_operator -> . DIFFERENT

    DOT             reduce using rule 61 (argument -> expression .)
    COMMA           reduce using rule 61 (argument -> expression .)
    SEMICOLON       reduce using rule 61 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 61 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 61 (argument -> expression .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL_TO    shift and go to state 67
    LESS_THAN       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    IDENTICAL_TO    shift and go to state 72
    NOT_IDENTICAL_TO shift and go to state 73
    DIFFERENT       shift and go to state 74

    relational_operator            shift and go to state 65

state 98

    (62) argument -> array .

    DOT             reduce using rule 62 (argument -> array .)
    COMMA           reduce using rule 62 (argument -> array .)
    SEMICOLON       reduce using rule 62 (argument -> array .)
    RIGHT_PAREN     reduce using rule 62 (argument -> array .)
    RIGHT_BRACKET   reduce using rule 62 (argument -> array .)


state 99

    (63) argument -> array_indexing .

    DOT             reduce using rule 63 (argument -> array_indexing .)
    COMMA           reduce using rule 63 (argument -> array_indexing .)
    SEMICOLON       reduce using rule 63 (argument -> array_indexing .)
    RIGHT_PAREN     reduce using rule 63 (argument -> array_indexing .)
    RIGHT_BRACKET   reduce using rule 63 (argument -> array_indexing .)


state 100

    (64) argument -> function_call .

    DOT             reduce using rule 64 (argument -> function_call .)
    COMMA           reduce using rule 64 (argument -> function_call .)
    SEMICOLON       reduce using rule 64 (argument -> function_call .)
    RIGHT_PAREN     reduce using rule 64 (argument -> function_call .)
    RIGHT_BRACKET   reduce using rule 64 (argument -> function_call .)


state 101

    (65) argument -> ID . CALL function_call
    (42) variable -> ID .
    (43) variable -> ID . CALL NAME

    CALL            shift and go to state 161
    LEFT_BRACKET    reduce using rule 42 (variable -> ID .)
    PLUS_PLUS       reduce using rule 42 (variable -> ID .)
    MINUS_MINUS     reduce using rule 42 (variable -> ID .)
    EQUALS          reduce using rule 42 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 42 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 42 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 42 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 42 (variable -> ID .)
    MOD_EQUALS      reduce using rule 42 (variable -> ID .)
    LOGICAL_AND     reduce using rule 42 (variable -> ID .)
    LOGICAL_OR      reduce using rule 42 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 42 (variable -> ID .)
    TIMES           reduce using rule 42 (variable -> ID .)
    DIVIDE          reduce using rule 42 (variable -> ID .)
    MOD             reduce using rule 42 (variable -> ID .)
    POWER           reduce using rule 42 (variable -> ID .)
    PLUS            reduce using rule 42 (variable -> ID .)
    MINUS           reduce using rule 42 (variable -> ID .)
    EQUAL_TO        reduce using rule 42 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 42 (variable -> ID .)
    LESS_THAN       reduce using rule 42 (variable -> ID .)
    GREATER_THAN    reduce using rule 42 (variable -> ID .)
    LESS_EQUAL      reduce using rule 42 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 42 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 42 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 42 (variable -> ID .)
    DIFFERENT       reduce using rule 42 (variable -> ID .)
    DOT             reduce using rule 42 (variable -> ID .)
    COMMA           reduce using rule 42 (variable -> ID .)
    SEMICOLON       reduce using rule 42 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 42 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 42 (variable -> ID .)


state 102

    (66) argument -> anonymous_function .

    DOT             reduce using rule 66 (argument -> anonymous_function .)
    COMMA           reduce using rule 66 (argument -> anonymous_function .)
    SEMICOLON       reduce using rule 66 (argument -> anonymous_function .)
    RIGHT_PAREN     reduce using rule 66 (argument -> anonymous_function .)
    RIGHT_BRACKET   reduce using rule 66 (argument -> anonymous_function .)


state 103

    (67) argument -> assignment_statement .

    DOT             reduce using rule 67 (argument -> assignment_statement .)
    COMMA           reduce using rule 67 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 67 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 67 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 67 (argument -> assignment_statement .)


state 104

    (68) argument -> fgets_statement .

    DOT             reduce using rule 68 (argument -> fgets_statement .)
    COMMA           reduce using rule 68 (argument -> fgets_statement .)
    SEMICOLON       reduce using rule 68 (argument -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 68 (argument -> fgets_statement .)
    RIGHT_BRACKET   reduce using rule 68 (argument -> fgets_statement .)


state 105

    (69) argument -> object_creation .

    DOT             reduce using rule 69 (argument -> object_creation .)
    COMMA           reduce using rule 69 (argument -> object_creation .)
    SEMICOLON       reduce using rule 69 (argument -> object_creation .)
    RIGHT_PAREN     reduce using rule 69 (argument -> object_creation .)
    RIGHT_BRACKET   reduce using rule 69 (argument -> object_creation .)


state 106

    (70) argument -> casting . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    casting                        shift and go to state 106
    argument                       shift and go to state 162
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 107

    (135) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 163


state 108

    (136) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (137) array_elements -> . array_argument
    (138) array_elements -> . array_elements COMMA array_argument
    (139) array_argument -> . argument
    (140) array_argument -> . clave KEY_VALUE argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (141) clave -> . STRING
    (142) clave -> . INTEGER
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 168
    ID              shift and go to state 101
    INTEGER         shift and go to state 169
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    array_elements                 shift and go to state 164
    array_argument                 shift and go to state 165
    argument                       shift and go to state 166
    clave                          shift and go to state 167
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 109

    (143) array_indexing -> variable . LEFT_BRACKET clave RIGHT_BRACKET
    (44) assignment_statement -> variable . assignment_operator argument
    (45) assignment_statement -> variable . PLUS_PLUS
    (46) assignment_statement -> variable . MINUS_MINUS
    (113) simple_condition -> variable .
    (47) assignment_operator -> . EQUALS
    (48) assignment_operator -> . PLUS_EQUALS
    (49) assignment_operator -> . MINUS_EQUALS
    (50) assignment_operator -> . TIMES_EQUALS
    (51) assignment_operator -> . DIVIDE_EQUALS
    (52) assignment_operator -> . MOD_EQUALS

    LEFT_BRACKET    shift and go to state 170
    PLUS_PLUS       shift and go to state 115
    MINUS_MINUS     shift and go to state 116
    LOGICAL_AND     reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 113 (simple_condition -> variable .)
    TIMES           reduce using rule 113 (simple_condition -> variable .)
    DIVIDE          reduce using rule 113 (simple_condition -> variable .)
    MOD             reduce using rule 113 (simple_condition -> variable .)
    POWER           reduce using rule 113 (simple_condition -> variable .)
    PLUS            reduce using rule 113 (simple_condition -> variable .)
    MINUS           reduce using rule 113 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 113 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 113 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 113 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 113 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 113 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 113 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 113 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 113 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 113 (simple_condition -> variable .)
    DOT             reduce using rule 113 (simple_condition -> variable .)
    COMMA           reduce using rule 113 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 113 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 113 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 113 (simple_condition -> variable .)
    EQUALS          shift and go to state 171
    PLUS_EQUALS     shift and go to state 119
    MINUS_EQUALS    shift and go to state 120
    TIMES_EQUALS    shift and go to state 121
    DIVIDE_EQUALS   shift and go to state 122
    MOD_EQUALS      shift and go to state 123

    assignment_operator            shift and go to state 114

state 110

    (29) anonymous_function -> FUNCTION . LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> FUNCTION . LEFT_PAREN RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 172


state 111

    (161) object_creation -> NEW . NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> NEW . NAME LEFT_PAREN arguments RIGHT_PAREN

    NAME            shift and go to state 173


state 112

    (39) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 174


state 113

    (38) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 175


state 114

    (44) assignment_statement -> variable assignment_operator . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    variable                       shift and go to state 109
    argument                       shift and go to state 176
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 115

    (45) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 45 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 45 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 45 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 45 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 45 (assignment_statement -> variable PLUS_PLUS .)


state 116

    (46) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 46 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 46 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 46 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 46 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 46 (assignment_statement -> variable MINUS_MINUS .)


state 117

    (134) array_declaration_statement -> variable EQUALS . array
    (47) assignment_operator -> EQUALS .
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for LEFT_BRACKET resolved as shift
    STRING          reduce using rule 47 (assignment_operator -> EQUALS .)
    ID              reduce using rule 47 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 47 (assignment_operator -> EQUALS .)
    FUNCTION        reduce using rule 47 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 47 (assignment_operator -> EQUALS .)
    NEW             reduce using rule 47 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 47 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 47 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 47 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 47 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 47 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 47 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108

  ! ARRAY           [ reduce using rule 47 (assignment_operator -> EQUALS .) ]
  ! LEFT_BRACKET    [ reduce using rule 47 (assignment_operator -> EQUALS .) ]

    array                          shift and go to state 177

state 118

    (143) array_indexing -> variable LEFT_BRACKET . clave RIGHT_BRACKET
    (144) array_add_element -> variable LEFT_BRACKET . RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> variable LEFT_BRACKET . clave RIGHT_BRACKET EQUALS argument
    (141) clave -> . STRING
    (142) clave -> . INTEGER

    RIGHT_BRACKET   shift and go to state 179
    STRING          shift and go to state 180
    INTEGER         shift and go to state 181

    clave                          shift and go to state 178

state 119

    (48) assignment_operator -> PLUS_EQUALS .

    STRING          reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    ARRAY           reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    LEFT_BRACKET    reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    NAME            reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    FUNCTION        reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    FGETS           reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    NEW             reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    INTEGER         reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 48 (assignment_operator -> PLUS_EQUALS .)


state 120

    (49) assignment_operator -> MINUS_EQUALS .

    STRING          reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    ARRAY           reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    LEFT_BRACKET    reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    NAME            reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    FUNCTION        reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    FGETS           reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    NEW             reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    INTEGER         reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 49 (assignment_operator -> MINUS_EQUALS .)


state 121

    (50) assignment_operator -> TIMES_EQUALS .

    STRING          reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    ARRAY           reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    LEFT_BRACKET    reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    NAME            reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    FUNCTION        reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    FGETS           reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    NEW             reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    INTEGER         reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 50 (assignment_operator -> TIMES_EQUALS .)


state 122

    (51) assignment_operator -> DIVIDE_EQUALS .

    STRING          reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    ARRAY           reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_BRACKET    reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    NAME            reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    FUNCTION        reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    FGETS           reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    NEW             reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    INTEGER         reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 51 (assignment_operator -> DIVIDE_EQUALS .)


state 123

    (52) assignment_operator -> MOD_EQUALS .

    STRING          reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    ARRAY           reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    LEFT_BRACKET    reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    NAME            reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    FUNCTION        reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    FGETS           reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    NEW             reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    INTEGER         reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 52 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 52 (assignment_operator -> MOD_EQUALS .)


state 124

    (35) return_statement -> RETURN arguments .
    (58) arguments -> arguments . DOT argument
    (59) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 35 (return_statement -> RETURN arguments .)
    RIGHT_PAREN     reduce using rule 35 (return_statement -> RETURN arguments .)
    DOT             shift and go to state 159
    COMMA           shift and go to state 160

  ! COMMA           [ reduce using rule 35 (return_statement -> RETURN arguments .) ]


state 125

    (131) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (83) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (117) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (132) casting_type -> . INT_TYPE
    (133) casting_type -> . FLOAT_TYPE
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 156
    FLOAT_TYPE      shift and go to state 157
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    ID              shift and go to state 49

    casting_type                   shift and go to state 154
    expression                     shift and go to state 90
    condition                      shift and go to state 91
    term                           shift and go to state 45
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    factor                         shift and go to state 50
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 126

    (146) array_remove_element -> UNSET LEFT_PAREN . variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    ID              shift and go to state 49

    variable                       shift and go to state 182

state 127

    (147) array_count_elements -> COUNT LEFT_PAREN . variable RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    ID              shift and go to state 49

    variable                       shift and go to state 183

state 128

    (74) term -> term TIMES . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    term                           shift and go to state 45
    factor                         shift and go to state 184
    condition                      shift and go to state 32
    expression                     shift and go to state 83
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 129

    (75) term -> term DIVIDE . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    term                           shift and go to state 45
    factor                         shift and go to state 185
    condition                      shift and go to state 32
    expression                     shift and go to state 83
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 130

    (76) term -> term MOD . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    term                           shift and go to state 45
    factor                         shift and go to state 186
    condition                      shift and go to state 32
    expression                     shift and go to state 83
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 131

    (77) term -> term POWER . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    ID              shift and go to state 49

    term                           shift and go to state 45
    factor                         shift and go to state 187
    condition                      shift and go to state 32
    expression                     shift and go to state 83
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58

state 132

    (93) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (94) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (101) assignment_list -> . assignment_statement
    (102) assignment_list -> . assignment_list COMMA assignment_statement
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    SEMICOLON       shift and go to state 189
    ID              shift and go to state 49

    assignment_list                shift and go to state 188
    assignment_statement           shift and go to state 190
    variable                       shift and go to state 191

state 133

    (43) variable -> ID CALL . NAME

    NAME            shift and go to state 192


state 134

    (115) negated_condition -> LOGICAL_NOT condition .
    (116) complex_condition -> condition . logical_operator condition
    (81) factor -> condition .
    (128) logical_operator -> . LOGICAL_AND
    (129) logical_operator -> . LOGICAL_OR
    (130) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for MOD resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 81 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .)
    TIMES           reduce using rule 81 (factor -> condition .)
    DIVIDE          reduce using rule 81 (factor -> condition .)
    MOD             reduce using rule 81 (factor -> condition .)
    POWER           reduce using rule 81 (factor -> condition .)
    PLUS            reduce using rule 81 (factor -> condition .)
    MINUS           reduce using rule 81 (factor -> condition .)
    EQUAL_TO        reduce using rule 81 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 81 (factor -> condition .)
    LESS_THAN       reduce using rule 81 (factor -> condition .)
    GREATER_THAN    reduce using rule 81 (factor -> condition .)
    LESS_EQUAL      reduce using rule 81 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 81 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 81 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 81 (factor -> condition .)
    DIFFERENT       reduce using rule 81 (factor -> condition .)
    LOGICAL_AND     shift and go to state 85
    LOGICAL_OR      shift and go to state 86
    LOGICAL_XOR     shift and go to state 87

  ! LOGICAL_AND     [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! TIMES           [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIVIDE          [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MOD             [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! POWER           [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! PLUS            [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MINUS           [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! EQUAL_TO        [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_THAN       [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_THAN    [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIFFERENT       [ reduce using rule 115 (negated_condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 84

state 135

    (71) expression -> expression PLUS term .
    (74) term -> term . TIMES factor
    (75) term -> term . DIVIDE factor
    (76) term -> term . MOD factor
    (77) term -> term . POWER factor
    (73) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 71 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 71 (expression -> expression PLUS term .)
    PLUS            reduce using rule 71 (expression -> expression PLUS term .)
    MINUS           reduce using rule 71 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 71 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 71 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 71 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 71 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 71 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 71 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 71 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 71 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 71 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 71 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 71 (expression -> expression PLUS term .)
    DOT             reduce using rule 71 (expression -> expression PLUS term .)
    COMMA           reduce using rule 71 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 71 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 71 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 71 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 71 (expression -> expression PLUS term .)
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    MOD             shift and go to state 130
    POWER           shift and go to state 131

  ! TIMES           [ reduce using rule 71 (expression -> expression PLUS term .) ]
  ! DIVIDE          [ reduce using rule 71 (expression -> expression PLUS term .) ]
  ! MOD             [ reduce using rule 71 (expression -> expression PLUS term .) ]
  ! POWER           [ reduce using rule 71 (expression -> expression PLUS term .) ]
  ! PLUS            [ reduce using rule 73 (expression -> term .) ]
  ! MINUS           [ reduce using rule 73 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 73 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 73 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 73 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 73 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 73 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 73 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 73 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 73 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 73 (expression -> term .) ]


state 136

    (72) expression -> expression MINUS term .
    (74) term -> term . TIMES factor
    (75) term -> term . DIVIDE factor
    (76) term -> term . MOD factor
    (77) term -> term . POWER factor
    (73) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 72 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 72 (expression -> expression MINUS term .)
    PLUS            reduce using rule 72 (expression -> expression MINUS term .)
    MINUS           reduce using rule 72 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 72 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 72 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 72 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 72 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 72 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 72 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 72 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 72 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 72 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 72 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 72 (expression -> expression MINUS term .)
    DOT             reduce using rule 72 (expression -> expression MINUS term .)
    COMMA           reduce using rule 72 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 72 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 72 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 72 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 72 (expression -> expression MINUS term .)
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    MOD             shift and go to state 130
    POWER           shift and go to state 131

  ! TIMES           [ reduce using rule 72 (expression -> expression MINUS term .) ]
  ! DIVIDE          [ reduce using rule 72 (expression -> expression MINUS term .) ]
  ! MOD             [ reduce using rule 72 (expression -> expression MINUS term .) ]
  ! POWER           [ reduce using rule 72 (expression -> expression MINUS term .) ]
  ! PLUS            [ reduce using rule 73 (expression -> term .) ]
  ! MINUS           [ reduce using rule 73 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 73 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 73 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 73 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 73 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 73 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 73 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 73 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 73 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 73 (expression -> term .) ]


state 137

    (118) relational_expression -> expression relational_operator expression .
    (71) expression -> expression . PLUS term
    (72) expression -> expression . MINUS term
    (118) relational_expression -> expression . relational_operator expression
    (119) relational_operator -> . EQUAL_TO
    (120) relational_operator -> . NOT_EQUAL_TO
    (121) relational_operator -> . LESS_THAN
    (122) relational_operator -> . GREATER_THAN
    (123) relational_operator -> . LESS_EQUAL
    (124) relational_operator -> . GREATER_EQUAL
    (125) relational_operator -> . IDENTICAL_TO
    (126) relational_operator -> . NOT_IDENTICAL_TO
    (127) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL_TO resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for NOT_IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    LOGICAL_AND     reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    TIMES           reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    DIVIDE          reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    MOD             reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    POWER           reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    SEMICOLON       reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    DOT             reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    COMMA           reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 118 (relational_expression -> expression relational_operator expression .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL_TO    shift and go to state 67
    LESS_THAN       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    IDENTICAL_TO    shift and go to state 72
    NOT_IDENTICAL_TO shift and go to state 73
    DIFFERENT       shift and go to state 74

  ! PLUS            [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! MINUS           [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! EQUAL_TO        [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_THAN       [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_THAN    [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_EQUAL      [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! IDENTICAL_TO    [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]
  ! DIFFERENT       [ reduce using rule 118 (relational_expression -> expression relational_operator expression .) ]

    relational_operator            shift and go to state 65

state 138

    (84) if_statement -> IF parenthesized_condition block .
    (85) if_statement -> IF parenthesized_condition block . else_if_extended
    (86) if_statement -> IF parenthesized_condition block . else_if_extended if_part3
    (87) if_statement -> IF parenthesized_condition block . if_part3
    (88) else_if_extended -> . if_part2
    (89) else_if_extended -> . else_if_extended if_part2
    (91) if_part3 -> . ELSE block
    (90) if_part2 -> . ELSEIF parenthesized_condition block

    CLOSE_TAG       reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    BREAK           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    CONTINUE        reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    IF              reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    WHILE           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    FUNCTION        reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    CLASS           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    FSCANF          reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    FGETS           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    NAME            reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    RETURN          reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    UNSET           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    COUNT           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    FOR             reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    PRINT           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    ECHO            reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    ID              reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    INTEGER         reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    FLOAT           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    STRING          reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    TRUE            reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    FALSE           reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 84 (if_statement -> IF parenthesized_condition block .)
    ELSE            shift and go to state 196
    ELSEIF          shift and go to state 197

    else_if_extended               shift and go to state 193
    if_part3                       shift and go to state 194
    if_part2                       shift and go to state 195

state 139

    (105) block -> LEFT_BRACE . statements RIGHT_BRACE
    (106) block -> LEFT_BRACE . RIGHT_BRACE
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . array_indexing
    (22) statement -> . array_add_element
    (23) statement -> . array_modify_element
    (24) statement -> . array_remove_element
    (25) statement -> . array_count_elements
    (26) statement -> . expression
    (84) if_statement -> . IF parenthesized_condition block
    (85) if_statement -> . IF parenthesized_condition block else_if_extended
    (86) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (87) if_statement -> . IF parenthesized_condition block if_part3
    (92) while_statement -> . WHILE parenthesized_condition block
    (95) for_statement -> . for_part1 condition for_part3
    (96) for_statement -> . for_part1 for_part3
    (27) function_statement -> . FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (148) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (149) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (53) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> . print_function arguments
    (39) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (134) array_declaration_statement -> . variable EQUALS array
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (35) return_statement -> . RETURN arguments
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> . variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> . variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (146) array_remove_element -> . UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (147) array_count_elements -> . COUNT LEFT_PAREN variable RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (93) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (94) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (55) print_function -> . PRINT
    (56) print_function -> . ECHO
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    RIGHT_BRACE     shift and go to state 199
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 28
    WHILE           shift and go to state 30
    FUNCTION        shift and go to state 33
    CLASS           shift and go to state 36
    FSCANF          shift and go to state 38
    FGETS           shift and go to state 40
    NAME            shift and go to state 34
    RETURN          shift and go to state 42
    UNSET           shift and go to state 43
    COUNT           shift and go to state 44
    FOR             shift and go to state 46
    PRINT           shift and go to state 47
    ECHO            shift and go to state 48
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    statements                     shift and go to state 198
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    array_indexing                 shift and go to state 22
    array_add_element              shift and go to state 23
    array_modify_element           shift and go to state 24
    array_remove_element           shift and go to state 25
    array_count_elements           shift and go to state 26
    expression                     shift and go to state 27
    parenthesized_condition        shift and go to state 29
    for_part1                      shift and go to state 31
    condition                      shift and go to state 32
    print_function                 shift and go to state 37
    variable                       shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 50
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    relational_expression          shift and go to state 58

state 140

    (92) while_statement -> WHILE parenthesized_condition block .

    CLOSE_TAG       reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    BREAK           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    CONTINUE        reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    IF              reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    WHILE           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    FUNCTION        reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    CLASS           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    FSCANF          reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    FGETS           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    NAME            reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    RETURN          reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    UNSET           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    COUNT           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    FOR             reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    PRINT           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    ECHO            reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    ID              reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    INTEGER         reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    FLOAT           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    STRING          reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    TRUE            reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    FALSE           reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 92 (while_statement -> WHILE parenthesized_condition block .)


state 141

    (95) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    FUNCTION        reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    CLASS           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    NAME            reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    RETURN          reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    UNSET           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    COUNT           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    INTEGER         reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    FLOAT           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    STRING          reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    LEFT_PAREN      reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    TRUE            reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    FALSE           reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    LOGICAL_NOT     reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 95 (for_statement -> for_part1 condition for_part3 .)


state 142

    (97) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (104) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 200
    COMMA           shift and go to state 201


state 143

    (98) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (99) for_part4 -> . block
    (100) for_part4 -> . SEMICOLON
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 202
    LEFT_BRACE      shift and go to state 139

    for_part4                      shift and go to state 203
    block                          shift and go to state 204

state 144

    (103) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 103 (statement_list -> statement .)
    COMMA           reduce using rule 103 (statement_list -> statement .)


state 145

    (116) complex_condition -> condition logical_operator condition .
    (116) complex_condition -> condition . logical_operator condition
    (81) factor -> condition .
    (128) logical_operator -> . LOGICAL_AND
    (129) logical_operator -> . LOGICAL_OR
    (130) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for MOD resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 81 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 81 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 116 (complex_condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 116 (complex_condition -> condition logical_operator condition .)
    DOT             reduce using rule 116 (complex_condition -> condition logical_operator condition .)
    COMMA           reduce using rule 116 (complex_condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 116 (complex_condition -> condition logical_operator condition .)
    TIMES           reduce using rule 81 (factor -> condition .)
    DIVIDE          reduce using rule 81 (factor -> condition .)
    MOD             reduce using rule 81 (factor -> condition .)
    POWER           reduce using rule 81 (factor -> condition .)
    PLUS            reduce using rule 81 (factor -> condition .)
    MINUS           reduce using rule 81 (factor -> condition .)
    EQUAL_TO        reduce using rule 81 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 81 (factor -> condition .)
    LESS_THAN       reduce using rule 81 (factor -> condition .)
    GREATER_THAN    reduce using rule 81 (factor -> condition .)
    LESS_EQUAL      reduce using rule 81 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 81 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 81 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 81 (factor -> condition .)
    DIFFERENT       reduce using rule 81 (factor -> condition .)
    LOGICAL_AND     shift and go to state 85
    LOGICAL_OR      shift and go to state 86
    LOGICAL_XOR     shift and go to state 87

  ! LOGICAL_AND     [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! TIMES           [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! DIVIDE          [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! MOD             [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! POWER           [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! PLUS            [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! MINUS           [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! EQUAL_TO        [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_THAN       [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_THAN    [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_EQUAL      [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]
  ! DIFFERENT       [ reduce using rule 116 (complex_condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 84

state 146

    (27) function_statement -> FUNCTION NAME LEFT_PAREN . parameters RIGHT_PAREN block
    (28) function_statement -> FUNCTION NAME LEFT_PAREN . RIGHT_PAREN block
    (31) parameters -> . parameter
    (32) parameters -> . parameters COMMA parameter
    (33) parameter -> . variable
    (34) parameter -> . variable EQUALS argument
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    RIGHT_PAREN     shift and go to state 206
    ID              shift and go to state 49

    parameters                     shift and go to state 205
    parameter                      shift and go to state 207
    variable                       shift and go to state 208

state 147

    (36) function_call -> NAME LEFT_PAREN arguments . RIGHT_PAREN
    (58) arguments -> arguments . DOT argument
    (59) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 209
    DOT             shift and go to state 159
    COMMA           shift and go to state 160


state 148

    (37) function_call -> NAME LEFT_PAREN RIGHT_PAREN .

    SEMICOLON       reduce using rule 37 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    DOT             reduce using rule 37 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    COMMA           reduce using rule 37 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 37 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 37 (function_call -> NAME LEFT_PAREN RIGHT_PAREN .)


state 149

    (83) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MOD             reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    POWER           reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 83 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 150

    (117) parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .

    LOGICAL_AND     reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    TIMES           reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIVIDE          reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MOD             reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    POWER           reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    PLUS            reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MINUS           reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_THAN       reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIFFERENT       reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    SEMICOLON       reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 117 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 151

    (148) class_declaration -> CLASS NAME LEFT_BRACE . class_statements RIGHT_BRACE
    (149) class_declaration -> CLASS NAME LEFT_BRACE . RIGHT_BRACE
    (150) class_statements -> . class_statement
    (151) class_statements -> . class_statements class_statement
    (152) class_statement -> . method_declaration
    (153) class_statement -> . property_declaration
    (154) class_statement -> . ONE_LINE_COMMENT
    (155) class_statement -> . MULTI_LINE_COMMENT
    (156) method_declaration -> . visibility_operator function_statement
    (157) property_declaration -> . visibility_operator variable SEMICOLON
    (158) visibility_operator -> . PUBLIC
    (159) visibility_operator -> . PRIVATE
    (160) visibility_operator -> . PROTECTED

    RIGHT_BRACE     shift and go to state 211
    ONE_LINE_COMMENT shift and go to state 215
    MULTI_LINE_COMMENT shift and go to state 216
    PUBLIC          shift and go to state 218
    PRIVATE         shift and go to state 219
    PROTECTED       shift and go to state 220

    class_statements               shift and go to state 210
    class_statement                shift and go to state 212
    method_declaration             shift and go to state 213
    property_declaration           shift and go to state 214
    visibility_operator            shift and go to state 217

state 152

    (117) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (131) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (83) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (132) casting_type -> . INT_TYPE
    (133) casting_type -> . FLOAT_TYPE
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (118) relational_expression -> . expression relational_operator expression
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INT_TYPE        shift and go to state 156
    FLOAT_TYPE      shift and go to state 157
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59
    LEFT_PAREN      shift and go to state 82
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39

    condition                      shift and go to state 91
    casting_type                   shift and go to state 154
    expression                     shift and go to state 90
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    term                           shift and go to state 45
    variable                       shift and go to state 81
    relational_expression          shift and go to state 58
    factor                         shift and go to state 50

state 153

    (53) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (58) arguments -> arguments . DOT argument
    (59) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 221
    DOT             shift and go to state 159
    COMMA           shift and go to state 160


state 154

    (131) casting -> LEFT_PAREN casting_type . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 222


state 155

    (83) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (71) expression -> expression . PLUS term
    (72) expression -> expression . MINUS term
    (61) argument -> expression .
    (118) relational_expression -> expression . relational_operator expression
    (119) relational_operator -> . EQUAL_TO
    (120) relational_operator -> . NOT_EQUAL_TO
    (121) relational_operator -> . LESS_THAN
    (122) relational_operator -> . GREATER_THAN
    (123) relational_operator -> . LESS_EQUAL
    (124) relational_operator -> . GREATER_EQUAL
    (125) relational_operator -> . IDENTICAL_TO
    (126) relational_operator -> . NOT_IDENTICAL_TO
    (127) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 149
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    DOT             reduce using rule 61 (argument -> expression .)
    COMMA           reduce using rule 61 (argument -> expression .)
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL_TO    shift and go to state 67
    LESS_THAN       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    IDENTICAL_TO    shift and go to state 72
    NOT_IDENTICAL_TO shift and go to state 73
    DIFFERENT       shift and go to state 74

  ! RIGHT_PAREN     [ reduce using rule 61 (argument -> expression .) ]

    relational_operator            shift and go to state 65

state 156

    (132) casting_type -> INT_TYPE .

    RIGHT_PAREN     reduce using rule 132 (casting_type -> INT_TYPE .)


state 157

    (133) casting_type -> FLOAT_TYPE .

    RIGHT_PAREN     reduce using rule 133 (casting_type -> FLOAT_TYPE .)


state 158

    (113) simple_condition -> variable .
    (143) array_indexing -> variable . LEFT_BRACKET clave RIGHT_BRACKET
    (44) assignment_statement -> variable . assignment_operator argument
    (45) assignment_statement -> variable . PLUS_PLUS
    (46) assignment_statement -> variable . MINUS_MINUS
    (47) assignment_operator -> . EQUALS
    (48) assignment_operator -> . PLUS_EQUALS
    (49) assignment_operator -> . MINUS_EQUALS
    (50) assignment_operator -> . TIMES_EQUALS
    (51) assignment_operator -> . DIVIDE_EQUALS
    (52) assignment_operator -> . MOD_EQUALS

    RIGHT_PAREN     reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 113 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 113 (simple_condition -> variable .)
    TIMES           reduce using rule 113 (simple_condition -> variable .)
    DIVIDE          reduce using rule 113 (simple_condition -> variable .)
    MOD             reduce using rule 113 (simple_condition -> variable .)
    POWER           reduce using rule 113 (simple_condition -> variable .)
    PLUS            reduce using rule 113 (simple_condition -> variable .)
    MINUS           reduce using rule 113 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 113 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 113 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 113 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 113 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 113 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 113 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 113 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 113 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 113 (simple_condition -> variable .)
    DOT             reduce using rule 113 (simple_condition -> variable .)
    COMMA           reduce using rule 113 (simple_condition -> variable .)
    LEFT_BRACKET    shift and go to state 170
    PLUS_PLUS       shift and go to state 115
    MINUS_MINUS     shift and go to state 116
    EQUALS          shift and go to state 171
    PLUS_EQUALS     shift and go to state 119
    MINUS_EQUALS    shift and go to state 120
    TIMES_EQUALS    shift and go to state 121
    DIVIDE_EQUALS   shift and go to state 122
    MOD_EQUALS      shift and go to state 123

    assignment_operator            shift and go to state 114

state 159

    (58) arguments -> arguments DOT . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    argument                       shift and go to state 223
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 160

    (59) arguments -> arguments COMMA . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    argument                       shift and go to state 224
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 161

    (65) argument -> ID CALL . function_call
    (43) variable -> ID CALL . NAME
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN

    NAME            shift and go to state 226

    function_call                  shift and go to state 225

state 162

    (70) argument -> casting argument .

    DOT             reduce using rule 70 (argument -> casting argument .)
    COMMA           reduce using rule 70 (argument -> casting argument .)
    SEMICOLON       reduce using rule 70 (argument -> casting argument .)
    RIGHT_PAREN     reduce using rule 70 (argument -> casting argument .)
    RIGHT_BRACKET   reduce using rule 70 (argument -> casting argument .)


state 163

    (135) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (137) array_elements -> . array_argument
    (138) array_elements -> . array_elements COMMA array_argument
    (139) array_argument -> . argument
    (140) array_argument -> . clave KEY_VALUE argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (141) clave -> . STRING
    (142) clave -> . INTEGER
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 168
    ID              shift and go to state 101
    INTEGER         shift and go to state 169
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    array_elements                 shift and go to state 227
    array_argument                 shift and go to state 165
    argument                       shift and go to state 166
    clave                          shift and go to state 167
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 164

    (136) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (138) array_elements -> array_elements . COMMA array_argument

    RIGHT_BRACKET   shift and go to state 228
    COMMA           shift and go to state 229


state 165

    (137) array_elements -> array_argument .

    RIGHT_BRACKET   reduce using rule 137 (array_elements -> array_argument .)
    COMMA           reduce using rule 137 (array_elements -> array_argument .)
    RIGHT_PAREN     reduce using rule 137 (array_elements -> array_argument .)


state 166

    (139) array_argument -> argument .

    RIGHT_BRACKET   reduce using rule 139 (array_argument -> argument .)
    COMMA           reduce using rule 139 (array_argument -> argument .)
    RIGHT_PAREN     reduce using rule 139 (array_argument -> argument .)


state 167

    (140) array_argument -> clave . KEY_VALUE argument

    KEY_VALUE       shift and go to state 230


state 168

    (60) argument -> STRING .
    (141) clave -> STRING .
    (82) factor -> STRING .

  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 60 (argument -> STRING .)
  ! reduce/reduce conflict for COMMA resolved using rule 60 (argument -> STRING .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 60 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 60 (argument -> STRING .)
    COMMA           reduce using rule 60 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 60 (argument -> STRING .)
    KEY_VALUE       reduce using rule 141 (clave -> STRING .)
    TIMES           reduce using rule 82 (factor -> STRING .)
    DIVIDE          reduce using rule 82 (factor -> STRING .)
    MOD             reduce using rule 82 (factor -> STRING .)
    POWER           reduce using rule 82 (factor -> STRING .)
    PLUS            reduce using rule 82 (factor -> STRING .)
    MINUS           reduce using rule 82 (factor -> STRING .)
    EQUAL_TO        reduce using rule 82 (factor -> STRING .)
    NOT_EQUAL_TO    reduce using rule 82 (factor -> STRING .)
    LESS_THAN       reduce using rule 82 (factor -> STRING .)
    GREATER_THAN    reduce using rule 82 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 82 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 82 (factor -> STRING .)
    IDENTICAL_TO    reduce using rule 82 (factor -> STRING .)
    NOT_IDENTICAL_TO reduce using rule 82 (factor -> STRING .)
    DIFFERENT       reduce using rule 82 (factor -> STRING .)

  ! RIGHT_BRACKET   [ reduce using rule 82 (factor -> STRING .) ]
  ! COMMA           [ reduce using rule 82 (factor -> STRING .) ]
  ! RIGHT_PAREN     [ reduce using rule 82 (factor -> STRING .) ]


state 169

    (142) clave -> INTEGER .
    (79) factor -> INTEGER .

    KEY_VALUE       reduce using rule 142 (clave -> INTEGER .)
    TIMES           reduce using rule 79 (factor -> INTEGER .)
    DIVIDE          reduce using rule 79 (factor -> INTEGER .)
    MOD             reduce using rule 79 (factor -> INTEGER .)
    POWER           reduce using rule 79 (factor -> INTEGER .)
    PLUS            reduce using rule 79 (factor -> INTEGER .)
    MINUS           reduce using rule 79 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 79 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 79 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 79 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 79 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 79 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 79 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 79 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 79 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 79 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 79 (factor -> INTEGER .)
    COMMA           reduce using rule 79 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 79 (factor -> INTEGER .)


state 170

    (143) array_indexing -> variable LEFT_BRACKET . clave RIGHT_BRACKET
    (141) clave -> . STRING
    (142) clave -> . INTEGER

    STRING          shift and go to state 180
    INTEGER         shift and go to state 181

    clave                          shift and go to state 231

state 171

    (47) assignment_operator -> EQUALS .

    STRING          reduce using rule 47 (assignment_operator -> EQUALS .)
    ID              reduce using rule 47 (assignment_operator -> EQUALS .)
    ARRAY           reduce using rule 47 (assignment_operator -> EQUALS .)
    LEFT_BRACKET    reduce using rule 47 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 47 (assignment_operator -> EQUALS .)
    FUNCTION        reduce using rule 47 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 47 (assignment_operator -> EQUALS .)
    NEW             reduce using rule 47 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 47 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 47 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 47 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 47 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 47 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 47 (assignment_operator -> EQUALS .)


state 172

    (29) anonymous_function -> FUNCTION LEFT_PAREN . parameters RIGHT_PAREN block
    (30) anonymous_function -> FUNCTION LEFT_PAREN . RIGHT_PAREN block
    (31) parameters -> . parameter
    (32) parameters -> . parameters COMMA parameter
    (33) parameter -> . variable
    (34) parameter -> . variable EQUALS argument
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    RIGHT_PAREN     shift and go to state 233
    ID              shift and go to state 49

    parameters                     shift and go to state 232
    parameter                      shift and go to state 207
    variable                       shift and go to state 208

state 173

    (161) object_creation -> NEW NAME . LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> NEW NAME . LEFT_PAREN arguments RIGHT_PAREN

    LEFT_PAREN      shift and go to state 234


state 174

    (39) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 235


state 175

    (38) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 236


state 176

    (44) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 44 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 44 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 44 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 44 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 44 (assignment_statement -> variable assignment_operator argument .)


state 177

    (134) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 134 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 134 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 134 (array_declaration_statement -> variable EQUALS array .)


state 178

    (143) array_indexing -> variable LEFT_BRACKET clave . RIGHT_BRACKET
    (145) array_modify_element -> variable LEFT_BRACKET clave . RIGHT_BRACKET EQUALS argument

    RIGHT_BRACKET   shift and go to state 237


state 179

    (144) array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET . EQUALS argument

    EQUALS          shift and go to state 238


state 180

    (141) clave -> STRING .

    RIGHT_BRACKET   reduce using rule 141 (clave -> STRING .)


state 181

    (142) clave -> INTEGER .

    RIGHT_BRACKET   reduce using rule 142 (clave -> INTEGER .)


state 182

    (146) array_remove_element -> UNSET LEFT_PAREN variable . LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN

    LEFT_BRACKET    shift and go to state 239


state 183

    (147) array_count_elements -> COUNT LEFT_PAREN variable . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 240


state 184

    (74) term -> term TIMES factor .
    (78) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MOD resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for POWER resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 74 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 74 (term -> term TIMES factor .)
    TIMES           reduce using rule 74 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 74 (term -> term TIMES factor .)
    MOD             reduce using rule 74 (term -> term TIMES factor .)
    POWER           reduce using rule 74 (term -> term TIMES factor .)
    PLUS            reduce using rule 74 (term -> term TIMES factor .)
    MINUS           reduce using rule 74 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 74 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 74 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 74 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 74 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 74 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 74 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 74 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 74 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 74 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 74 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 74 (term -> term TIMES factor .)
    DOT             reduce using rule 74 (term -> term TIMES factor .)
    COMMA           reduce using rule 74 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 74 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 74 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 74 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 74 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 78 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 78 (term -> factor .) ]
  ! MOD             [ reduce using rule 78 (term -> factor .) ]
  ! POWER           [ reduce using rule 78 (term -> factor .) ]
  ! PLUS            [ reduce using rule 78 (term -> factor .) ]
  ! MINUS           [ reduce using rule 78 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 78 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 78 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 78 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 78 (term -> factor .) ]


state 185

    (75) term -> term DIVIDE factor .
    (78) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MOD resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for POWER resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 75 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 75 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 75 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 75 (term -> term DIVIDE factor .)
    MOD             reduce using rule 75 (term -> term DIVIDE factor .)
    POWER           reduce using rule 75 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 75 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 75 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 75 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 75 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 75 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 75 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 75 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 75 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 75 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 75 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 75 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 75 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 75 (term -> term DIVIDE factor .)
    DOT             reduce using rule 75 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 75 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 75 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 75 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 75 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 75 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 78 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 78 (term -> factor .) ]
  ! MOD             [ reduce using rule 78 (term -> factor .) ]
  ! POWER           [ reduce using rule 78 (term -> factor .) ]
  ! PLUS            [ reduce using rule 78 (term -> factor .) ]
  ! MINUS           [ reduce using rule 78 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 78 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 78 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 78 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 78 (term -> factor .) ]


state 186

    (76) term -> term MOD factor .
    (78) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for MOD resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for POWER resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 76 (term -> term MOD factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 76 (term -> term MOD factor .)
    TIMES           reduce using rule 76 (term -> term MOD factor .)
    DIVIDE          reduce using rule 76 (term -> term MOD factor .)
    MOD             reduce using rule 76 (term -> term MOD factor .)
    POWER           reduce using rule 76 (term -> term MOD factor .)
    PLUS            reduce using rule 76 (term -> term MOD factor .)
    MINUS           reduce using rule 76 (term -> term MOD factor .)
    EQUAL_TO        reduce using rule 76 (term -> term MOD factor .)
    NOT_EQUAL_TO    reduce using rule 76 (term -> term MOD factor .)
    LESS_THAN       reduce using rule 76 (term -> term MOD factor .)
    GREATER_THAN    reduce using rule 76 (term -> term MOD factor .)
    LESS_EQUAL      reduce using rule 76 (term -> term MOD factor .)
    GREATER_EQUAL   reduce using rule 76 (term -> term MOD factor .)
    IDENTICAL_TO    reduce using rule 76 (term -> term MOD factor .)
    NOT_IDENTICAL_TO reduce using rule 76 (term -> term MOD factor .)
    DIFFERENT       reduce using rule 76 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 76 (term -> term MOD factor .)
    RIGHT_PAREN     reduce using rule 76 (term -> term MOD factor .)
    DOT             reduce using rule 76 (term -> term MOD factor .)
    COMMA           reduce using rule 76 (term -> term MOD factor .)
    LOGICAL_AND     reduce using rule 76 (term -> term MOD factor .)
    LOGICAL_OR      reduce using rule 76 (term -> term MOD factor .)
    LOGICAL_XOR     reduce using rule 76 (term -> term MOD factor .)
    RIGHT_BRACKET   reduce using rule 76 (term -> term MOD factor .)

  ! TIMES           [ reduce using rule 78 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 78 (term -> factor .) ]
  ! MOD             [ reduce using rule 78 (term -> factor .) ]
  ! POWER           [ reduce using rule 78 (term -> factor .) ]
  ! PLUS            [ reduce using rule 78 (term -> factor .) ]
  ! MINUS           [ reduce using rule 78 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 78 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 78 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 78 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 78 (term -> factor .) ]


state 187

    (77) term -> term POWER factor .
    (78) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for MOD resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for POWER resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 77 (term -> term POWER factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 77 (term -> term POWER factor .)
    TIMES           reduce using rule 77 (term -> term POWER factor .)
    DIVIDE          reduce using rule 77 (term -> term POWER factor .)
    MOD             reduce using rule 77 (term -> term POWER factor .)
    POWER           reduce using rule 77 (term -> term POWER factor .)
    PLUS            reduce using rule 77 (term -> term POWER factor .)
    MINUS           reduce using rule 77 (term -> term POWER factor .)
    EQUAL_TO        reduce using rule 77 (term -> term POWER factor .)
    NOT_EQUAL_TO    reduce using rule 77 (term -> term POWER factor .)
    LESS_THAN       reduce using rule 77 (term -> term POWER factor .)
    GREATER_THAN    reduce using rule 77 (term -> term POWER factor .)
    LESS_EQUAL      reduce using rule 77 (term -> term POWER factor .)
    GREATER_EQUAL   reduce using rule 77 (term -> term POWER factor .)
    IDENTICAL_TO    reduce using rule 77 (term -> term POWER factor .)
    NOT_IDENTICAL_TO reduce using rule 77 (term -> term POWER factor .)
    DIFFERENT       reduce using rule 77 (term -> term POWER factor .)
    SEMICOLON       reduce using rule 77 (term -> term POWER factor .)
    RIGHT_PAREN     reduce using rule 77 (term -> term POWER factor .)
    DOT             reduce using rule 77 (term -> term POWER factor .)
    COMMA           reduce using rule 77 (term -> term POWER factor .)
    LOGICAL_AND     reduce using rule 77 (term -> term POWER factor .)
    LOGICAL_OR      reduce using rule 77 (term -> term POWER factor .)
    LOGICAL_XOR     reduce using rule 77 (term -> term POWER factor .)
    RIGHT_BRACKET   reduce using rule 77 (term -> term POWER factor .)

  ! TIMES           [ reduce using rule 78 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 78 (term -> factor .) ]
  ! MOD             [ reduce using rule 78 (term -> factor .) ]
  ! POWER           [ reduce using rule 78 (term -> factor .) ]
  ! PLUS            [ reduce using rule 78 (term -> factor .) ]
  ! MINUS           [ reduce using rule 78 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 78 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 78 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 78 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 78 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 78 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 78 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 78 (term -> factor .) ]


state 188

    (93) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (102) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 241
    COMMA           shift and go to state 242


state 189

    (94) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    SEMICOLON       reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    TRUE            reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    STRING          reduce using rule 94 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 190

    (101) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 101 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 101 (assignment_list -> assignment_statement .)


state 191

    (44) assignment_statement -> variable . assignment_operator argument
    (45) assignment_statement -> variable . PLUS_PLUS
    (46) assignment_statement -> variable . MINUS_MINUS
    (47) assignment_operator -> . EQUALS
    (48) assignment_operator -> . PLUS_EQUALS
    (49) assignment_operator -> . MINUS_EQUALS
    (50) assignment_operator -> . TIMES_EQUALS
    (51) assignment_operator -> . DIVIDE_EQUALS
    (52) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 115
    MINUS_MINUS     shift and go to state 116
    EQUALS          shift and go to state 171
    PLUS_EQUALS     shift and go to state 119
    MINUS_EQUALS    shift and go to state 120
    TIMES_EQUALS    shift and go to state 121
    DIVIDE_EQUALS   shift and go to state 122
    MOD_EQUALS      shift and go to state 123

    assignment_operator            shift and go to state 114

state 192

    (43) variable -> ID CALL NAME .

    PLUS_PLUS       reduce using rule 43 (variable -> ID CALL NAME .)
    MINUS_MINUS     reduce using rule 43 (variable -> ID CALL NAME .)
    EQUALS          reduce using rule 43 (variable -> ID CALL NAME .)
    LEFT_BRACKET    reduce using rule 43 (variable -> ID CALL NAME .)
    PLUS_EQUALS     reduce using rule 43 (variable -> ID CALL NAME .)
    MINUS_EQUALS    reduce using rule 43 (variable -> ID CALL NAME .)
    TIMES_EQUALS    reduce using rule 43 (variable -> ID CALL NAME .)
    DIVIDE_EQUALS   reduce using rule 43 (variable -> ID CALL NAME .)
    MOD_EQUALS      reduce using rule 43 (variable -> ID CALL NAME .)
    LOGICAL_AND     reduce using rule 43 (variable -> ID CALL NAME .)
    LOGICAL_OR      reduce using rule 43 (variable -> ID CALL NAME .)
    LOGICAL_XOR     reduce using rule 43 (variable -> ID CALL NAME .)
    TIMES           reduce using rule 43 (variable -> ID CALL NAME .)
    DIVIDE          reduce using rule 43 (variable -> ID CALL NAME .)
    MOD             reduce using rule 43 (variable -> ID CALL NAME .)
    POWER           reduce using rule 43 (variable -> ID CALL NAME .)
    PLUS            reduce using rule 43 (variable -> ID CALL NAME .)
    MINUS           reduce using rule 43 (variable -> ID CALL NAME .)
    EQUAL_TO        reduce using rule 43 (variable -> ID CALL NAME .)
    NOT_EQUAL_TO    reduce using rule 43 (variable -> ID CALL NAME .)
    LESS_THAN       reduce using rule 43 (variable -> ID CALL NAME .)
    GREATER_THAN    reduce using rule 43 (variable -> ID CALL NAME .)
    LESS_EQUAL      reduce using rule 43 (variable -> ID CALL NAME .)
    GREATER_EQUAL   reduce using rule 43 (variable -> ID CALL NAME .)
    IDENTICAL_TO    reduce using rule 43 (variable -> ID CALL NAME .)
    NOT_IDENTICAL_TO reduce using rule 43 (variable -> ID CALL NAME .)
    DIFFERENT       reduce using rule 43 (variable -> ID CALL NAME .)
    SEMICOLON       reduce using rule 43 (variable -> ID CALL NAME .)
    RIGHT_PAREN     reduce using rule 43 (variable -> ID CALL NAME .)
    DOT             reduce using rule 43 (variable -> ID CALL NAME .)
    COMMA           reduce using rule 43 (variable -> ID CALL NAME .)
    RIGHT_BRACKET   reduce using rule 43 (variable -> ID CALL NAME .)


state 193

    (85) if_statement -> IF parenthesized_condition block else_if_extended .
    (86) if_statement -> IF parenthesized_condition block else_if_extended . if_part3
    (89) else_if_extended -> else_if_extended . if_part2
    (91) if_part3 -> . ELSE block
    (90) if_part2 -> . ELSEIF parenthesized_condition block

    CLOSE_TAG       reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ONE_LINE_COMMENT reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    MULTI_LINE_COMMENT reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    BREAK           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    CONTINUE        reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    IF              reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    WHILE           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FUNCTION        reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    CLASS           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FSCANF          reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FGETS           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    NAME            reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    RETURN          reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    UNSET           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    COUNT           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FOR             reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    PRINT           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ECHO            reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ID              reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    INTEGER         reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FLOAT           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    STRING          reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    LEFT_PAREN      reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    TRUE            reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FALSE           reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    LOGICAL_NOT     reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    RIGHT_BRACE     reduce using rule 85 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ELSE            shift and go to state 196
    ELSEIF          shift and go to state 197

    if_part3                       shift and go to state 243
    if_part2                       shift and go to state 244

state 194

    (87) if_statement -> IF parenthesized_condition block if_part3 .

    CLOSE_TAG       reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    ONE_LINE_COMMENT reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    BREAK           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    CONTINUE        reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    IF              reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    WHILE           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    FUNCTION        reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    CLASS           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    FSCANF          reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    FGETS           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    NAME            reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    RETURN          reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    UNSET           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    COUNT           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    FOR             reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    PRINT           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    ECHO            reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    ID              reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    INTEGER         reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    FLOAT           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    STRING          reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    LEFT_PAREN      reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    TRUE            reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    FALSE           reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    LOGICAL_NOT     reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)
    RIGHT_BRACE     reduce using rule 87 (if_statement -> IF parenthesized_condition block if_part3 .)


state 195

    (88) else_if_extended -> if_part2 .

    ELSE            reduce using rule 88 (else_if_extended -> if_part2 .)
    ELSEIF          reduce using rule 88 (else_if_extended -> if_part2 .)
    CLOSE_TAG       reduce using rule 88 (else_if_extended -> if_part2 .)
    ONE_LINE_COMMENT reduce using rule 88 (else_if_extended -> if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 88 (else_if_extended -> if_part2 .)
    BREAK           reduce using rule 88 (else_if_extended -> if_part2 .)
    CONTINUE        reduce using rule 88 (else_if_extended -> if_part2 .)
    IF              reduce using rule 88 (else_if_extended -> if_part2 .)
    WHILE           reduce using rule 88 (else_if_extended -> if_part2 .)
    FUNCTION        reduce using rule 88 (else_if_extended -> if_part2 .)
    CLASS           reduce using rule 88 (else_if_extended -> if_part2 .)
    FSCANF          reduce using rule 88 (else_if_extended -> if_part2 .)
    FGETS           reduce using rule 88 (else_if_extended -> if_part2 .)
    NAME            reduce using rule 88 (else_if_extended -> if_part2 .)
    RETURN          reduce using rule 88 (else_if_extended -> if_part2 .)
    UNSET           reduce using rule 88 (else_if_extended -> if_part2 .)
    COUNT           reduce using rule 88 (else_if_extended -> if_part2 .)
    FOR             reduce using rule 88 (else_if_extended -> if_part2 .)
    PRINT           reduce using rule 88 (else_if_extended -> if_part2 .)
    ECHO            reduce using rule 88 (else_if_extended -> if_part2 .)
    ID              reduce using rule 88 (else_if_extended -> if_part2 .)
    INTEGER         reduce using rule 88 (else_if_extended -> if_part2 .)
    FLOAT           reduce using rule 88 (else_if_extended -> if_part2 .)
    STRING          reduce using rule 88 (else_if_extended -> if_part2 .)
    LEFT_PAREN      reduce using rule 88 (else_if_extended -> if_part2 .)
    TRUE            reduce using rule 88 (else_if_extended -> if_part2 .)
    FALSE           reduce using rule 88 (else_if_extended -> if_part2 .)
    LOGICAL_NOT     reduce using rule 88 (else_if_extended -> if_part2 .)
    RIGHT_BRACE     reduce using rule 88 (else_if_extended -> if_part2 .)


state 196

    (91) if_part3 -> ELSE . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 245

state 197

    (90) if_part2 -> ELSEIF . parenthesized_condition block
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 76

    parenthesized_condition        shift and go to state 246

state 198

    (105) block -> LEFT_BRACE statements . RIGHT_BRACE
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . array_indexing
    (22) statement -> . array_add_element
    (23) statement -> . array_modify_element
    (24) statement -> . array_remove_element
    (25) statement -> . array_count_elements
    (26) statement -> . expression
    (84) if_statement -> . IF parenthesized_condition block
    (85) if_statement -> . IF parenthesized_condition block else_if_extended
    (86) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (87) if_statement -> . IF parenthesized_condition block if_part3
    (92) while_statement -> . WHILE parenthesized_condition block
    (95) for_statement -> . for_part1 condition for_part3
    (96) for_statement -> . for_part1 for_part3
    (27) function_statement -> . FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (148) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (149) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (53) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> . print_function arguments
    (39) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (134) array_declaration_statement -> . variable EQUALS array
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (35) return_statement -> . RETURN arguments
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> . variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> . variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (146) array_remove_element -> . UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (147) array_count_elements -> . COUNT LEFT_PAREN variable RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (93) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (94) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (55) print_function -> . PRINT
    (56) print_function -> . ECHO
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    RIGHT_BRACE     shift and go to state 247
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 28
    WHILE           shift and go to state 30
    FUNCTION        shift and go to state 33
    CLASS           shift and go to state 36
    FSCANF          shift and go to state 38
    FGETS           shift and go to state 40
    NAME            shift and go to state 34
    RETURN          shift and go to state 42
    UNSET           shift and go to state 43
    COUNT           shift and go to state 44
    FOR             shift and go to state 46
    PRINT           shift and go to state 47
    ECHO            shift and go to state 48
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    statement2                     shift and go to state 61
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    array_indexing                 shift and go to state 22
    array_add_element              shift and go to state 23
    array_modify_element           shift and go to state 24
    array_remove_element           shift and go to state 25
    array_count_elements           shift and go to state 26
    expression                     shift and go to state 27
    parenthesized_condition        shift and go to state 29
    for_part1                      shift and go to state 31
    condition                      shift and go to state 32
    print_function                 shift and go to state 37
    variable                       shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 50
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    relational_expression          shift and go to state 58

state 199

    (106) block -> LEFT_BRACE RIGHT_BRACE .

    ELSE            reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSEIF          reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLASS           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    UNSET           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    COUNT           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    INTEGER         reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    FLOAT           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    STRING          reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    TRUE            reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    FALSE           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    PUBLIC          reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRIVATE         reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    PROTECTED       reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    DOT             reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    COMMA           reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    SEMICOLON       reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_PAREN     reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACKET   reduce using rule 106 (block -> LEFT_BRACE RIGHT_BRACE .)


state 200

    (97) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (99) for_part4 -> . block
    (100) for_part4 -> . SEMICOLON
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 202
    LEFT_BRACE      shift and go to state 139

    for_part4                      shift and go to state 248
    block                          shift and go to state 204

state 201

    (104) statement_list -> statement_list COMMA . statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . array_indexing
    (22) statement -> . array_add_element
    (23) statement -> . array_modify_element
    (24) statement -> . array_remove_element
    (25) statement -> . array_count_elements
    (26) statement -> . expression
    (53) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (54) print_statement -> . print_function arguments
    (39) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (134) array_declaration_statement -> . variable EQUALS array
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (35) return_statement -> . RETURN arguments
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (144) array_add_element -> . variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument
    (145) array_modify_element -> . variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument
    (146) array_remove_element -> . UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN
    (147) array_count_elements -> . COUNT LEFT_PAREN variable RIGHT_PAREN
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (55) print_function -> . PRINT
    (56) print_function -> . ECHO
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 38
    FGETS           shift and go to state 40
    NAME            shift and go to state 34
    RETURN          shift and go to state 42
    UNSET           shift and go to state 43
    COUNT           shift and go to state 44
    PRINT           shift and go to state 47
    ECHO            shift and go to state 48
    ID              shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    STRING          shift and go to state 39
    LEFT_PAREN      shift and go to state 35
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    statement                      shift and go to state 249
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    array_indexing                 shift and go to state 22
    array_add_element              shift and go to state 23
    array_modify_element           shift and go to state 24
    array_remove_element           shift and go to state 25
    array_count_elements           shift and go to state 26
    expression                     shift and go to state 27
    print_function                 shift and go to state 37
    variable                       shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 202

    (100) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 100 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 100 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 100 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 100 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 100 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 100 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 100 (for_part4 -> SEMICOLON .)
    FUNCTION        reduce using rule 100 (for_part4 -> SEMICOLON .)
    CLASS           reduce using rule 100 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 100 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 100 (for_part4 -> SEMICOLON .)
    NAME            reduce using rule 100 (for_part4 -> SEMICOLON .)
    RETURN          reduce using rule 100 (for_part4 -> SEMICOLON .)
    UNSET           reduce using rule 100 (for_part4 -> SEMICOLON .)
    COUNT           reduce using rule 100 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 100 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 100 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 100 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 100 (for_part4 -> SEMICOLON .)
    INTEGER         reduce using rule 100 (for_part4 -> SEMICOLON .)
    FLOAT           reduce using rule 100 (for_part4 -> SEMICOLON .)
    STRING          reduce using rule 100 (for_part4 -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 100 (for_part4 -> SEMICOLON .)
    TRUE            reduce using rule 100 (for_part4 -> SEMICOLON .)
    FALSE           reduce using rule 100 (for_part4 -> SEMICOLON .)
    LOGICAL_NOT     reduce using rule 100 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 100 (for_part4 -> SEMICOLON .)


state 203

    (98) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CLASS           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    UNSET           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    COUNT           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    INTEGER         reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FLOAT           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    STRING          reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    LEFT_PAREN      reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    TRUE            reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FALSE           reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    LOGICAL_NOT     reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 98 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 204

    (99) for_part4 -> block .

    CLOSE_TAG       reduce using rule 99 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 99 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 99 (for_part4 -> block .)
    BREAK           reduce using rule 99 (for_part4 -> block .)
    CONTINUE        reduce using rule 99 (for_part4 -> block .)
    IF              reduce using rule 99 (for_part4 -> block .)
    WHILE           reduce using rule 99 (for_part4 -> block .)
    FUNCTION        reduce using rule 99 (for_part4 -> block .)
    CLASS           reduce using rule 99 (for_part4 -> block .)
    FSCANF          reduce using rule 99 (for_part4 -> block .)
    FGETS           reduce using rule 99 (for_part4 -> block .)
    NAME            reduce using rule 99 (for_part4 -> block .)
    RETURN          reduce using rule 99 (for_part4 -> block .)
    UNSET           reduce using rule 99 (for_part4 -> block .)
    COUNT           reduce using rule 99 (for_part4 -> block .)
    FOR             reduce using rule 99 (for_part4 -> block .)
    PRINT           reduce using rule 99 (for_part4 -> block .)
    ECHO            reduce using rule 99 (for_part4 -> block .)
    ID              reduce using rule 99 (for_part4 -> block .)
    INTEGER         reduce using rule 99 (for_part4 -> block .)
    FLOAT           reduce using rule 99 (for_part4 -> block .)
    STRING          reduce using rule 99 (for_part4 -> block .)
    LEFT_PAREN      reduce using rule 99 (for_part4 -> block .)
    TRUE            reduce using rule 99 (for_part4 -> block .)
    FALSE           reduce using rule 99 (for_part4 -> block .)
    LOGICAL_NOT     reduce using rule 99 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 99 (for_part4 -> block .)


state 205

    (27) function_statement -> FUNCTION NAME LEFT_PAREN parameters . RIGHT_PAREN block
    (32) parameters -> parameters . COMMA parameter

    RIGHT_PAREN     shift and go to state 250
    COMMA           shift and go to state 251


state 206

    (28) function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 252

state 207

    (31) parameters -> parameter .

    RIGHT_PAREN     reduce using rule 31 (parameters -> parameter .)
    COMMA           reduce using rule 31 (parameters -> parameter .)


state 208

    (33) parameter -> variable .
    (34) parameter -> variable . EQUALS argument

    RIGHT_PAREN     reduce using rule 33 (parameter -> variable .)
    COMMA           reduce using rule 33 (parameter -> variable .)
    EQUALS          shift and go to state 253


state 209

    (36) function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 36 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    DOT             reduce using rule 36 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 36 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 36 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 36 (function_call -> NAME LEFT_PAREN arguments RIGHT_PAREN .)


state 210

    (148) class_declaration -> CLASS NAME LEFT_BRACE class_statements . RIGHT_BRACE
    (151) class_statements -> class_statements . class_statement
    (152) class_statement -> . method_declaration
    (153) class_statement -> . property_declaration
    (154) class_statement -> . ONE_LINE_COMMENT
    (155) class_statement -> . MULTI_LINE_COMMENT
    (156) method_declaration -> . visibility_operator function_statement
    (157) property_declaration -> . visibility_operator variable SEMICOLON
    (158) visibility_operator -> . PUBLIC
    (159) visibility_operator -> . PRIVATE
    (160) visibility_operator -> . PROTECTED

    RIGHT_BRACE     shift and go to state 254
    ONE_LINE_COMMENT shift and go to state 215
    MULTI_LINE_COMMENT shift and go to state 216
    PUBLIC          shift and go to state 218
    PRIVATE         shift and go to state 219
    PROTECTED       shift and go to state 220

    class_statement                shift and go to state 255
    method_declaration             shift and go to state 213
    property_declaration           shift and go to state 214
    visibility_operator            shift and go to state 217

state 211

    (149) class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    CLASS           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    UNSET           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    COUNT           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    INTEGER         reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FLOAT           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    STRING          reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    TRUE            reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FALSE           reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 149 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)


state 212

    (150) class_statements -> class_statement .

    RIGHT_BRACE     reduce using rule 150 (class_statements -> class_statement .)
    ONE_LINE_COMMENT reduce using rule 150 (class_statements -> class_statement .)
    MULTI_LINE_COMMENT reduce using rule 150 (class_statements -> class_statement .)
    PUBLIC          reduce using rule 150 (class_statements -> class_statement .)
    PRIVATE         reduce using rule 150 (class_statements -> class_statement .)
    PROTECTED       reduce using rule 150 (class_statements -> class_statement .)


state 213

    (152) class_statement -> method_declaration .

    RIGHT_BRACE     reduce using rule 152 (class_statement -> method_declaration .)
    ONE_LINE_COMMENT reduce using rule 152 (class_statement -> method_declaration .)
    MULTI_LINE_COMMENT reduce using rule 152 (class_statement -> method_declaration .)
    PUBLIC          reduce using rule 152 (class_statement -> method_declaration .)
    PRIVATE         reduce using rule 152 (class_statement -> method_declaration .)
    PROTECTED       reduce using rule 152 (class_statement -> method_declaration .)


state 214

    (153) class_statement -> property_declaration .

    RIGHT_BRACE     reduce using rule 153 (class_statement -> property_declaration .)
    ONE_LINE_COMMENT reduce using rule 153 (class_statement -> property_declaration .)
    MULTI_LINE_COMMENT reduce using rule 153 (class_statement -> property_declaration .)
    PUBLIC          reduce using rule 153 (class_statement -> property_declaration .)
    PRIVATE         reduce using rule 153 (class_statement -> property_declaration .)
    PROTECTED       reduce using rule 153 (class_statement -> property_declaration .)


state 215

    (154) class_statement -> ONE_LINE_COMMENT .

    RIGHT_BRACE     reduce using rule 154 (class_statement -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 154 (class_statement -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 154 (class_statement -> ONE_LINE_COMMENT .)
    PUBLIC          reduce using rule 154 (class_statement -> ONE_LINE_COMMENT .)
    PRIVATE         reduce using rule 154 (class_statement -> ONE_LINE_COMMENT .)
    PROTECTED       reduce using rule 154 (class_statement -> ONE_LINE_COMMENT .)


state 216

    (155) class_statement -> MULTI_LINE_COMMENT .

    RIGHT_BRACE     reduce using rule 155 (class_statement -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 155 (class_statement -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 155 (class_statement -> MULTI_LINE_COMMENT .)
    PUBLIC          reduce using rule 155 (class_statement -> MULTI_LINE_COMMENT .)
    PRIVATE         reduce using rule 155 (class_statement -> MULTI_LINE_COMMENT .)
    PROTECTED       reduce using rule 155 (class_statement -> MULTI_LINE_COMMENT .)


state 217

    (156) method_declaration -> visibility_operator . function_statement
    (157) property_declaration -> visibility_operator . variable SEMICOLON
    (27) function_statement -> . FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block
    (28) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    FUNCTION        shift and go to state 33
    ID              shift and go to state 49

    function_statement             shift and go to state 256
    variable                       shift and go to state 257

state 218

    (158) visibility_operator -> PUBLIC .

    FUNCTION        reduce using rule 158 (visibility_operator -> PUBLIC .)
    ID              reduce using rule 158 (visibility_operator -> PUBLIC .)


state 219

    (159) visibility_operator -> PRIVATE .

    FUNCTION        reduce using rule 159 (visibility_operator -> PRIVATE .)
    ID              reduce using rule 159 (visibility_operator -> PRIVATE .)


state 220

    (160) visibility_operator -> PROTECTED .

    FUNCTION        reduce using rule 160 (visibility_operator -> PROTECTED .)
    ID              reduce using rule 160 (visibility_operator -> PROTECTED .)


state 221

    (53) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 53 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 53 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 53 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 222

    (131) casting -> LEFT_PAREN casting_type RIGHT_PAREN .

    STRING          reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ID              reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ARRAY           reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_BRACKET    reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NAME            reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FUNCTION        reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FGETS           reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NEW             reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    INTEGER         reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FLOAT           reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    TRUE            reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FALSE           reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 131 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)


state 223

    (58) arguments -> arguments DOT argument .

    DOT             reduce using rule 58 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 58 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 58 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 58 (arguments -> arguments DOT argument .)


state 224

    (59) arguments -> arguments COMMA argument .

    DOT             reduce using rule 59 (arguments -> arguments COMMA argument .)
    COMMA           reduce using rule 59 (arguments -> arguments COMMA argument .)
    SEMICOLON       reduce using rule 59 (arguments -> arguments COMMA argument .)
    RIGHT_PAREN     reduce using rule 59 (arguments -> arguments COMMA argument .)


state 225

    (65) argument -> ID CALL function_call .

    DOT             reduce using rule 65 (argument -> ID CALL function_call .)
    COMMA           reduce using rule 65 (argument -> ID CALL function_call .)
    SEMICOLON       reduce using rule 65 (argument -> ID CALL function_call .)
    RIGHT_PAREN     reduce using rule 65 (argument -> ID CALL function_call .)
    RIGHT_BRACKET   reduce using rule 65 (argument -> ID CALL function_call .)


state 226

    (43) variable -> ID CALL NAME .
    (36) function_call -> NAME . LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> NAME . LEFT_PAREN RIGHT_PAREN

    LEFT_BRACKET    reduce using rule 43 (variable -> ID CALL NAME .)
    PLUS_PLUS       reduce using rule 43 (variable -> ID CALL NAME .)
    MINUS_MINUS     reduce using rule 43 (variable -> ID CALL NAME .)
    EQUALS          reduce using rule 43 (variable -> ID CALL NAME .)
    PLUS_EQUALS     reduce using rule 43 (variable -> ID CALL NAME .)
    MINUS_EQUALS    reduce using rule 43 (variable -> ID CALL NAME .)
    TIMES_EQUALS    reduce using rule 43 (variable -> ID CALL NAME .)
    DIVIDE_EQUALS   reduce using rule 43 (variable -> ID CALL NAME .)
    MOD_EQUALS      reduce using rule 43 (variable -> ID CALL NAME .)
    LOGICAL_AND     reduce using rule 43 (variable -> ID CALL NAME .)
    LOGICAL_OR      reduce using rule 43 (variable -> ID CALL NAME .)
    LOGICAL_XOR     reduce using rule 43 (variable -> ID CALL NAME .)
    TIMES           reduce using rule 43 (variable -> ID CALL NAME .)
    DIVIDE          reduce using rule 43 (variable -> ID CALL NAME .)
    MOD             reduce using rule 43 (variable -> ID CALL NAME .)
    POWER           reduce using rule 43 (variable -> ID CALL NAME .)
    PLUS            reduce using rule 43 (variable -> ID CALL NAME .)
    MINUS           reduce using rule 43 (variable -> ID CALL NAME .)
    EQUAL_TO        reduce using rule 43 (variable -> ID CALL NAME .)
    NOT_EQUAL_TO    reduce using rule 43 (variable -> ID CALL NAME .)
    LESS_THAN       reduce using rule 43 (variable -> ID CALL NAME .)
    GREATER_THAN    reduce using rule 43 (variable -> ID CALL NAME .)
    LESS_EQUAL      reduce using rule 43 (variable -> ID CALL NAME .)
    GREATER_EQUAL   reduce using rule 43 (variable -> ID CALL NAME .)
    IDENTICAL_TO    reduce using rule 43 (variable -> ID CALL NAME .)
    NOT_IDENTICAL_TO reduce using rule 43 (variable -> ID CALL NAME .)
    DIFFERENT       reduce using rule 43 (variable -> ID CALL NAME .)
    DOT             reduce using rule 43 (variable -> ID CALL NAME .)
    COMMA           reduce using rule 43 (variable -> ID CALL NAME .)
    SEMICOLON       reduce using rule 43 (variable -> ID CALL NAME .)
    RIGHT_PAREN     reduce using rule 43 (variable -> ID CALL NAME .)
    RIGHT_BRACKET   reduce using rule 43 (variable -> ID CALL NAME .)
    LEFT_PAREN      shift and go to state 89


state 227

    (135) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (138) array_elements -> array_elements . COMMA array_argument

    RIGHT_PAREN     shift and go to state 258
    COMMA           shift and go to state 229


state 228

    (136) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    DOT             reduce using rule 136 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 136 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 136 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 136 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 136 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)


state 229

    (138) array_elements -> array_elements COMMA . array_argument
    (139) array_argument -> . argument
    (140) array_argument -> . clave KEY_VALUE argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (141) clave -> . STRING
    (142) clave -> . INTEGER
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 168
    ID              shift and go to state 101
    INTEGER         shift and go to state 169
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    array_argument                 shift and go to state 259
    argument                       shift and go to state 166
    clave                          shift and go to state 167
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 230

    (140) array_argument -> clave KEY_VALUE . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    argument                       shift and go to state 260
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 231

    (143) array_indexing -> variable LEFT_BRACKET clave . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 261


state 232

    (29) anonymous_function -> FUNCTION LEFT_PAREN parameters . RIGHT_PAREN block
    (32) parameters -> parameters . COMMA parameter

    RIGHT_PAREN     shift and go to state 262
    COMMA           shift and go to state 251


state 233

    (30) anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 263

state 234

    (161) object_creation -> NEW NAME LEFT_PAREN . RIGHT_PAREN
    (162) object_creation -> NEW NAME LEFT_PAREN . arguments RIGHT_PAREN
    (57) arguments -> . argument
    (58) arguments -> . arguments DOT argument
    (59) arguments -> . arguments COMMA argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 264
    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    arguments                      shift and go to state 265
    argument                       shift and go to state 95
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    variable                       shift and go to state 109
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 235

    (39) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 266


state 236

    (38) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 38 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    DOT             reduce using rule 38 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 38 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 38 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 38 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)


state 237

    (143) array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .
    (145) array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET . EQUALS argument

    SEMICOLON       reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    COMMA           reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    EQUALS          shift and go to state 267


state 238

    (144) array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET EQUALS . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    variable                       shift and go to state 109
    argument                       shift and go to state 268
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 239

    (146) array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET . clave RIGHT_BRACKET RIGHT_PAREN
    (141) clave -> . STRING
    (142) clave -> . INTEGER

    STRING          shift and go to state 180
    INTEGER         shift and go to state 181

    clave                          shift and go to state 269

state 240

    (147) array_count_elements -> COUNT LEFT_PAREN variable RIGHT_PAREN .

    SEMICOLON       reduce using rule 147 (array_count_elements -> COUNT LEFT_PAREN variable RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 147 (array_count_elements -> COUNT LEFT_PAREN variable RIGHT_PAREN .)
    COMMA           reduce using rule 147 (array_count_elements -> COUNT LEFT_PAREN variable RIGHT_PAREN .)


state 241

    (93) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    SEMICOLON       reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    TRUE            reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    STRING          reduce using rule 93 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)


state 242

    (102) assignment_list -> assignment_list COMMA . assignment_statement
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    ID              shift and go to state 49

    assignment_statement           shift and go to state 270
    variable                       shift and go to state 191

state 243

    (86) if_statement -> IF parenthesized_condition block else_if_extended if_part3 .

    CLOSE_TAG       reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ONE_LINE_COMMENT reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    BREAK           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CONTINUE        reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    IF              reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    WHILE           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FUNCTION        reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CLASS           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FSCANF          reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FGETS           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    NAME            reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RETURN          reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    UNSET           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    COUNT           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FOR             reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    PRINT           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ECHO            reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ID              reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    INTEGER         reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FLOAT           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    STRING          reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    LEFT_PAREN      reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    TRUE            reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FALSE           reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    LOGICAL_NOT     reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RIGHT_BRACE     reduce using rule 86 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)


state 244

    (89) else_if_extended -> else_if_extended if_part2 .

    ELSE            reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    ELSEIF          reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    CLOSE_TAG       reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    ONE_LINE_COMMENT reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    BREAK           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    CONTINUE        reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    IF              reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    WHILE           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    FUNCTION        reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    CLASS           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    FSCANF          reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    FGETS           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    NAME            reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    RETURN          reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    UNSET           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    COUNT           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    FOR             reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    PRINT           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    ECHO            reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    ID              reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    INTEGER         reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    FLOAT           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    STRING          reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    LEFT_PAREN      reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    TRUE            reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    FALSE           reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    LOGICAL_NOT     reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)
    RIGHT_BRACE     reduce using rule 89 (else_if_extended -> else_if_extended if_part2 .)


state 245

    (91) if_part3 -> ELSE block .

    CLOSE_TAG       reduce using rule 91 (if_part3 -> ELSE block .)
    ONE_LINE_COMMENT reduce using rule 91 (if_part3 -> ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 91 (if_part3 -> ELSE block .)
    BREAK           reduce using rule 91 (if_part3 -> ELSE block .)
    CONTINUE        reduce using rule 91 (if_part3 -> ELSE block .)
    IF              reduce using rule 91 (if_part3 -> ELSE block .)
    WHILE           reduce using rule 91 (if_part3 -> ELSE block .)
    FUNCTION        reduce using rule 91 (if_part3 -> ELSE block .)
    CLASS           reduce using rule 91 (if_part3 -> ELSE block .)
    FSCANF          reduce using rule 91 (if_part3 -> ELSE block .)
    FGETS           reduce using rule 91 (if_part3 -> ELSE block .)
    NAME            reduce using rule 91 (if_part3 -> ELSE block .)
    RETURN          reduce using rule 91 (if_part3 -> ELSE block .)
    UNSET           reduce using rule 91 (if_part3 -> ELSE block .)
    COUNT           reduce using rule 91 (if_part3 -> ELSE block .)
    FOR             reduce using rule 91 (if_part3 -> ELSE block .)
    PRINT           reduce using rule 91 (if_part3 -> ELSE block .)
    ECHO            reduce using rule 91 (if_part3 -> ELSE block .)
    ID              reduce using rule 91 (if_part3 -> ELSE block .)
    INTEGER         reduce using rule 91 (if_part3 -> ELSE block .)
    FLOAT           reduce using rule 91 (if_part3 -> ELSE block .)
    STRING          reduce using rule 91 (if_part3 -> ELSE block .)
    LEFT_PAREN      reduce using rule 91 (if_part3 -> ELSE block .)
    TRUE            reduce using rule 91 (if_part3 -> ELSE block .)
    FALSE           reduce using rule 91 (if_part3 -> ELSE block .)
    LOGICAL_NOT     reduce using rule 91 (if_part3 -> ELSE block .)
    RIGHT_BRACE     reduce using rule 91 (if_part3 -> ELSE block .)


state 246

    (90) if_part2 -> ELSEIF parenthesized_condition . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 271

state 247

    (105) block -> LEFT_BRACE statements RIGHT_BRACE .

    ELSE            reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSEIF          reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLASS           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    NAME            reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RETURN          reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    UNSET           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    COUNT           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    INTEGER         reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FLOAT           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    STRING          reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    TRUE            reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FALSE           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PUBLIC          reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRIVATE         reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PROTECTED       reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    DOT             reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    COMMA           reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    SEMICOLON       reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_PAREN     reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACKET   reduce using rule 105 (block -> LEFT_BRACE statements RIGHT_BRACE .)


state 248

    (97) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CLASS           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    UNSET           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    COUNT           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    INTEGER         reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FLOAT           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    STRING          reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    LEFT_PAREN      reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    TRUE            reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FALSE           reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    LOGICAL_NOT     reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 97 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)


state 249

    (104) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 104 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 104 (statement_list -> statement_list COMMA statement .)


state 250

    (27) function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 272

state 251

    (32) parameters -> parameters COMMA . parameter
    (33) parameter -> . variable
    (34) parameter -> . variable EQUALS argument
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    ID              shift and go to state 49

    parameter                      shift and go to state 273
    variable                       shift and go to state 208

state 252

    (28) function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    BREAK           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    CONTINUE        reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    IF              reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    WHILE           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FUNCTION        reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    CLASS           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FSCANF          reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FGETS           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    NAME            reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    RETURN          reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    UNSET           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    COUNT           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FOR             reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PRINT           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ECHO            reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ID              reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    INTEGER         reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FLOAT           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    STRING          reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    TRUE            reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FALSE           reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    LOGICAL_NOT     reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PUBLIC          reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PRIVATE         reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PROTECTED       reduce using rule 28 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)


state 253

    (34) parameter -> variable EQUALS . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    variable                       shift and go to state 109
    argument                       shift and go to state 274
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 254

    (148) class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    BREAK           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    IF              reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    WHILE           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    CLASS           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FSCANF          reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FGETS           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    NAME            reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    RETURN          reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    UNSET           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    COUNT           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FOR             reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    PRINT           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ECHO            reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ID              reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    INTEGER         reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FLOAT           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    STRING          reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    TRUE            reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FALSE           reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 148 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)


state 255

    (151) class_statements -> class_statements class_statement .

    RIGHT_BRACE     reduce using rule 151 (class_statements -> class_statements class_statement .)
    ONE_LINE_COMMENT reduce using rule 151 (class_statements -> class_statements class_statement .)
    MULTI_LINE_COMMENT reduce using rule 151 (class_statements -> class_statements class_statement .)
    PUBLIC          reduce using rule 151 (class_statements -> class_statements class_statement .)
    PRIVATE         reduce using rule 151 (class_statements -> class_statements class_statement .)
    PROTECTED       reduce using rule 151 (class_statements -> class_statements class_statement .)


state 256

    (156) method_declaration -> visibility_operator function_statement .

    RIGHT_BRACE     reduce using rule 156 (method_declaration -> visibility_operator function_statement .)
    ONE_LINE_COMMENT reduce using rule 156 (method_declaration -> visibility_operator function_statement .)
    MULTI_LINE_COMMENT reduce using rule 156 (method_declaration -> visibility_operator function_statement .)
    PUBLIC          reduce using rule 156 (method_declaration -> visibility_operator function_statement .)
    PRIVATE         reduce using rule 156 (method_declaration -> visibility_operator function_statement .)
    PROTECTED       reduce using rule 156 (method_declaration -> visibility_operator function_statement .)


state 257

    (157) property_declaration -> visibility_operator variable . SEMICOLON

    SEMICOLON       shift and go to state 275


state 258

    (135) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    DOT             reduce using rule 135 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 135 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    SEMICOLON       reduce using rule 135 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 135 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 135 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 259

    (138) array_elements -> array_elements COMMA array_argument .

    RIGHT_BRACKET   reduce using rule 138 (array_elements -> array_elements COMMA array_argument .)
    COMMA           reduce using rule 138 (array_elements -> array_elements COMMA array_argument .)
    RIGHT_PAREN     reduce using rule 138 (array_elements -> array_elements COMMA array_argument .)


state 260

    (140) array_argument -> clave KEY_VALUE argument .

    RIGHT_BRACKET   reduce using rule 140 (array_argument -> clave KEY_VALUE argument .)
    COMMA           reduce using rule 140 (array_argument -> clave KEY_VALUE argument .)
    RIGHT_PAREN     reduce using rule 140 (array_argument -> clave KEY_VALUE argument .)


state 261

    (143) array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .

    DOT             reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    COMMA           reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 143 (array_indexing -> variable LEFT_BRACKET clave RIGHT_BRACKET .)


state 262

    (29) anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN . block
    (105) block -> . LEFT_BRACE statements RIGHT_BRACE
    (106) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 139

    block                          shift and go to state 276

state 263

    (30) anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .

    DOT             reduce using rule 30 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    COMMA           reduce using rule 30 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    SEMICOLON       reduce using rule 30 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_PAREN     reduce using rule 30 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_BRACKET   reduce using rule 30 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)


state 264

    (161) object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .

    DOT             reduce using rule 161 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    COMMA           reduce using rule 161 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    SEMICOLON       reduce using rule 161 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 161 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 161 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)


state 265

    (162) object_creation -> NEW NAME LEFT_PAREN arguments . RIGHT_PAREN
    (58) arguments -> arguments . DOT argument
    (59) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 277
    DOT             shift and go to state 159
    COMMA           shift and go to state 160


state 266

    (39) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 278


state 267

    (145) array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS . argument
    (60) argument -> . STRING
    (61) argument -> . expression
    (62) argument -> . array
    (63) argument -> . array_indexing
    (64) argument -> . function_call
    (65) argument -> . ID CALL function_call
    (66) argument -> . anonymous_function
    (67) argument -> . assignment_statement
    (68) argument -> . fgets_statement
    (69) argument -> . object_creation
    (70) argument -> . casting argument
    (71) expression -> . expression PLUS term
    (72) expression -> . expression MINUS term
    (73) expression -> . term
    (135) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (136) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (143) array_indexing -> . variable LEFT_BRACKET clave RIGHT_BRACKET
    (36) function_call -> . NAME LEFT_PAREN arguments RIGHT_PAREN
    (37) function_call -> . NAME LEFT_PAREN RIGHT_PAREN
    (29) anonymous_function -> . FUNCTION LEFT_PAREN parameters RIGHT_PAREN block
    (30) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (44) assignment_statement -> . variable assignment_operator argument
    (45) assignment_statement -> . variable PLUS_PLUS
    (46) assignment_statement -> . variable MINUS_MINUS
    (38) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (161) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (162) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (131) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (74) term -> . term TIMES factor
    (75) term -> . term DIVIDE factor
    (76) term -> . term MOD factor
    (77) term -> . term POWER factor
    (78) term -> . factor
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME
    (79) factor -> . INTEGER
    (80) factor -> . FLOAT
    (81) factor -> . condition
    (82) factor -> . STRING
    (83) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (107) condition -> . simple_condition
    (108) condition -> . negated_condition
    (109) condition -> . complex_condition
    (110) condition -> . parenthesized_condition
    (111) simple_condition -> . TRUE
    (112) simple_condition -> . FALSE
    (113) simple_condition -> . variable
    (114) simple_condition -> . relational_expression
    (115) negated_condition -> . LOGICAL_NOT condition
    (116) complex_condition -> . condition logical_operator condition
    (117) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (118) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 96
    ID              shift and go to state 101
    ARRAY           shift and go to state 107
    LEFT_BRACKET    shift and go to state 108
    NAME            shift and go to state 34
    FUNCTION        shift and go to state 110
    FGETS           shift and go to state 40
    NEW             shift and go to state 111
    LEFT_PAREN      shift and go to state 125
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    LOGICAL_NOT     shift and go to state 59

    variable                       shift and go to state 109
    argument                       shift and go to state 279
    expression                     shift and go to state 97
    array                          shift and go to state 98
    array_indexing                 shift and go to state 99
    function_call                  shift and go to state 100
    anonymous_function             shift and go to state 102
    assignment_statement           shift and go to state 103
    fgets_statement                shift and go to state 104
    object_creation                shift and go to state 105
    casting                        shift and go to state 106
    term                           shift and go to state 45
    factor                         shift and go to state 50
    condition                      shift and go to state 32
    simple_condition               shift and go to state 53
    negated_condition              shift and go to state 54
    complex_condition              shift and go to state 55
    parenthesized_condition        shift and go to state 29
    relational_expression          shift and go to state 58

state 268

    (144) array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument .

    SEMICOLON       reduce using rule 144 (array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument .)
    RIGHT_PAREN     reduce using rule 144 (array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument .)
    COMMA           reduce using rule 144 (array_add_element -> variable LEFT_BRACKET RIGHT_BRACKET EQUALS argument .)


state 269

    (146) array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave . RIGHT_BRACKET RIGHT_PAREN

    RIGHT_BRACKET   shift and go to state 280


state 270

    (102) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 102 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 102 (assignment_list -> assignment_list COMMA assignment_statement .)


state 271

    (90) if_part2 -> ELSEIF parenthesized_condition block .

    ELSE            reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    ELSEIF          reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLOSE_TAG       reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    BREAK           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    CONTINUE        reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    IF              reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    WHILE           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    FUNCTION        reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLASS           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    FSCANF          reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    FGETS           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    NAME            reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    RETURN          reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    UNSET           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    COUNT           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    FOR             reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    PRINT           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    ECHO            reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    ID              reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    INTEGER         reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    FLOAT           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    STRING          reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    TRUE            reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    FALSE           reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 90 (if_part2 -> ELSEIF parenthesized_condition block .)


state 272

    (27) function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    BREAK           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    CONTINUE        reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    IF              reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    WHILE           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    FUNCTION        reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    CLASS           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    FSCANF          reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    FGETS           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    NAME            reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    RETURN          reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    UNSET           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    COUNT           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    FOR             reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    PRINT           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    ECHO            reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    ID              reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    INTEGER         reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    FLOAT           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    STRING          reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    TRUE            reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    FALSE           reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    LOGICAL_NOT     reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    PUBLIC          reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    PRIVATE         reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)
    PROTECTED       reduce using rule 27 (function_statement -> FUNCTION NAME LEFT_PAREN parameters RIGHT_PAREN block .)


state 273

    (32) parameters -> parameters COMMA parameter .

    RIGHT_PAREN     reduce using rule 32 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 32 (parameters -> parameters COMMA parameter .)


state 274

    (34) parameter -> variable EQUALS argument .

    RIGHT_PAREN     reduce using rule 34 (parameter -> variable EQUALS argument .)
    COMMA           reduce using rule 34 (parameter -> variable EQUALS argument .)


state 275

    (157) property_declaration -> visibility_operator variable SEMICOLON .

    RIGHT_BRACE     reduce using rule 157 (property_declaration -> visibility_operator variable SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 157 (property_declaration -> visibility_operator variable SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 157 (property_declaration -> visibility_operator variable SEMICOLON .)
    PUBLIC          reduce using rule 157 (property_declaration -> visibility_operator variable SEMICOLON .)
    PRIVATE         reduce using rule 157 (property_declaration -> visibility_operator variable SEMICOLON .)
    PROTECTED       reduce using rule 157 (property_declaration -> visibility_operator variable SEMICOLON .)


state 276

    (29) anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block .

    DOT             reduce using rule 29 (anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block .)
    COMMA           reduce using rule 29 (anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block .)
    SEMICOLON       reduce using rule 29 (anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block .)
    RIGHT_PAREN     reduce using rule 29 (anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block .)
    RIGHT_BRACKET   reduce using rule 29 (anonymous_function -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN block .)


state 277

    (162) object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .

    DOT             reduce using rule 162 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 162 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    SEMICOLON       reduce using rule 162 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 162 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 162 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)


state 278

    (39) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (40) variable_list -> . variable
    (41) variable_list -> . variable_list COMMA variable
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    ID              shift and go to state 49

    variable_list                  shift and go to state 281
    variable                       shift and go to state 282

state 279

    (145) array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument .

    SEMICOLON       reduce using rule 145 (array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument .)
    RIGHT_PAREN     reduce using rule 145 (array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument .)
    COMMA           reduce using rule 145 (array_modify_element -> variable LEFT_BRACKET clave RIGHT_BRACKET EQUALS argument .)


state 280

    (146) array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 283


state 281

    (39) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (41) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 285
    COMMA           shift and go to state 284


state 282

    (40) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 40 (variable_list -> variable .)
    COMMA           reduce using rule 40 (variable_list -> variable .)


state 283

    (146) array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN .

    SEMICOLON       reduce using rule 146 (array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 146 (array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN .)
    COMMA           reduce using rule 146 (array_remove_element -> UNSET LEFT_PAREN variable LEFT_BRACKET clave RIGHT_BRACKET RIGHT_PAREN .)


state 284

    (41) variable_list -> variable_list COMMA . variable
    (42) variable -> . ID
    (43) variable -> . ID CALL NAME

    ID              shift and go to state 49

    variable                       shift and go to state 286

state 285

    (39) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 39 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 39 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 39 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)


state 286

    (41) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 41 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 41 (variable_list -> variable_list COMMA variable .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 32 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 32 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 32 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 45 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 45 resolved as shift
WARNING: shift/reduce conflict for MOD in state 45 resolved as shift
WARNING: shift/reduce conflict for POWER in state 45 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 91 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 94 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 117 resolved as shift
WARNING: shift/reduce conflict for LEFT_BRACKET in state 117 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 124 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 134 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 135 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 135 resolved as shift
WARNING: shift/reduce conflict for MOD in state 135 resolved as shift
WARNING: shift/reduce conflict for POWER in state 135 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 136 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 136 resolved as shift
WARNING: shift/reduce conflict for MOD in state 136 resolved as shift
WARNING: shift/reduce conflict for POWER in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 137 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL_TO in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 137 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for IDENTICAL_TO in state 137 resolved as shift
WARNING: shift/reduce conflict for NOT_IDENTICAL_TO in state 137 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 137 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 145 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 145 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 145 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 155 resolved as shift
WARNING: reduce/reduce conflict in state 96 resolved using rule (argument -> STRING)
WARNING: rejected rule (factor -> STRING) in state 96
WARNING: reduce/reduce conflict in state 134 resolved using rule (factor -> condition)
WARNING: rejected rule (negated_condition -> LOGICAL_NOT condition) in state 134
WARNING: reduce/reduce conflict in state 135 resolved using rule (expression -> expression PLUS term)
WARNING: rejected rule (expression -> term) in state 135
WARNING: reduce/reduce conflict in state 136 resolved using rule (expression -> expression MINUS term)
WARNING: rejected rule (expression -> term) in state 136
WARNING: reduce/reduce conflict in state 145 resolved using rule (factor -> condition)
WARNING: rejected rule (complex_condition -> condition logical_operator condition) in state 145
WARNING: reduce/reduce conflict in state 168 resolved using rule (argument -> STRING)
WARNING: rejected rule (factor -> STRING) in state 168
WARNING: reduce/reduce conflict in state 184 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 184
WARNING: reduce/reduce conflict in state 185 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 185
WARNING: reduce/reduce conflict in state 186 resolved using rule (term -> term MOD factor)
WARNING: rejected rule (term -> factor) in state 186
WARNING: reduce/reduce conflict in state 187 resolved using rule (term -> term POWER factor)
WARNING: rejected rule (term -> factor) in state 187
