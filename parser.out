Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    AS
    ASYNC
    AWAIT
    BOOL
    CALL
    CALLABLE
    CASE
    CATCH
    CLASS
    CLONE
    COLON
    CONST
    DECLARE
    DEFAULT
    DIE
    DO
    ELSEIF
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FINAL
    FINALLY
    FN
    FOREACH
    FUNCTION
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    KEY_VALUE
    LIST
    LPAREN
    MATCH
    MIXED
    MOD
    NAME
    NAMESPACE
    NEW
    NULL
    OBJECT
    OR
    POWER
    PRIVATE
    PROTECTED
    PUBLIC
    REQUIRE
    REQUIRE_ONCE
    RETURN
    RPAREN
    SELF
    STATIC
    SWITCH
    THROW
    TRAIT
    TRY
    UNSET
    USE
    VAR
    VOID
    XOR
    YIELD
    YIELD_FROM

Grammar

Rule 0     S' -> program
Rule 1     program -> OPEN_TAG statements CLOSE_TAG
Rule 2     statements -> statement2
Rule 3     statements -> statements statement2
Rule 4     statement2 -> statement SEMICOLON
Rule 5     statement2 -> if_statement
Rule 6     statement2 -> while_statement
Rule 7     statement2 -> for_statement
Rule 8     statement2 -> ONE_LINE_COMMENT
Rule 9     statement2 -> MULTI_LINE_COMMENT
Rule 10    statement -> print_statement
Rule 11    statement -> fscanf_statement
Rule 12    statement -> fgets_statement
Rule 13    statement -> assignment_statement
Rule 14    statement -> array_declaration_statement
Rule 15    statement -> BREAK
Rule 16    statement -> CONTINUE
Rule 17    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 18    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 19    variable_list -> variable
Rule 20    variable_list -> variable_list COMMA variable
Rule 21    variable -> ID
Rule 22    assignment_operator -> EQUALS
Rule 23    assignment_operator -> PLUS_EQUALS
Rule 24    assignment_operator -> MINUS_EQUALS
Rule 25    assignment_operator -> TIMES_EQUALS
Rule 26    assignment_operator -> DIVIDE_EQUALS
Rule 27    assignment_operator -> MOD_EQUALS
Rule 28    assignment_statement -> variable assignment_operator argument
Rule 29    assignment_statement -> variable PLUS_PLUS
Rule 30    assignment_statement -> variable MINUS_MINUS
Rule 31    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 32    print_statement -> print_function arguments
Rule 33    print_function -> PRINT
Rule 34    print_function -> ECHO
Rule 35    arguments -> argument
Rule 36    arguments -> arguments DOT argument
Rule 37    argument -> INTEGER
Rule 38    argument -> FLOAT
Rule 39    argument -> STRING
Rule 40    argument -> variable
Rule 41    argument -> expression
Rule 42    argument -> condition
Rule 43    argument -> assignment_statement
Rule 44    expression -> expression PLUS term
Rule 45    expression -> expression MINUS term
Rule 46    expression -> term
Rule 47    term -> term TIMES factor
Rule 48    term -> term DIVIDE factor
Rule 49    term -> factor
Rule 50    factor -> INTEGER
Rule 51    factor -> FLOAT
Rule 52    factor -> variable
Rule 53    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 54    if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block
Rule 55    if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
Rule 56    while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block
Rule 57    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 58    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 59    for_statement -> for_part1 condition for_part3
Rule 60    for_statement -> for_part1 for_part3
Rule 61    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 62    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 63    for_part4 -> block
Rule 64    for_part4 -> SEMICOLON
Rule 65    assignment_list -> assignment_statement
Rule 66    assignment_list -> assignment_list COMMA assignment_statement
Rule 67    statement_list -> statement
Rule 68    statement_list -> statement_list COMMA statement
Rule 69    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 70    block -> LEFT_BRACE RIGHT_BRACE
Rule 71    condition -> TRUE
Rule 72    condition -> FALSE
Rule 73    condition -> expression relational_operator expression
Rule 74    condition -> condition logical_operator condition
Rule 75    condition -> LOGICAL_NOT condition
Rule 76    condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 77    relational_operator -> EQUAL_TO
Rule 78    relational_operator -> NOT_EQUAL_TO
Rule 79    relational_operator -> LESS_THAN
Rule 80    relational_operator -> GREATER_THAN
Rule 81    relational_operator -> LESS_EQUAL
Rule 82    relational_operator -> GREATER_EQUAL
Rule 83    relational_operator -> IDENTICAL_TO
Rule 84    relational_operator -> NOT_IDENTICAL_TO
Rule 85    relational_operator -> DIFFERENT
Rule 86    logical_operator -> LOGICAL_AND
Rule 87    logical_operator -> LOGICAL_OR
Rule 88    logical_operator -> LOGICAL_XOR
Rule 89    array_declaration_statement -> variable EQUALS array
Rule 90    array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 91    array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 92    array_elements -> argument
Rule 93    array_elements -> array_elements COMMA argument

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
ARRAY                : 90
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 15
CALL                 : 
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 1
COLON                : 
COMMA                : 18 18 20 66 68 93
CONST                : 
CONTINUE             : 16
DECLARE              : 
DEFAULT              : 
DIE                  : 
DIFFERENT            : 85
DIVIDE               : 48
DIVIDE_EQUALS        : 26
DO                   : 
DOT                  : 36
ECHO                 : 34
ELSE                 : 55
ELSEIF               : 
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENUM                 : 
EQUALS               : 22 89
EQUAL_TO             : 77
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 72
FGETS                : 17
FINAL                : 
FINALLY              : 
FLOAT                : 38 51
FN                   : 
FOR                  : 57 58
FOREACH              : 
FSCANF               : 18
FUNCTION             : 
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 82
GREATER_THAN         : 80
HALT_COMPILER        : 
ID                   : 21
IDENTICAL_TO         : 83
IF                   : 54 55
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 37 50
INTERFACE            : 
ISSET                : 
ITERABLE             : 
KEY_VALUE            : 
LEFT_BRACE           : 69 70
LEFT_BRACKET         : 91
LEFT_PAREN           : 17 18 31 53 54 55 56 57 58 76 90
LESS_EQUAL           : 81
LESS_THAN            : 79
LIST                 : 
LOGICAL_AND          : 86
LOGICAL_NOT          : 75
LOGICAL_OR           : 87
LOGICAL_XOR          : 88
LPAREN               : 
MATCH                : 
MINUS                : 45
MINUS_EQUALS         : 24
MINUS_MINUS          : 30
MIXED                : 
MOD                  : 
MOD_EQUALS           : 27
MULTI_LINE_COMMENT   : 9
NAME                 : 
NAMESPACE            : 
NEW                  : 
NOT_EQUAL_TO         : 78
NOT_IDENTICAL_TO     : 84
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 8
OPEN_TAG             : 1
OR                   : 
PLUS                 : 44
PLUS_EQUALS          : 23
PLUS_PLUS            : 29
POWER                : 
PRINT                : 33
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 
RIGHT_BRACE          : 69 70
RIGHT_BRACKET        : 91
RIGHT_PAREN          : 17 18 31 53 54 55 56 61 62 76 90
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 57 58 61 62 64
STATIC               : 
STDIN                : 17 18
STRING               : 18 39
SWITCH               : 
THROW                : 
TIMES                : 47
TIMES_EQUALS         : 25
TRAIT                : 
TRUE                 : 71
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
VOID                 : 
WHILE                : 56
XOR                  : 
YIELD                : 
YIELD_FROM           : 
error                : 

Nonterminals, with rules where they appear

argument             : 28 35 36 92 93
arguments            : 31 32 36
array                : 89
array_declaration_statement : 14
array_elements       : 90 91 93
assignment_list      : 57 66
assignment_operator  : 28
assignment_statement : 13 43 65 66
block                : 54 55 55 56 63
condition            : 42 54 55 56 59 74 74 75 76
expression           : 41 44 45 53 73 73
factor               : 47 48 49
fgets_statement      : 12
for_part1            : 59 60
for_part3            : 59 60
for_part4            : 61 62
for_statement        : 7
fscanf_statement     : 11
if_statement         : 5
logical_operator     : 74
print_function       : 31 32
print_statement      : 10
program              : 0
relational_operator  : 73
statement            : 4 67 68
statement2           : 2 3
statement_list       : 61 68
statements           : 1 3 69
term                 : 44 45 46 47 48
variable             : 19 20 28 29 30 40 52 89
variable_list        : 18 20
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . OPEN_TAG statements CLOSE_TAG

    OPEN_TAG        shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> OPEN_TAG . statements CLOSE_TAG
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (54) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (55) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (56) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (59) for_statement -> . for_part1 condition for_part3
    (60) for_statement -> . for_part1 for_part3
    (31) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> . print_function arguments
    (18) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (17) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (89) array_declaration_statement -> . variable EQUALS array
    (57) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (58) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (33) print_function -> . PRINT
    (34) print_function -> . ECHO
    (21) variable -> . ID

    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FSCANF          shift and go to state 22
    FGETS           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    ECHO            shift and go to state 27
    ID              shift and go to state 28

    statements                     shift and go to state 3
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    for_part1                      shift and go to state 20
    print_function                 shift and go to state 21
    variable                       shift and go to state 24

state 3

    (1) program -> OPEN_TAG statements . CLOSE_TAG
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (54) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (55) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (56) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (59) for_statement -> . for_part1 condition for_part3
    (60) for_statement -> . for_part1 for_part3
    (31) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> . print_function arguments
    (18) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (17) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (89) array_declaration_statement -> . variable EQUALS array
    (57) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (58) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (33) print_function -> . PRINT
    (34) print_function -> . ECHO
    (21) variable -> . ID

    CLOSE_TAG       shift and go to state 29
    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FSCANF          shift and go to state 22
    FGETS           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    ECHO            shift and go to state 27
    ID              shift and go to state 28

    statement2                     shift and go to state 30
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    for_part1                      shift and go to state 20
    print_function                 shift and go to state 21
    variable                       shift and go to state 24

state 4

    (2) statements -> statement2 .

    CLOSE_TAG       reduce using rule 2 (statements -> statement2 .)
    ONE_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    MULTI_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    BREAK           reduce using rule 2 (statements -> statement2 .)
    CONTINUE        reduce using rule 2 (statements -> statement2 .)
    IF              reduce using rule 2 (statements -> statement2 .)
    WHILE           reduce using rule 2 (statements -> statement2 .)
    FSCANF          reduce using rule 2 (statements -> statement2 .)
    FGETS           reduce using rule 2 (statements -> statement2 .)
    FOR             reduce using rule 2 (statements -> statement2 .)
    PRINT           reduce using rule 2 (statements -> statement2 .)
    ECHO            reduce using rule 2 (statements -> statement2 .)
    ID              reduce using rule 2 (statements -> statement2 .)
    RIGHT_BRACE     reduce using rule 2 (statements -> statement2 .)


state 5

    (4) statement2 -> statement . SEMICOLON

    SEMICOLON       shift and go to state 31


state 6

    (5) statement2 -> if_statement .

    CLOSE_TAG       reduce using rule 5 (statement2 -> if_statement .)
    ONE_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    MULTI_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    BREAK           reduce using rule 5 (statement2 -> if_statement .)
    CONTINUE        reduce using rule 5 (statement2 -> if_statement .)
    IF              reduce using rule 5 (statement2 -> if_statement .)
    WHILE           reduce using rule 5 (statement2 -> if_statement .)
    FSCANF          reduce using rule 5 (statement2 -> if_statement .)
    FGETS           reduce using rule 5 (statement2 -> if_statement .)
    FOR             reduce using rule 5 (statement2 -> if_statement .)
    PRINT           reduce using rule 5 (statement2 -> if_statement .)
    ECHO            reduce using rule 5 (statement2 -> if_statement .)
    ID              reduce using rule 5 (statement2 -> if_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement2 -> if_statement .)


state 7

    (6) statement2 -> while_statement .

    CLOSE_TAG       reduce using rule 6 (statement2 -> while_statement .)
    ONE_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    MULTI_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    BREAK           reduce using rule 6 (statement2 -> while_statement .)
    CONTINUE        reduce using rule 6 (statement2 -> while_statement .)
    IF              reduce using rule 6 (statement2 -> while_statement .)
    WHILE           reduce using rule 6 (statement2 -> while_statement .)
    FSCANF          reduce using rule 6 (statement2 -> while_statement .)
    FGETS           reduce using rule 6 (statement2 -> while_statement .)
    FOR             reduce using rule 6 (statement2 -> while_statement .)
    PRINT           reduce using rule 6 (statement2 -> while_statement .)
    ECHO            reduce using rule 6 (statement2 -> while_statement .)
    ID              reduce using rule 6 (statement2 -> while_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement2 -> while_statement .)


state 8

    (7) statement2 -> for_statement .

    CLOSE_TAG       reduce using rule 7 (statement2 -> for_statement .)
    ONE_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    MULTI_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    BREAK           reduce using rule 7 (statement2 -> for_statement .)
    CONTINUE        reduce using rule 7 (statement2 -> for_statement .)
    IF              reduce using rule 7 (statement2 -> for_statement .)
    WHILE           reduce using rule 7 (statement2 -> for_statement .)
    FSCANF          reduce using rule 7 (statement2 -> for_statement .)
    FGETS           reduce using rule 7 (statement2 -> for_statement .)
    FOR             reduce using rule 7 (statement2 -> for_statement .)
    PRINT           reduce using rule 7 (statement2 -> for_statement .)
    ECHO            reduce using rule 7 (statement2 -> for_statement .)
    ID              reduce using rule 7 (statement2 -> for_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement2 -> for_statement .)


state 9

    (8) statement2 -> ONE_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)


state 10

    (9) statement2 -> MULTI_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)


state 11

    (10) statement -> print_statement .

    SEMICOLON       reduce using rule 10 (statement -> print_statement .)
    RIGHT_PAREN     reduce using rule 10 (statement -> print_statement .)
    COMMA           reduce using rule 10 (statement -> print_statement .)


state 12

    (11) statement -> fscanf_statement .

    SEMICOLON       reduce using rule 11 (statement -> fscanf_statement .)
    RIGHT_PAREN     reduce using rule 11 (statement -> fscanf_statement .)
    COMMA           reduce using rule 11 (statement -> fscanf_statement .)


state 13

    (12) statement -> fgets_statement .

    SEMICOLON       reduce using rule 12 (statement -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 12 (statement -> fgets_statement .)
    COMMA           reduce using rule 12 (statement -> fgets_statement .)


state 14

    (13) statement -> assignment_statement .

    SEMICOLON       reduce using rule 13 (statement -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 13 (statement -> assignment_statement .)
    COMMA           reduce using rule 13 (statement -> assignment_statement .)


state 15

    (14) statement -> array_declaration_statement .

    SEMICOLON       reduce using rule 14 (statement -> array_declaration_statement .)
    RIGHT_PAREN     reduce using rule 14 (statement -> array_declaration_statement .)
    COMMA           reduce using rule 14 (statement -> array_declaration_statement .)


state 16

    (15) statement -> BREAK .

    SEMICOLON       reduce using rule 15 (statement -> BREAK .)
    RIGHT_PAREN     reduce using rule 15 (statement -> BREAK .)
    COMMA           reduce using rule 15 (statement -> BREAK .)


state 17

    (16) statement -> CONTINUE .

    SEMICOLON       reduce using rule 16 (statement -> CONTINUE .)
    RIGHT_PAREN     reduce using rule 16 (statement -> CONTINUE .)
    COMMA           reduce using rule 16 (statement -> CONTINUE .)


state 18

    (54) if_statement -> IF . LEFT_PAREN condition RIGHT_PAREN block
    (55) if_statement -> IF . LEFT_PAREN condition RIGHT_PAREN block ELSE block

    LEFT_PAREN      shift and go to state 32


state 19

    (56) while_statement -> WHILE . LEFT_PAREN condition RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 33


state 20

    (59) for_statement -> for_part1 . condition for_part3
    (60) for_statement -> for_part1 . for_part3
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (61) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (62) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    SEMICOLON       shift and go to state 41
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 28

    condition                      shift and go to state 34
    for_part3                      shift and go to state 35
    expression                     shift and go to state 38
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 21

    (31) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> print_function . arguments
    (35) arguments -> . argument
    (36) arguments -> . arguments DOT argument
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (21) variable -> . ID
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 47
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39

    arguments                      shift and go to state 48
    argument                       shift and go to state 49
    variable                       shift and go to state 53
    expression                     shift and go to state 54
    condition                      shift and go to state 55
    assignment_statement           shift and go to state 56
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 22

    (18) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 57


state 23

    (17) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 58


state 24

    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (89) array_declaration_statement -> variable . EQUALS array
    (22) assignment_operator -> . EQUALS
    (23) assignment_operator -> . PLUS_EQUALS
    (24) assignment_operator -> . MINUS_EQUALS
    (25) assignment_operator -> . TIMES_EQUALS
    (26) assignment_operator -> . DIVIDE_EQUALS
    (27) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 60
    MINUS_MINUS     shift and go to state 61
    EQUALS          shift and go to state 62
    PLUS_EQUALS     shift and go to state 63
    MINUS_EQUALS    shift and go to state 64
    TIMES_EQUALS    shift and go to state 65
    DIVIDE_EQUALS   shift and go to state 66
    MOD_EQUALS      shift and go to state 67

    assignment_operator            shift and go to state 59

state 25

    (57) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (58) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 68


state 26

    (33) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 33 (print_function -> PRINT .)
    INTEGER         reduce using rule 33 (print_function -> PRINT .)
    FLOAT           reduce using rule 33 (print_function -> PRINT .)
    STRING          reduce using rule 33 (print_function -> PRINT .)
    ID              reduce using rule 33 (print_function -> PRINT .)
    TRUE            reduce using rule 33 (print_function -> PRINT .)
    FALSE           reduce using rule 33 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 33 (print_function -> PRINT .)


state 27

    (34) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 34 (print_function -> ECHO .)
    INTEGER         reduce using rule 34 (print_function -> ECHO .)
    FLOAT           reduce using rule 34 (print_function -> ECHO .)
    STRING          reduce using rule 34 (print_function -> ECHO .)
    ID              reduce using rule 34 (print_function -> ECHO .)
    TRUE            reduce using rule 34 (print_function -> ECHO .)
    FALSE           reduce using rule 34 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 34 (print_function -> ECHO .)


state 28

    (21) variable -> ID .

    PLUS_PLUS       reduce using rule 21 (variable -> ID .)
    MINUS_MINUS     reduce using rule 21 (variable -> ID .)
    EQUALS          reduce using rule 21 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 21 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 21 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 21 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 21 (variable -> ID .)
    MOD_EQUALS      reduce using rule 21 (variable -> ID .)
    TIMES           reduce using rule 21 (variable -> ID .)
    DIVIDE          reduce using rule 21 (variable -> ID .)
    PLUS            reduce using rule 21 (variable -> ID .)
    MINUS           reduce using rule 21 (variable -> ID .)
    EQUAL_TO        reduce using rule 21 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 21 (variable -> ID .)
    LESS_THAN       reduce using rule 21 (variable -> ID .)
    GREATER_THAN    reduce using rule 21 (variable -> ID .)
    LESS_EQUAL      reduce using rule 21 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 21 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 21 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 21 (variable -> ID .)
    DIFFERENT       reduce using rule 21 (variable -> ID .)
    DOT             reduce using rule 21 (variable -> ID .)
    SEMICOLON       reduce using rule 21 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 21 (variable -> ID .)
    COMMA           reduce using rule 21 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 21 (variable -> ID .)
    LOGICAL_AND     reduce using rule 21 (variable -> ID .)
    LOGICAL_OR      reduce using rule 21 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 21 (variable -> ID .)


state 29

    (1) program -> OPEN_TAG statements CLOSE_TAG .

    $end            reduce using rule 1 (program -> OPEN_TAG statements CLOSE_TAG .)


state 30

    (3) statements -> statements statement2 .

    CLOSE_TAG       reduce using rule 3 (statements -> statements statement2 .)
    ONE_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    MULTI_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    BREAK           reduce using rule 3 (statements -> statements statement2 .)
    CONTINUE        reduce using rule 3 (statements -> statements statement2 .)
    IF              reduce using rule 3 (statements -> statements statement2 .)
    WHILE           reduce using rule 3 (statements -> statements statement2 .)
    FSCANF          reduce using rule 3 (statements -> statements statement2 .)
    FGETS           reduce using rule 3 (statements -> statements statement2 .)
    FOR             reduce using rule 3 (statements -> statements statement2 .)
    PRINT           reduce using rule 3 (statements -> statements statement2 .)
    ECHO            reduce using rule 3 (statements -> statements statement2 .)
    ID              reduce using rule 3 (statements -> statements statement2 .)
    RIGHT_BRACE     reduce using rule 3 (statements -> statements statement2 .)


state 31

    (4) statement2 -> statement SEMICOLON .

    CLOSE_TAG       reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    BREAK           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    IF              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FSCANF          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FGETS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FOR             reduce using rule 4 (statement2 -> statement SEMICOLON .)
    PRINT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ECHO            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ID              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RIGHT_BRACE     reduce using rule 4 (statement2 -> statement SEMICOLON .)


state 32

    (54) if_statement -> IF LEFT_PAREN . condition RIGHT_PAREN block
    (55) if_statement -> IF LEFT_PAREN . condition RIGHT_PAREN block ELSE block
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 28

    condition                      shift and go to state 69
    expression                     shift and go to state 38
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 33

    (56) while_statement -> WHILE LEFT_PAREN . condition RIGHT_PAREN block
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 28

    condition                      shift and go to state 70
    expression                     shift and go to state 38
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 34

    (59) for_statement -> for_part1 condition . for_part3
    (74) condition -> condition . logical_operator condition
    (61) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (62) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

    SEMICOLON       shift and go to state 41
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

    for_part3                      shift and go to state 71
    logical_operator               shift and go to state 72

state 35

    (60) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 60 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 60 (for_statement -> for_part1 for_part3 .)


state 36

    (71) condition -> TRUE .

    SEMICOLON       reduce using rule 71 (condition -> TRUE .)
    LOGICAL_AND     reduce using rule 71 (condition -> TRUE .)
    LOGICAL_OR      reduce using rule 71 (condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 71 (condition -> TRUE .)
    DOT             reduce using rule 71 (condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 71 (condition -> TRUE .)
    COMMA           reduce using rule 71 (condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 71 (condition -> TRUE .)


state 37

    (72) condition -> FALSE .

    SEMICOLON       reduce using rule 72 (condition -> FALSE .)
    LOGICAL_AND     reduce using rule 72 (condition -> FALSE .)
    LOGICAL_OR      reduce using rule 72 (condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 72 (condition -> FALSE .)
    DOT             reduce using rule 72 (condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 72 (condition -> FALSE .)
    COMMA           reduce using rule 72 (condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 72 (condition -> FALSE .)


state 38

    (73) condition -> expression . relational_operator expression
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (77) relational_operator -> . EQUAL_TO
    (78) relational_operator -> . NOT_EQUAL_TO
    (79) relational_operator -> . LESS_THAN
    (80) relational_operator -> . GREATER_THAN
    (81) relational_operator -> . LESS_EQUAL
    (82) relational_operator -> . GREATER_EQUAL
    (83) relational_operator -> . IDENTICAL_TO
    (84) relational_operator -> . NOT_IDENTICAL_TO
    (85) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    EQUAL_TO        shift and go to state 79
    NOT_EQUAL_TO    shift and go to state 80
    LESS_THAN       shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_EQUAL      shift and go to state 83
    GREATER_EQUAL   shift and go to state 84
    IDENTICAL_TO    shift and go to state 85
    NOT_IDENTICAL_TO shift and go to state 86
    DIFFERENT       shift and go to state 87

    relational_operator            shift and go to state 76

state 39

    (75) condition -> LOGICAL_NOT . condition
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 28

    condition                      shift and go to state 88
    expression                     shift and go to state 38
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 40

    (76) condition -> LEFT_PAREN . condition RIGHT_PAREN
    (53) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 28

    condition                      shift and go to state 89
    expression                     shift and go to state 90
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 41

    (61) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (62) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (67) statement_list -> . statement
    (68) statement_list -> . statement_list COMMA statement
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (31) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> . print_function arguments
    (18) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (17) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (89) array_declaration_statement -> . variable EQUALS array
    (33) print_function -> . PRINT
    (34) print_function -> . ECHO
    (21) variable -> . ID

    RIGHT_PAREN     shift and go to state 92
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    FSCANF          shift and go to state 22
    FGETS           shift and go to state 23
    PRINT           shift and go to state 26
    ECHO            shift and go to state 27
    ID              shift and go to state 28

    statement_list                 shift and go to state 91
    statement                      shift and go to state 93
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    print_function                 shift and go to state 21
    variable                       shift and go to state 24

state 42

    (46) expression -> term .
    (47) term -> term . TIMES factor
    (48) term -> term . DIVIDE factor

    PLUS            reduce using rule 46 (expression -> term .)
    MINUS           reduce using rule 46 (expression -> term .)
    EQUAL_TO        reduce using rule 46 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 46 (expression -> term .)
    LESS_THAN       reduce using rule 46 (expression -> term .)
    GREATER_THAN    reduce using rule 46 (expression -> term .)
    LESS_EQUAL      reduce using rule 46 (expression -> term .)
    GREATER_EQUAL   reduce using rule 46 (expression -> term .)
    IDENTICAL_TO    reduce using rule 46 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 46 (expression -> term .)
    DIFFERENT       reduce using rule 46 (expression -> term .)
    DOT             reduce using rule 46 (expression -> term .)
    SEMICOLON       reduce using rule 46 (expression -> term .)
    RIGHT_PAREN     reduce using rule 46 (expression -> term .)
    COMMA           reduce using rule 46 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 46 (expression -> term .)
    LOGICAL_AND     reduce using rule 46 (expression -> term .)
    LOGICAL_OR      reduce using rule 46 (expression -> term .)
    LOGICAL_XOR     reduce using rule 46 (expression -> term .)
    TIMES           shift and go to state 94
    DIVIDE          shift and go to state 95


state 43

    (49) term -> factor .

    TIMES           reduce using rule 49 (term -> factor .)
    DIVIDE          reduce using rule 49 (term -> factor .)
    PLUS            reduce using rule 49 (term -> factor .)
    MINUS           reduce using rule 49 (term -> factor .)
    EQUAL_TO        reduce using rule 49 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 49 (term -> factor .)
    LESS_THAN       reduce using rule 49 (term -> factor .)
    GREATER_THAN    reduce using rule 49 (term -> factor .)
    LESS_EQUAL      reduce using rule 49 (term -> factor .)
    GREATER_EQUAL   reduce using rule 49 (term -> factor .)
    IDENTICAL_TO    reduce using rule 49 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 49 (term -> factor .)
    DIFFERENT       reduce using rule 49 (term -> factor .)
    DOT             reduce using rule 49 (term -> factor .)
    SEMICOLON       reduce using rule 49 (term -> factor .)
    RIGHT_PAREN     reduce using rule 49 (term -> factor .)
    COMMA           reduce using rule 49 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 49 (term -> factor .)
    LOGICAL_AND     reduce using rule 49 (term -> factor .)
    LOGICAL_OR      reduce using rule 49 (term -> factor .)
    LOGICAL_XOR     reduce using rule 49 (term -> factor .)


state 44

    (50) factor -> INTEGER .

    TIMES           reduce using rule 50 (factor -> INTEGER .)
    DIVIDE          reduce using rule 50 (factor -> INTEGER .)
    PLUS            reduce using rule 50 (factor -> INTEGER .)
    MINUS           reduce using rule 50 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 50 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 50 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 50 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 50 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 50 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 50 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 50 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 50 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 50 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 50 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 50 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 50 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 50 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 50 (factor -> INTEGER .)
    DOT             reduce using rule 50 (factor -> INTEGER .)
    COMMA           reduce using rule 50 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 50 (factor -> INTEGER .)


state 45

    (51) factor -> FLOAT .

    TIMES           reduce using rule 51 (factor -> FLOAT .)
    DIVIDE          reduce using rule 51 (factor -> FLOAT .)
    PLUS            reduce using rule 51 (factor -> FLOAT .)
    MINUS           reduce using rule 51 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 51 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 51 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 51 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 51 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 51 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 51 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 51 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 51 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 51 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 51 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 51 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 51 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 51 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 51 (factor -> FLOAT .)
    DOT             reduce using rule 51 (factor -> FLOAT .)
    COMMA           reduce using rule 51 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 51 (factor -> FLOAT .)


state 46

    (52) factor -> variable .

    TIMES           reduce using rule 52 (factor -> variable .)
    DIVIDE          reduce using rule 52 (factor -> variable .)
    PLUS            reduce using rule 52 (factor -> variable .)
    MINUS           reduce using rule 52 (factor -> variable .)
    EQUAL_TO        reduce using rule 52 (factor -> variable .)
    NOT_EQUAL_TO    reduce using rule 52 (factor -> variable .)
    LESS_THAN       reduce using rule 52 (factor -> variable .)
    GREATER_THAN    reduce using rule 52 (factor -> variable .)
    LESS_EQUAL      reduce using rule 52 (factor -> variable .)
    GREATER_EQUAL   reduce using rule 52 (factor -> variable .)
    IDENTICAL_TO    reduce using rule 52 (factor -> variable .)
    NOT_IDENTICAL_TO reduce using rule 52 (factor -> variable .)
    DIFFERENT       reduce using rule 52 (factor -> variable .)
    RIGHT_PAREN     reduce using rule 52 (factor -> variable .)
    SEMICOLON       reduce using rule 52 (factor -> variable .)
    LOGICAL_AND     reduce using rule 52 (factor -> variable .)
    LOGICAL_OR      reduce using rule 52 (factor -> variable .)
    LOGICAL_XOR     reduce using rule 52 (factor -> variable .)
    DOT             reduce using rule 52 (factor -> variable .)
    COMMA           reduce using rule 52 (factor -> variable .)
    RIGHT_BRACKET   reduce using rule 52 (factor -> variable .)


state 47

    (31) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (76) condition -> LEFT_PAREN . condition RIGHT_PAREN
    (53) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (35) arguments -> . argument
    (36) arguments -> . arguments DOT argument
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (21) variable -> . ID
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28

    arguments                      shift and go to state 96
    condition                      shift and go to state 97
    expression                     shift and go to state 98
    argument                       shift and go to state 49
    term                           shift and go to state 42
    variable                       shift and go to state 53
    assignment_statement           shift and go to state 56
    factor                         shift and go to state 43

state 48

    (32) print_statement -> print_function arguments .
    (36) arguments -> arguments . DOT argument

    SEMICOLON       reduce using rule 32 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 32 (print_statement -> print_function arguments .)
    COMMA           reduce using rule 32 (print_statement -> print_function arguments .)
    DOT             shift and go to state 99


state 49

    (35) arguments -> argument .

    DOT             reduce using rule 35 (arguments -> argument .)
    SEMICOLON       reduce using rule 35 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 35 (arguments -> argument .)
    COMMA           reduce using rule 35 (arguments -> argument .)


state 50

    (37) argument -> INTEGER .
    (50) factor -> INTEGER .

  ! reduce/reduce conflict for DOT resolved using rule 37 (argument -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (argument -> INTEGER .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 37 (argument -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (argument -> INTEGER .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 37 (argument -> INTEGER .)
    DOT             reduce using rule 37 (argument -> INTEGER .)
    SEMICOLON       reduce using rule 37 (argument -> INTEGER .)
    RIGHT_PAREN     reduce using rule 37 (argument -> INTEGER .)
    COMMA           reduce using rule 37 (argument -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 37 (argument -> INTEGER .)
    TIMES           reduce using rule 50 (factor -> INTEGER .)
    DIVIDE          reduce using rule 50 (factor -> INTEGER .)
    PLUS            reduce using rule 50 (factor -> INTEGER .)
    MINUS           reduce using rule 50 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 50 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 50 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 50 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 50 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 50 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 50 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 50 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 50 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 50 (factor -> INTEGER .)

  ! DOT             [ reduce using rule 50 (factor -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 50 (factor -> INTEGER .) ]
  ! RIGHT_PAREN     [ reduce using rule 50 (factor -> INTEGER .) ]
  ! COMMA           [ reduce using rule 50 (factor -> INTEGER .) ]
  ! RIGHT_BRACKET   [ reduce using rule 50 (factor -> INTEGER .) ]


state 51

    (38) argument -> FLOAT .
    (51) factor -> FLOAT .

  ! reduce/reduce conflict for DOT resolved using rule 38 (argument -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (argument -> FLOAT .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 38 (argument -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 38 (argument -> FLOAT .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 38 (argument -> FLOAT .)
    DOT             reduce using rule 38 (argument -> FLOAT .)
    SEMICOLON       reduce using rule 38 (argument -> FLOAT .)
    RIGHT_PAREN     reduce using rule 38 (argument -> FLOAT .)
    COMMA           reduce using rule 38 (argument -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 38 (argument -> FLOAT .)
    TIMES           reduce using rule 51 (factor -> FLOAT .)
    DIVIDE          reduce using rule 51 (factor -> FLOAT .)
    PLUS            reduce using rule 51 (factor -> FLOAT .)
    MINUS           reduce using rule 51 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 51 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 51 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 51 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 51 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 51 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 51 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 51 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 51 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 51 (factor -> FLOAT .)

  ! DOT             [ reduce using rule 51 (factor -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 51 (factor -> FLOAT .) ]
  ! RIGHT_PAREN     [ reduce using rule 51 (factor -> FLOAT .) ]
  ! COMMA           [ reduce using rule 51 (factor -> FLOAT .) ]
  ! RIGHT_BRACKET   [ reduce using rule 51 (factor -> FLOAT .) ]


state 52

    (39) argument -> STRING .

    DOT             reduce using rule 39 (argument -> STRING .)
    SEMICOLON       reduce using rule 39 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 39 (argument -> STRING .)
    COMMA           reduce using rule 39 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 39 (argument -> STRING .)


state 53

    (40) argument -> variable .
    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (52) factor -> variable .
    (22) assignment_operator -> . EQUALS
    (23) assignment_operator -> . PLUS_EQUALS
    (24) assignment_operator -> . MINUS_EQUALS
    (25) assignment_operator -> . TIMES_EQUALS
    (26) assignment_operator -> . DIVIDE_EQUALS
    (27) assignment_operator -> . MOD_EQUALS

  ! reduce/reduce conflict for DOT resolved using rule 40 (argument -> variable .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 40 (argument -> variable .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 40 (argument -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 40 (argument -> variable .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 40 (argument -> variable .)
    DOT             reduce using rule 40 (argument -> variable .)
    SEMICOLON       reduce using rule 40 (argument -> variable .)
    RIGHT_PAREN     reduce using rule 40 (argument -> variable .)
    COMMA           reduce using rule 40 (argument -> variable .)
    RIGHT_BRACKET   reduce using rule 40 (argument -> variable .)
    PLUS_PLUS       shift and go to state 60
    MINUS_MINUS     shift and go to state 61
    TIMES           reduce using rule 52 (factor -> variable .)
    DIVIDE          reduce using rule 52 (factor -> variable .)
    PLUS            reduce using rule 52 (factor -> variable .)
    MINUS           reduce using rule 52 (factor -> variable .)
    EQUAL_TO        reduce using rule 52 (factor -> variable .)
    NOT_EQUAL_TO    reduce using rule 52 (factor -> variable .)
    LESS_THAN       reduce using rule 52 (factor -> variable .)
    GREATER_THAN    reduce using rule 52 (factor -> variable .)
    LESS_EQUAL      reduce using rule 52 (factor -> variable .)
    GREATER_EQUAL   reduce using rule 52 (factor -> variable .)
    IDENTICAL_TO    reduce using rule 52 (factor -> variable .)
    NOT_IDENTICAL_TO reduce using rule 52 (factor -> variable .)
    DIFFERENT       reduce using rule 52 (factor -> variable .)
    EQUALS          shift and go to state 100
    PLUS_EQUALS     shift and go to state 63
    MINUS_EQUALS    shift and go to state 64
    TIMES_EQUALS    shift and go to state 65
    DIVIDE_EQUALS   shift and go to state 66
    MOD_EQUALS      shift and go to state 67

  ! DOT             [ reduce using rule 52 (factor -> variable .) ]
  ! SEMICOLON       [ reduce using rule 52 (factor -> variable .) ]
  ! RIGHT_PAREN     [ reduce using rule 52 (factor -> variable .) ]
  ! COMMA           [ reduce using rule 52 (factor -> variable .) ]
  ! RIGHT_BRACKET   [ reduce using rule 52 (factor -> variable .) ]

    assignment_operator            shift and go to state 59

state 54

    (41) argument -> expression .
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (73) condition -> expression . relational_operator expression
    (77) relational_operator -> . EQUAL_TO
    (78) relational_operator -> . NOT_EQUAL_TO
    (79) relational_operator -> . LESS_THAN
    (80) relational_operator -> . GREATER_THAN
    (81) relational_operator -> . LESS_EQUAL
    (82) relational_operator -> . GREATER_EQUAL
    (83) relational_operator -> . IDENTICAL_TO
    (84) relational_operator -> . NOT_IDENTICAL_TO
    (85) relational_operator -> . DIFFERENT

    DOT             reduce using rule 41 (argument -> expression .)
    SEMICOLON       reduce using rule 41 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 41 (argument -> expression .)
    COMMA           reduce using rule 41 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 41 (argument -> expression .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    EQUAL_TO        shift and go to state 79
    NOT_EQUAL_TO    shift and go to state 80
    LESS_THAN       shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_EQUAL      shift and go to state 83
    GREATER_EQUAL   shift and go to state 84
    IDENTICAL_TO    shift and go to state 85
    NOT_IDENTICAL_TO shift and go to state 86
    DIFFERENT       shift and go to state 87

    relational_operator            shift and go to state 76

state 55

    (42) argument -> condition .
    (74) condition -> condition . logical_operator condition
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

    DOT             reduce using rule 42 (argument -> condition .)
    SEMICOLON       reduce using rule 42 (argument -> condition .)
    RIGHT_PAREN     reduce using rule 42 (argument -> condition .)
    COMMA           reduce using rule 42 (argument -> condition .)
    RIGHT_BRACKET   reduce using rule 42 (argument -> condition .)
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

    logical_operator               shift and go to state 72

state 56

    (43) argument -> assignment_statement .

    DOT             reduce using rule 43 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 43 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 43 (argument -> assignment_statement .)
    COMMA           reduce using rule 43 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 43 (argument -> assignment_statement .)


state 57

    (18) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 101


state 58

    (17) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 102


state 59

    (28) assignment_statement -> variable assignment_operator . argument
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (21) variable -> . ID
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40

    variable                       shift and go to state 53
    argument                       shift and go to state 103
    expression                     shift and go to state 54
    condition                      shift and go to state 55
    assignment_statement           shift and go to state 56
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 60

    (29) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 29 (assignment_statement -> variable PLUS_PLUS .)


state 61

    (30) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 30 (assignment_statement -> variable MINUS_MINUS .)


state 62

    (89) array_declaration_statement -> variable EQUALS . array
    (22) assignment_operator -> EQUALS .
    (90) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (91) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

    INTEGER         reduce using rule 22 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 22 (assignment_operator -> EQUALS .)
    STRING          reduce using rule 22 (assignment_operator -> EQUALS .)
    ID              reduce using rule 22 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 22 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 22 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 22 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 22 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 105
    LEFT_BRACKET    shift and go to state 106

    array                          shift and go to state 104

state 63

    (23) assignment_operator -> PLUS_EQUALS .

    INTEGER         reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    STRING          reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 23 (assignment_operator -> PLUS_EQUALS .)


state 64

    (24) assignment_operator -> MINUS_EQUALS .

    INTEGER         reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    STRING          reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 24 (assignment_operator -> MINUS_EQUALS .)


state 65

    (25) assignment_operator -> TIMES_EQUALS .

    INTEGER         reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    STRING          reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 25 (assignment_operator -> TIMES_EQUALS .)


state 66

    (26) assignment_operator -> DIVIDE_EQUALS .

    INTEGER         reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    STRING          reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 26 (assignment_operator -> DIVIDE_EQUALS .)


state 67

    (27) assignment_operator -> MOD_EQUALS .

    INTEGER         reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    STRING          reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 27 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 27 (assignment_operator -> MOD_EQUALS .)


state 68

    (57) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (58) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (65) assignment_list -> . assignment_statement
    (66) assignment_list -> . assignment_list COMMA assignment_statement
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (21) variable -> . ID

    SEMICOLON       shift and go to state 108
    ID              shift and go to state 28

    assignment_list                shift and go to state 107
    assignment_statement           shift and go to state 109
    variable                       shift and go to state 110

state 69

    (54) if_statement -> IF LEFT_PAREN condition . RIGHT_PAREN block
    (55) if_statement -> IF LEFT_PAREN condition . RIGHT_PAREN block ELSE block
    (74) condition -> condition . logical_operator condition
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

    RIGHT_PAREN     shift and go to state 111
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

    logical_operator               shift and go to state 72

state 70

    (56) while_statement -> WHILE LEFT_PAREN condition . RIGHT_PAREN block
    (74) condition -> condition . logical_operator condition
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

    RIGHT_PAREN     shift and go to state 112
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

    logical_operator               shift and go to state 72

state 71

    (59) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 59 (for_statement -> for_part1 condition for_part3 .)


state 72

    (74) condition -> condition logical_operator . condition
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 28

    condition                      shift and go to state 113
    expression                     shift and go to state 38
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 73

    (86) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 86 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 86 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 86 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 86 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 86 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 86 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 86 (logical_operator -> LOGICAL_AND .)


state 74

    (87) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 87 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 87 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 87 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 87 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 87 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 87 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 87 (logical_operator -> LOGICAL_OR .)


state 75

    (88) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 88 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 88 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 88 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 88 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 88 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 88 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 88 (logical_operator -> LOGICAL_XOR .)


state 76

    (73) condition -> expression relational_operator . expression
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 115
    ID              shift and go to state 28

    expression                     shift and go to state 114
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 77

    (44) expression -> expression PLUS . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 115
    ID              shift and go to state 28

    term                           shift and go to state 116
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 78

    (45) expression -> expression MINUS . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 115
    ID              shift and go to state 28

    term                           shift and go to state 117
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 79

    (77) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 77 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 77 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 77 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 77 (relational_operator -> EQUAL_TO .)


state 80

    (78) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 78 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 78 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 78 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 78 (relational_operator -> NOT_EQUAL_TO .)


state 81

    (79) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 79 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 79 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 79 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 79 (relational_operator -> LESS_THAN .)


state 82

    (80) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 80 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 80 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 80 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 80 (relational_operator -> GREATER_THAN .)


state 83

    (81) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 81 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 81 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 81 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 81 (relational_operator -> LESS_EQUAL .)


state 84

    (82) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 82 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 82 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 82 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 82 (relational_operator -> GREATER_EQUAL .)


state 85

    (83) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 83 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 83 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 83 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 83 (relational_operator -> IDENTICAL_TO .)


state 86

    (84) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 84 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 84 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 84 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 84 (relational_operator -> NOT_IDENTICAL_TO .)


state 87

    (85) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 85 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 85 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 85 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 85 (relational_operator -> DIFFERENT .)


state 88

    (75) condition -> LOGICAL_NOT condition .
    (74) condition -> condition . logical_operator condition
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 75 (condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 75 (condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 75 (condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 75 (condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 75 (condition -> LOGICAL_NOT condition .)
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

  ! LOGICAL_AND     [ reduce using rule 75 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 75 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 75 (condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 72

state 89

    (76) condition -> LEFT_PAREN condition . RIGHT_PAREN
    (74) condition -> condition . logical_operator condition
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

    RIGHT_PAREN     shift and go to state 118
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

    logical_operator               shift and go to state 72

state 90

    (53) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (73) condition -> expression . relational_operator expression
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (77) relational_operator -> . EQUAL_TO
    (78) relational_operator -> . NOT_EQUAL_TO
    (79) relational_operator -> . LESS_THAN
    (80) relational_operator -> . GREATER_THAN
    (81) relational_operator -> . LESS_EQUAL
    (82) relational_operator -> . GREATER_EQUAL
    (83) relational_operator -> . IDENTICAL_TO
    (84) relational_operator -> . NOT_IDENTICAL_TO
    (85) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 119
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    EQUAL_TO        shift and go to state 79
    NOT_EQUAL_TO    shift and go to state 80
    LESS_THAN       shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_EQUAL      shift and go to state 83
    GREATER_EQUAL   shift and go to state 84
    IDENTICAL_TO    shift and go to state 85
    NOT_IDENTICAL_TO shift and go to state 86
    DIFFERENT       shift and go to state 87

    relational_operator            shift and go to state 76

state 91

    (61) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (68) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 120
    COMMA           shift and go to state 121


state 92

    (62) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (63) for_part4 -> . block
    (64) for_part4 -> . SEMICOLON
    (69) block -> . LEFT_BRACE statements RIGHT_BRACE
    (70) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 122
    LEFT_BRACE      shift and go to state 125

    for_part4                      shift and go to state 123
    block                          shift and go to state 124

state 93

    (67) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 67 (statement_list -> statement .)
    COMMA           reduce using rule 67 (statement_list -> statement .)


state 94

    (47) term -> term TIMES . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 115
    ID              shift and go to state 28

    factor                         shift and go to state 126
    variable                       shift and go to state 46

state 95

    (48) term -> term DIVIDE . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 115
    ID              shift and go to state 28

    factor                         shift and go to state 127
    variable                       shift and go to state 46

state 96

    (31) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (36) arguments -> arguments . DOT argument

    RIGHT_PAREN     shift and go to state 128
    DOT             shift and go to state 99


state 97

    (76) condition -> LEFT_PAREN condition . RIGHT_PAREN
    (74) condition -> condition . logical_operator condition
    (42) argument -> condition .
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 118
    DOT             reduce using rule 42 (argument -> condition .)
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

  ! RIGHT_PAREN     [ reduce using rule 42 (argument -> condition .) ]

    logical_operator               shift and go to state 72

state 98

    (53) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (73) condition -> expression . relational_operator expression
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term
    (41) argument -> expression .
    (77) relational_operator -> . EQUAL_TO
    (78) relational_operator -> . NOT_EQUAL_TO
    (79) relational_operator -> . LESS_THAN
    (80) relational_operator -> . GREATER_THAN
    (81) relational_operator -> . LESS_EQUAL
    (82) relational_operator -> . GREATER_EQUAL
    (83) relational_operator -> . IDENTICAL_TO
    (84) relational_operator -> . NOT_IDENTICAL_TO
    (85) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 119
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    DOT             reduce using rule 41 (argument -> expression .)
    EQUAL_TO        shift and go to state 79
    NOT_EQUAL_TO    shift and go to state 80
    LESS_THAN       shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_EQUAL      shift and go to state 83
    GREATER_EQUAL   shift and go to state 84
    IDENTICAL_TO    shift and go to state 85
    NOT_IDENTICAL_TO shift and go to state 86
    DIFFERENT       shift and go to state 87

  ! RIGHT_PAREN     [ reduce using rule 41 (argument -> expression .) ]

    relational_operator            shift and go to state 76

state 99

    (36) arguments -> arguments DOT . argument
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (21) variable -> . ID
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40

    argument                       shift and go to state 129
    variable                       shift and go to state 53
    expression                     shift and go to state 54
    condition                      shift and go to state 55
    assignment_statement           shift and go to state 56
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 100

    (22) assignment_operator -> EQUALS .

    INTEGER         reduce using rule 22 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 22 (assignment_operator -> EQUALS .)
    STRING          reduce using rule 22 (assignment_operator -> EQUALS .)
    ID              reduce using rule 22 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 22 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 22 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 22 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 22 (assignment_operator -> EQUALS .)


state 101

    (18) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 130


state 102

    (17) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 131


state 103

    (28) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 28 (assignment_statement -> variable assignment_operator argument .)


state 104

    (89) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 89 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 89 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 89 (array_declaration_statement -> variable EQUALS array .)


state 105

    (90) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 132


state 106

    (91) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (92) array_elements -> . argument
    (93) array_elements -> . array_elements COMMA argument
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (21) variable -> . ID
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40

    array_elements                 shift and go to state 133
    argument                       shift and go to state 134
    variable                       shift and go to state 53
    expression                     shift and go to state 54
    condition                      shift and go to state 55
    assignment_statement           shift and go to state 56
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 107

    (57) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (66) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 135
    COMMA           shift and go to state 136


state 108

    (58) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    TRUE            reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 58 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 109

    (65) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 65 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 65 (assignment_list -> assignment_statement .)


state 110

    (28) assignment_statement -> variable . assignment_operator argument
    (29) assignment_statement -> variable . PLUS_PLUS
    (30) assignment_statement -> variable . MINUS_MINUS
    (22) assignment_operator -> . EQUALS
    (23) assignment_operator -> . PLUS_EQUALS
    (24) assignment_operator -> . MINUS_EQUALS
    (25) assignment_operator -> . TIMES_EQUALS
    (26) assignment_operator -> . DIVIDE_EQUALS
    (27) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 60
    MINUS_MINUS     shift and go to state 61
    EQUALS          shift and go to state 100
    PLUS_EQUALS     shift and go to state 63
    MINUS_EQUALS    shift and go to state 64
    TIMES_EQUALS    shift and go to state 65
    DIVIDE_EQUALS   shift and go to state 66
    MOD_EQUALS      shift and go to state 67

    assignment_operator            shift and go to state 59

state 111

    (54) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN . block
    (55) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN . block ELSE block
    (69) block -> . LEFT_BRACE statements RIGHT_BRACE
    (70) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 125

    block                          shift and go to state 137

state 112

    (56) while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN . block
    (69) block -> . LEFT_BRACE statements RIGHT_BRACE
    (70) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 125

    block                          shift and go to state 138

state 113

    (74) condition -> condition logical_operator condition .
    (74) condition -> condition . logical_operator condition
    (86) logical_operator -> . LOGICAL_AND
    (87) logical_operator -> . LOGICAL_OR
    (88) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 74 (condition -> condition logical_operator condition .)
    DOT             reduce using rule 74 (condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 74 (condition -> condition logical_operator condition .)
    COMMA           reduce using rule 74 (condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 74 (condition -> condition logical_operator condition .)
    LOGICAL_AND     shift and go to state 73
    LOGICAL_OR      shift and go to state 74
    LOGICAL_XOR     shift and go to state 75

  ! LOGICAL_AND     [ reduce using rule 74 (condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 74 (condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 74 (condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 72

state 114

    (73) condition -> expression relational_operator expression .
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 73 (condition -> expression relational_operator expression .)
    LOGICAL_AND     reduce using rule 73 (condition -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 73 (condition -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 73 (condition -> expression relational_operator expression .)
    DOT             reduce using rule 73 (condition -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 73 (condition -> expression relational_operator expression .)
    COMMA           reduce using rule 73 (condition -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 73 (condition -> expression relational_operator expression .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 115

    (53) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (21) variable -> . ID

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 115
    ID              shift and go to state 28

    expression                     shift and go to state 139
    term                           shift and go to state 42
    factor                         shift and go to state 43
    variable                       shift and go to state 46

state 116

    (44) expression -> expression PLUS term .
    (47) term -> term . TIMES factor
    (48) term -> term . DIVIDE factor

    PLUS            reduce using rule 44 (expression -> expression PLUS term .)
    MINUS           reduce using rule 44 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 44 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 44 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 44 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 44 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 44 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 44 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 44 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 44 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 44 (expression -> expression PLUS term .)
    DOT             reduce using rule 44 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 44 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 44 (expression -> expression PLUS term .)
    COMMA           reduce using rule 44 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 44 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 44 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 44 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 44 (expression -> expression PLUS term .)
    TIMES           shift and go to state 94
    DIVIDE          shift and go to state 95


state 117

    (45) expression -> expression MINUS term .
    (47) term -> term . TIMES factor
    (48) term -> term . DIVIDE factor

    PLUS            reduce using rule 45 (expression -> expression MINUS term .)
    MINUS           reduce using rule 45 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 45 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 45 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 45 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 45 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 45 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 45 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 45 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 45 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 45 (expression -> expression MINUS term .)
    DOT             reduce using rule 45 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 45 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 45 (expression -> expression MINUS term .)
    COMMA           reduce using rule 45 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 45 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 45 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 45 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 45 (expression -> expression MINUS term .)
    TIMES           shift and go to state 94
    DIVIDE          shift and go to state 95


state 118

    (76) condition -> LEFT_PAREN condition RIGHT_PAREN .

    SEMICOLON       reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 76 (condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 119

    (53) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 53 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 120

    (61) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (63) for_part4 -> . block
    (64) for_part4 -> . SEMICOLON
    (69) block -> . LEFT_BRACE statements RIGHT_BRACE
    (70) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 122
    LEFT_BRACE      shift and go to state 125

    for_part4                      shift and go to state 140
    block                          shift and go to state 124

state 121

    (68) statement_list -> statement_list COMMA . statement
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (31) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> . print_function arguments
    (18) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (17) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (89) array_declaration_statement -> . variable EQUALS array
    (33) print_function -> . PRINT
    (34) print_function -> . ECHO
    (21) variable -> . ID

    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    FSCANF          shift and go to state 22
    FGETS           shift and go to state 23
    PRINT           shift and go to state 26
    ECHO            shift and go to state 27
    ID              shift and go to state 28

    statement                      shift and go to state 141
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    print_function                 shift and go to state 21
    variable                       shift and go to state 24

state 122

    (64) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 64 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 64 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 64 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 64 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 64 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 64 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 64 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 64 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 64 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 64 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 64 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 64 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 64 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 64 (for_part4 -> SEMICOLON .)


state 123

    (62) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 62 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 124

    (63) for_part4 -> block .

    CLOSE_TAG       reduce using rule 63 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 63 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 63 (for_part4 -> block .)
    BREAK           reduce using rule 63 (for_part4 -> block .)
    CONTINUE        reduce using rule 63 (for_part4 -> block .)
    IF              reduce using rule 63 (for_part4 -> block .)
    WHILE           reduce using rule 63 (for_part4 -> block .)
    FSCANF          reduce using rule 63 (for_part4 -> block .)
    FGETS           reduce using rule 63 (for_part4 -> block .)
    FOR             reduce using rule 63 (for_part4 -> block .)
    PRINT           reduce using rule 63 (for_part4 -> block .)
    ECHO            reduce using rule 63 (for_part4 -> block .)
    ID              reduce using rule 63 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 63 (for_part4 -> block .)


state 125

    (69) block -> LEFT_BRACE . statements RIGHT_BRACE
    (70) block -> LEFT_BRACE . RIGHT_BRACE
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (54) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (55) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (56) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (59) for_statement -> . for_part1 condition for_part3
    (60) for_statement -> . for_part1 for_part3
    (31) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> . print_function arguments
    (18) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (17) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (89) array_declaration_statement -> . variable EQUALS array
    (57) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (58) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (33) print_function -> . PRINT
    (34) print_function -> . ECHO
    (21) variable -> . ID

    RIGHT_BRACE     shift and go to state 143
    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FSCANF          shift and go to state 22
    FGETS           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    ECHO            shift and go to state 27
    ID              shift and go to state 28

    statements                     shift and go to state 142
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    for_part1                      shift and go to state 20
    print_function                 shift and go to state 21
    variable                       shift and go to state 24

state 126

    (47) term -> term TIMES factor .

    TIMES           reduce using rule 47 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 47 (term -> term TIMES factor .)
    PLUS            reduce using rule 47 (term -> term TIMES factor .)
    MINUS           reduce using rule 47 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 47 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 47 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 47 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 47 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 47 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 47 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 47 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 47 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 47 (term -> term TIMES factor .)
    DOT             reduce using rule 47 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 47 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 47 (term -> term TIMES factor .)
    COMMA           reduce using rule 47 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 47 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 47 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 47 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 47 (term -> term TIMES factor .)


state 127

    (48) term -> term DIVIDE factor .

    TIMES           reduce using rule 48 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 48 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 48 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 48 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 48 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 48 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 48 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 48 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 48 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 48 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 48 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 48 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 48 (term -> term DIVIDE factor .)
    DOT             reduce using rule 48 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 48 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 48 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 48 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 48 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 48 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 48 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 48 (term -> term DIVIDE factor .)


state 128

    (31) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 31 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 31 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 31 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 129

    (36) arguments -> arguments DOT argument .

    DOT             reduce using rule 36 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 36 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 36 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 36 (arguments -> arguments DOT argument .)


state 130

    (18) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 144


state 131

    (17) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 17 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 17 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 17 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)


state 132

    (90) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (92) array_elements -> . argument
    (93) array_elements -> . array_elements COMMA argument
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (21) variable -> . ID
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40

    array_elements                 shift and go to state 145
    argument                       shift and go to state 134
    variable                       shift and go to state 53
    expression                     shift and go to state 54
    condition                      shift and go to state 55
    assignment_statement           shift and go to state 56
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 133

    (91) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (93) array_elements -> array_elements . COMMA argument

    RIGHT_BRACKET   shift and go to state 146
    COMMA           shift and go to state 147


state 134

    (92) array_elements -> argument .

    RIGHT_BRACKET   reduce using rule 92 (array_elements -> argument .)
    COMMA           reduce using rule 92 (array_elements -> argument .)
    RIGHT_PAREN     reduce using rule 92 (array_elements -> argument .)


state 135

    (57) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    TRUE            reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    SEMICOLON       reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 57 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)


state 136

    (66) assignment_list -> assignment_list COMMA . assignment_statement
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (21) variable -> . ID

    ID              shift and go to state 28

    assignment_statement           shift and go to state 148
    variable                       shift and go to state 110

state 137

    (54) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .
    (55) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block . ELSE block

    CLOSE_TAG       reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    BREAK           reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    CONTINUE        reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    IF              reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    WHILE           reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FSCANF          reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FGETS           reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FOR             reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    PRINT           reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ECHO            reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ID              reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 54 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ELSE            shift and go to state 149


state 138

    (56) while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    BREAK           reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    CONTINUE        reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    IF              reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    WHILE           reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FSCANF          reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FGETS           reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FOR             reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    PRINT           reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    ECHO            reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    ID              reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 56 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)


state 139

    (53) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (44) expression -> expression . PLUS term
    (45) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 119
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 140

    (61) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 61 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)


state 141

    (68) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 68 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 68 (statement_list -> statement_list COMMA statement .)


state 142

    (69) block -> LEFT_BRACE statements . RIGHT_BRACE
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (54) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (55) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (56) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (59) for_statement -> . for_part1 condition for_part3
    (60) for_statement -> . for_part1 for_part3
    (31) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (32) print_statement -> . print_function arguments
    (18) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (17) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (89) array_declaration_statement -> . variable EQUALS array
    (57) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (58) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (33) print_function -> . PRINT
    (34) print_function -> . ECHO
    (21) variable -> . ID

    RIGHT_BRACE     shift and go to state 150
    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    FSCANF          shift and go to state 22
    FGETS           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    ECHO            shift and go to state 27
    ID              shift and go to state 28

    statement2                     shift and go to state 30
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    for_part1                      shift and go to state 20
    print_function                 shift and go to state 21
    variable                       shift and go to state 24

state 143

    (70) block -> LEFT_BRACE RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSE            reduce using rule 70 (block -> LEFT_BRACE RIGHT_BRACE .)


state 144

    (18) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 151


state 145

    (90) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (93) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 152
    COMMA           shift and go to state 147


state 146

    (91) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    SEMICOLON       reduce using rule 91 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 91 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 91 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)


state 147

    (93) array_elements -> array_elements COMMA . argument
    (37) argument -> . INTEGER
    (38) argument -> . FLOAT
    (39) argument -> . STRING
    (40) argument -> . variable
    (41) argument -> . expression
    (42) argument -> . condition
    (43) argument -> . assignment_statement
    (21) variable -> . ID
    (44) expression -> . expression PLUS term
    (45) expression -> . expression MINUS term
    (46) expression -> . term
    (71) condition -> . TRUE
    (72) condition -> . FALSE
    (73) condition -> . expression relational_operator expression
    (74) condition -> . condition logical_operator condition
    (75) condition -> . LOGICAL_NOT condition
    (76) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (28) assignment_statement -> . variable assignment_operator argument
    (29) assignment_statement -> . variable PLUS_PLUS
    (30) assignment_statement -> . variable MINUS_MINUS
    (47) term -> . term TIMES factor
    (48) term -> . term DIVIDE factor
    (49) term -> . factor
    (50) factor -> . INTEGER
    (51) factor -> . FLOAT
    (52) factor -> . variable
    (53) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    STRING          shift and go to state 52
    ID              shift and go to state 28
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    LOGICAL_NOT     shift and go to state 39
    LEFT_PAREN      shift and go to state 40

    argument                       shift and go to state 153
    variable                       shift and go to state 53
    expression                     shift and go to state 54
    condition                      shift and go to state 55
    assignment_statement           shift and go to state 56
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 148

    (66) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 66 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 66 (assignment_list -> assignment_list COMMA assignment_statement .)


state 149

    (55) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE . block
    (69) block -> . LEFT_BRACE statements RIGHT_BRACE
    (70) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 125

    block                          shift and go to state 154

state 150

    (69) block -> LEFT_BRACE statements RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSE            reduce using rule 69 (block -> LEFT_BRACE statements RIGHT_BRACE .)


state 151

    (18) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (19) variable_list -> . variable
    (20) variable_list -> . variable_list COMMA variable
    (21) variable -> . ID

    ID              shift and go to state 28

    variable_list                  shift and go to state 155
    variable                       shift and go to state 156

state 152

    (90) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 90 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 90 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 90 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 153

    (93) array_elements -> array_elements COMMA argument .

    RIGHT_BRACKET   reduce using rule 93 (array_elements -> array_elements COMMA argument .)
    COMMA           reduce using rule 93 (array_elements -> array_elements COMMA argument .)
    RIGHT_PAREN     reduce using rule 93 (array_elements -> array_elements COMMA argument .)


state 154

    (55) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .

    CLOSE_TAG       reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ONE_LINE_COMMENT reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    BREAK           reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    CONTINUE        reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    IF              reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    WHILE           reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FSCANF          reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FGETS           reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FOR             reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    PRINT           reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ECHO            reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ID              reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    RIGHT_BRACE     reduce using rule 55 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)


state 155

    (18) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (20) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 158
    COMMA           shift and go to state 157


state 156

    (19) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 19 (variable_list -> variable .)
    COMMA           reduce using rule 19 (variable_list -> variable .)


state 157

    (20) variable_list -> variable_list COMMA . variable
    (21) variable -> . ID

    ID              shift and go to state 28

    variable                       shift and go to state 159

state 158

    (18) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 18 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 18 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 18 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)


state 159

    (20) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 20 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 20 (variable_list -> variable_list COMMA variable .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 88 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 97 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 113 resolved as shift
WARNING: reduce/reduce conflict in state 50 resolved using rule (argument -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 50
WARNING: reduce/reduce conflict in state 51 resolved using rule (argument -> FLOAT)
WARNING: rejected rule (factor -> FLOAT) in state 51
WARNING: reduce/reduce conflict in state 53 resolved using rule (argument -> variable)
WARNING: rejected rule (factor -> variable) in state 53
