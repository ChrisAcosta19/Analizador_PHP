Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASYNC
    AWAIT
    BOOL
    CALL
    CALLABLE
    CASE
    CATCH
    CLASS
    CLONE
    CONST
    DECLARE
    DEFAULT
    DIE
    DO
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FINAL
    FINALLY
    FN
    FOREACH
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    KEY_VALUE
    LIST
    LPAREN
    MATCH
    MIXED
    MOD
    NAMESPACE
    NEW
    NULL
    OBJECT
    POWER
    PRIVATE
    PROTECTED
    PUBLIC
    REQUIRE
    REQUIRE_ONCE
    RPAREN
    SELF
    STATIC
    SWITCH
    THROW
    TRAIT
    TRY
    UNSET
    USE
    VAR
    VOID
    YIELD
    YIELD_FROM
    object_declaration

Grammar

Rule 0     S' -> program
Rule 1     program -> OPEN_TAG statements CLOSE_TAG
Rule 2     statements -> statement2
Rule 3     statements -> statements statement2
Rule 4     statement2 -> statement SEMICOLON
Rule 5     statement2 -> if_statement
Rule 6     statement2 -> while_statement
Rule 7     statement2 -> for_statement
<<<<<<< HEAD
Rule 8     statement2 -> ONE_LINE_COMMENT
Rule 9     statement2 -> MULTI_LINE_COMMENT
Rule 10    statement -> print_statement
Rule 11    statement -> fscanf_statement
Rule 12    statement -> fgets_statement
Rule 13    statement -> assignment_statement
Rule 14    statement -> array_declaration_statement
Rule 15    statement -> BREAK
Rule 16    statement -> CONTINUE
Rule 17    statement -> function_call
Rule 18    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 19    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 20    variable_list -> variable
Rule 21    variable_list -> variable_list COMMA variable
Rule 22    variable -> ID
Rule 23    assignment_statement -> variable assignment_operator argument
Rule 24    assignment_statement -> variable PLUS_PLUS
Rule 25    assignment_statement -> variable MINUS_MINUS
Rule 26    assignment_operator -> EQUALS
Rule 27    assignment_operator -> PLUS_EQUALS
Rule 28    assignment_operator -> MINUS_EQUALS
Rule 29    assignment_operator -> TIMES_EQUALS
Rule 30    assignment_operator -> DIVIDE_EQUALS
Rule 31    assignment_operator -> MOD_EQUALS
Rule 32    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 33    print_statement -> print_function arguments
Rule 34    print_function -> PRINT
Rule 35    print_function -> ECHO
Rule 36    arguments -> argument
Rule 37    arguments -> arguments DOT argument
Rule 38    argument -> STRING
Rule 39    argument -> expression
Rule 40    argument -> assignment_statement
Rule 41    argument -> function_call
Rule 42    argument -> fgets_statement
Rule 43    argument -> array_indexing
Rule 44    argument -> casting argument
Rule 45    expression -> expression PLUS term
Rule 46    expression -> expression MINUS term
Rule 47    expression -> term
Rule 48    term -> term TIMES factor
Rule 49    term -> term DIVIDE factor
Rule 50    term -> factor
Rule 51    factor -> INTEGER
Rule 52    factor -> FLOAT
Rule 53    factor -> condition
Rule 54    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 55    if_statement -> IF parenthesized_condition block else_if_extended if_part3
Rule 56    else_if_extended -> if_part2
Rule 57    else_if_extended -> else_if_extended if_part2
Rule 58    if_part2 -> ELSEIF parenthesized_condition block
Rule 59    if_part2 -> <empty>
Rule 60    if_part3 -> ELSE block
Rule 61    if_part3 -> <empty>
Rule 62    while_statement -> WHILE parenthesized_condition block
Rule 63    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 64    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 65    for_statement -> for_part1 condition for_part3
Rule 66    for_statement -> for_part1 for_part3
Rule 67    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 68    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 69    for_part4 -> block
Rule 70    for_part4 -> SEMICOLON
Rule 71    assignment_list -> assignment_statement
Rule 72    assignment_list -> assignment_list COMMA assignment_statement
Rule 73    statement_list -> statement
Rule 74    statement_list -> statement_list COMMA statement
Rule 75    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 76    block -> LEFT_BRACE RIGHT_BRACE
Rule 77    condition -> simple_condition
Rule 78    condition -> negated_condition
Rule 79    condition -> complex_condition
Rule 80    condition -> parenthesized_condition
Rule 81    simple_condition -> TRUE
Rule 82    simple_condition -> FALSE
Rule 83    simple_condition -> variable
Rule 84    simple_condition -> relational_expression
Rule 85    negated_condition -> LOGICAL_NOT condition
Rule 86    complex_condition -> condition logical_operator condition
Rule 87    parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 88    relational_expression -> expression relational_operator expression
Rule 89    relational_operator -> EQUAL_TO
Rule 90    relational_operator -> NOT_EQUAL_TO
Rule 91    relational_operator -> LESS_THAN
Rule 92    relational_operator -> GREATER_THAN
Rule 93    relational_operator -> LESS_EQUAL
Rule 94    relational_operator -> GREATER_EQUAL
Rule 95    relational_operator -> IDENTICAL_TO
Rule 96    relational_operator -> NOT_IDENTICAL_TO
Rule 97    relational_operator -> DIFFERENT
Rule 98    logical_operator -> LOGICAL_AND
Rule 99    logical_operator -> LOGICAL_OR
Rule 100   logical_operator -> LOGICAL_XOR
Rule 101   casting -> LEFT_PAREN casting_type RIGHT_PAREN
Rule 102   casting_type -> INT_TYPE
Rule 103   casting_type -> FLOAT_TYPE
Rule 104   function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN
Rule 105   array_declaration_statement -> variable EQUALS array
Rule 106   array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 107   array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 108   array_elements -> argument
Rule 109   array_elements -> array_elements COMMA argument
Rule 110   array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET
=======
Rule 8     statement2 -> statement_return
Rule 9     statement2 -> function_statement
Rule 10    statement2 -> ONE_LINE_COMMENT
Rule 11    statement2 -> MULTI_LINE_COMMENT
Rule 12    statement -> print_statement
Rule 13    statement -> fscanf_statement
Rule 14    statement -> fgets_statement
Rule 15    statement -> assignment_statement
Rule 16    statement -> array_declaration_statement
Rule 17    statement -> BREAK
Rule 18    statement -> CONTINUE
Rule 19    function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
Rule 20    lambda_function -> LAMBDA arguments COLON expression
Rule 21    arrow_function -> ARROW arguments ARROW expression
Rule 22    statement_return -> RETURN expression SEMICOLON
Rule 23    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 24    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 25    variable_list -> variable
Rule 26    variable_list -> variable_list COMMA variable
Rule 27    variable -> ID
Rule 28    assignment_operator -> EQUALS
Rule 29    assignment_operator -> PLUS_EQUALS
Rule 30    assignment_operator -> MINUS_EQUALS
Rule 31    assignment_operator -> TIMES_EQUALS
Rule 32    assignment_operator -> DIVIDE_EQUALS
Rule 33    assignment_operator -> MOD_EQUALS
Rule 34    assignment_statement -> variable assignment_operator argument
Rule 35    assignment_statement -> variable PLUS_PLUS
Rule 36    assignment_statement -> variable MINUS_MINUS
Rule 37    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 38    print_statement -> print_function arguments
Rule 39    print_function -> PRINT
Rule 40    print_function -> ECHO
Rule 41    arguments -> argument
Rule 42    arguments -> arguments DOT argument
Rule 43    arguments -> arguments COMMA argument
Rule 44    argument -> INTEGER
Rule 45    argument -> FLOAT
Rule 46    argument -> STRING
Rule 47    argument -> variable
Rule 48    argument -> expression
Rule 49    argument -> condition
Rule 50    argument -> assignment_statement
Rule 51    expression -> expression PLUS term
Rule 52    expression -> expression MINUS term
Rule 53    expression -> term
Rule 54    term -> term TIMES factor
Rule 55    term -> term DIVIDE factor
Rule 56    term -> factor
Rule 57    factor -> INTEGER
Rule 58    factor -> FLOAT
Rule 59    factor -> variable
Rule 60    factor -> STRING
Rule 61    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 62    if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block
Rule 63    if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
Rule 64    while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block
Rule 65    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 66    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 67    for_statement -> for_part1 condition for_part3
Rule 68    for_statement -> for_part1 for_part3
Rule 69    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 70    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 71    for_part4 -> block
Rule 72    for_part4 -> SEMICOLON
Rule 73    assignment_list -> assignment_statement
Rule 74    assignment_list -> assignment_list COMMA assignment_statement
Rule 75    statement_list -> statement
Rule 76    statement_list -> statement_list COMMA statement
Rule 77    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 78    block -> LEFT_BRACE RIGHT_BRACE
Rule 79    condition -> TRUE
Rule 80    condition -> FALSE
Rule 81    condition -> expression relational_operator expression
Rule 82    condition -> condition logical_operator condition
Rule 83    condition -> LOGICAL_NOT condition
Rule 84    condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 85    relational_operator -> EQUAL_TO
Rule 86    relational_operator -> NOT_EQUAL_TO
Rule 87    relational_operator -> LESS_THAN
Rule 88    relational_operator -> GREATER_THAN
Rule 89    relational_operator -> LESS_EQUAL
Rule 90    relational_operator -> GREATER_EQUAL
Rule 91    relational_operator -> IDENTICAL_TO
Rule 92    relational_operator -> NOT_IDENTICAL_TO
Rule 93    relational_operator -> DIFFERENT
Rule 94    logical_operator -> LOGICAL_AND
Rule 95    logical_operator -> LOGICAL_OR
Rule 96    logical_operator -> LOGICAL_XOR
Rule 97    array_declaration_statement -> variable EQUALS array
Rule 98    array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 99    array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 100   array_elements -> argument
Rule 101   array_elements -> array_elements COMMA argument
Rule 102   list -> LEFT_BRACKET elements RIGHT_BRACKET
Rule 103   elements -> argument
Rule 104   elements -> elements COMMA argument
Rule 105   stack_operations -> PUSH argument
Rule 106   stack_operations -> POP
Rule 107   queue_operations -> ENQUEUE argument
Rule 108   queue_operations -> DEQUEUE
Rule 109   deque_operations -> APPEND argument
Rule 110   deque_operations -> APPENDLEFT argument
Rule 111   deque_operations -> POP
Rule 112   deque_operations -> POPLEFT
Rule 113   set_declaration -> SET LEFT_BRACE set_elements RIGHT_BRACE
Rule 114   set_elements -> argument
Rule 115   set_elements -> set_elements COMMA argument
Rule 116   dictionary_declaration -> DICTIONARY LEFT_BRACE dictionary_elements RIGHT_BRACE
Rule 117   dictionary_elements -> key_value_pair
Rule 118   dictionary_elements -> dictionary_elements COMMA key_value_pair
Rule 119   key_value_pair -> STRING COLON argument
Rule 120   iterator_declaration -> ITERATOR LEFT_BRACKET elements RIGHT_BRACKET
Rule 121   tree_operations -> ADD_CHILD argument
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

Terminals, with rules where they appear

ABSTRACT             : 
<<<<<<< HEAD
ARRAY                : 106
=======
ADD_CHILD            : 121
AND                  : 
APPEND               : 109
APPENDLEFT           : 110
ARRAY                : 98
ARROW                : 21 21
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 17
CALL                 : 
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 
CLONE                : 
CLOSE_TAG            : 1
<<<<<<< HEAD
COLON                : 
COMMA                : 19 19 21 72 74 109
=======
COLON                : 20 119
COMMA                : 24 24 26 43 74 76 101 104 115 118
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
CONST                : 
CONTINUE             : 18
DECLARE              : 
DEFAULT              : 
DEQUEUE              : 108
DICTIONARY           : 116
DIE                  : 
<<<<<<< HEAD
DIFFERENT            : 97
DIVIDE               : 49
DIVIDE_EQUALS        : 30
DO                   : 
DOT                  : 37
ECHO                 : 35
ELSE                 : 60
ELSEIF               : 58
=======
DIFFERENT            : 93
DIVIDE               : 55
DIVIDE_EQUALS        : 32
DO                   : 
DOT                  : 42
ECHO                 : 40
ELSE                 : 63
ELSEIF               : 
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENQUEUE              : 107
ENUM                 : 
<<<<<<< HEAD
EQUALS               : 26 105
EQUAL_TO             : 89
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 82
FGETS                : 18
FINAL                : 
FINALLY              : 
FLOAT                : 52
FLOAT_TYPE           : 103
FN                   : 
FOR                  : 63 64
FOREACH              : 
FSCANF               : 19
FUNCTION             : 
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 94
GREATER_THAN         : 92
HALT_COMPILER        : 
ID                   : 22
IDENTICAL_TO         : 95
IF                   : 55
=======
EQUALS               : 28 97
EQUAL_TO             : 85
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 80
FGETS                : 23
FINAL                : 
FINALLY              : 
FLOAT                : 45 58
FN                   : 
FOR                  : 65 66
FOREACH              : 
FSCANF               : 24
FUNCTION             : 19
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 90
GREATER_THAN         : 88
HALT_COMPILER        : 
ID                   : 27
IDENTICAL_TO         : 91
IF                   : 62 63
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
<<<<<<< HEAD
INTEGER              : 51 110
=======
INTEGER              : 44 57
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
INTERFACE            : 
INT_TYPE             : 102
ISSET                : 
ITERABLE             : 
ITERATOR             : 120
KEY_VALUE            : 
<<<<<<< HEAD
LEFT_BRACE           : 75 76
LEFT_BRACKET         : 107 110
LEFT_PAREN           : 18 19 32 54 63 64 87 101 104 106
LESS_EQUAL           : 93
LESS_THAN            : 91
LIST                 : 
LOGICAL_AND          : 98
LOGICAL_NOT          : 85
LOGICAL_OR           : 99
LOGICAL_XOR          : 100
LPAREN               : 
MATCH                : 
MINUS                : 46
MINUS_EQUALS         : 28
MINUS_MINUS          : 25
MIXED                : 
MOD                  : 
MOD_EQUALS           : 31
MULTI_LINE_COMMENT   : 9
NAME                 : 104
NAMESPACE            : 
NEW                  : 
NOT_EQUAL_TO         : 90
NOT_IDENTICAL_TO     : 96
=======
LAMBDA               : 20
LEFT_BRACE           : 77 78 113 116
LEFT_BRACKET         : 99 102 120
LEFT_PAREN           : 19 23 24 37 61 62 63 64 65 66 84 98
LESS_EQUAL           : 89
LESS_THAN            : 87
LIST                 : 
LOGICAL_AND          : 94
LOGICAL_NOT          : 83
LOGICAL_OR           : 95
LOGICAL_XOR          : 96
LPAREN               : 
MATCH                : 
MINUS                : 52
MINUS_EQUALS         : 30
MINUS_MINUS          : 36
MIXED                : 
MOD                  : 
MOD_EQUALS           : 33
MULTI_LINE_COMMENT   : 11
NAME                 : 19
NAMESPACE            : 
NEW                  : 
NOT_EQUAL_TO         : 86
NOT_IDENTICAL_TO     : 92
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 10
OPEN_TAG             : 1
<<<<<<< HEAD
PLUS                 : 45
PLUS_EQUALS          : 27
PLUS_PLUS            : 24
POWER                : 
PRINT                : 34
=======
OR                   : 
PLUS                 : 51
PLUS_EQUALS          : 29
PLUS_PLUS            : 35
POP                  : 106 111
POPLEFT              : 112
POWER                : 
PRINT                : 39
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
PUSH                 : 105
REQUIRE              : 
REQUIRE_ONCE         : 
<<<<<<< HEAD
RETURN               : 
RIGHT_BRACE          : 75 76
RIGHT_BRACKET        : 107 110
RIGHT_PAREN          : 18 19 32 54 67 68 87 101 104 106
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 63 64 67 68 70
STATIC               : 
STDIN                : 18 19
STRING               : 19 38
SWITCH               : 
THROW                : 
TIMES                : 48
TIMES_EQUALS         : 29
TRAIT                : 
TRUE                 : 81
=======
RETURN               : 22
RIGHT_BRACE          : 77 78 113 116
RIGHT_BRACKET        : 99 102 120
RIGHT_PAREN          : 19 23 24 37 61 62 63 64 69 70 84 98
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 22 65 66 69 70 72
SET                  : 113
STATIC               : 
STDIN                : 23 24
STRING               : 24 46 60 119
SWITCH               : 
THROW                : 
TIMES                : 54
TIMES_EQUALS         : 31
TRAIT                : 
TRUE                 : 79
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
VOID                 : 
<<<<<<< HEAD
WHILE                : 62
=======
WHILE                : 64
XOR                  : 
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
YIELD                : 
YIELD_FROM           : 
error                : 
object_declaration   : 

Nonterminals, with rules where they appear

<<<<<<< HEAD
argument             : 23 36 37 44 108 109
arguments            : 32 33 37
array                : 105
array_declaration_statement : 14
array_elements       : 104 106 107 109
array_indexing       : 43
assignment_list      : 63 72
assignment_operator  : 23
assignment_statement : 13 40 71 72
block                : 55 58 60 62 69
casting              : 44
casting_type         : 101
complex_condition    : 79
condition            : 53 65 85 86 86 87
else_if_extended     : 55 57
expression           : 39 45 46 54 88 88
factor               : 48 49 50
fgets_statement      : 12 42
for_part1            : 65 66
for_part3            : 65 66
for_part4            : 67 68
for_statement        : 7
fscanf_statement     : 11
function_call        : 17 41
if_part2             : 56 57
if_part3             : 55
if_statement         : 5
logical_operator     : 86
negated_condition    : 78
parenthesized_condition : 55 58 62 80
print_function       : 32 33
print_statement      : 10
program              : 0
relational_expression : 84
relational_operator  : 88
simple_condition     : 77
statement            : 4 73 74
statement2           : 2 3
statement_list       : 67 74
statements           : 1 3 75
term                 : 45 46 47 48 49
variable             : 20 21 23 24 25 83 105 110
variable_list        : 19 21
=======
argument             : 34 41 42 43 100 101 103 104 105 107 109 110 114 115 119 121
arguments            : 19 20 21 37 38 42 43
array                : 97
array_declaration_statement : 16
array_elements       : 98 99 101
arrow_function       : 
assignment_list      : 65 74
assignment_operator  : 34
assignment_statement : 15 50 73 74
block                : 19 62 63 63 64 71
condition            : 49 62 63 64 67 82 82 83 84
deque_operations     : 
dictionary_declaration : 
dictionary_elements  : 116 118
elements             : 102 104 120
expression           : 20 21 22 48 51 52 61 81 81
factor               : 54 55 56
fgets_statement      : 14
for_part1            : 67 68
for_part3            : 67 68
for_part4            : 69 70
for_statement        : 7
fscanf_statement     : 13
function_statement   : 9
if_statement         : 5
iterator_declaration : 
key_value_pair       : 117 118
lambda_function      : 
list                 : 
logical_operator     : 82
print_function       : 37 38
print_statement      : 12
program              : 0
queue_operations     : 
relational_operator  : 81
set_declaration      : 
set_elements         : 113 115
stack_operations     : 
statement            : 4 75 76
statement2           : 2 3
statement_list       : 69 76
statement_return     : 8
statements           : 1 3 77
term                 : 51 52 53 54 55
tree_operations      : 
variable             : 25 26 34 35 36 47 59 97
variable_list        : 24 26
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . OPEN_TAG statements CLOSE_TAG

    OPEN_TAG        shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> OPEN_TAG . statements CLOSE_TAG
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
<<<<<<< HEAD
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (17) statement -> . function_call
    (55) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (62) while_statement -> . WHILE parenthesized_condition block
    (65) for_statement -> . for_part1 condition for_part3
    (66) for_statement -> . for_part1 for_part3
    (32) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> . print_function arguments
    (19) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (105) array_declaration_statement -> . variable EQUALS array
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (63) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (64) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (34) print_function -> . PRINT
    (35) print_function -> . ECHO
    (22) variable -> . ID

    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    FSCANF          shift and go to state 23
    FGETS           shift and go to state 24
    NAME            shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    ECHO            shift and go to state 29
    ID              shift and go to state 30
=======
    (8) statement2 -> . statement_return
    (9) statement2 -> . function_statement
    (10) statement2 -> . ONE_LINE_COMMENT
    (11) statement2 -> . MULTI_LINE_COMMENT
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (62) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (63) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (64) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (67) for_statement -> . for_part1 condition for_part3
    (68) for_statement -> . for_part1 for_part3
    (22) statement_return -> . RETURN expression SEMICOLON
    (19) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (97) array_declaration_statement -> . variable EQUALS array
    (65) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (66) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    ONE_LINE_COMMENT shift and go to state 11
    MULTI_LINE_COMMENT shift and go to state 12
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 23
    FUNCTION        shift and go to state 24
    FSCANF          shift and go to state 26
    FGETS           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    ECHO            shift and go to state 31
    ID              shift and go to state 32
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    statements                     shift and go to state 3
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
<<<<<<< HEAD
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    function_call                  shift and go to state 18
    for_part1                      shift and go to state 21
    print_function                 shift and go to state 22
    variable                       shift and go to state 25
=======
    statement_return               shift and go to state 9
    function_statement             shift and go to state 10
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    for_part1                      shift and go to state 22
    print_function                 shift and go to state 25
    variable                       shift and go to state 28
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

state 3

    (1) program -> OPEN_TAG statements . CLOSE_TAG
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
<<<<<<< HEAD
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (17) statement -> . function_call
    (55) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (62) while_statement -> . WHILE parenthesized_condition block
    (65) for_statement -> . for_part1 condition for_part3
    (66) for_statement -> . for_part1 for_part3
    (32) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> . print_function arguments
    (19) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (105) array_declaration_statement -> . variable EQUALS array
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (63) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (64) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (34) print_function -> . PRINT
    (35) print_function -> . ECHO
    (22) variable -> . ID

    CLOSE_TAG       shift and go to state 31
    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    FSCANF          shift and go to state 23
    FGETS           shift and go to state 24
    NAME            shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    ECHO            shift and go to state 29
    ID              shift and go to state 30

    statement2                     shift and go to state 32
=======
    (8) statement2 -> . statement_return
    (9) statement2 -> . function_statement
    (10) statement2 -> . ONE_LINE_COMMENT
    (11) statement2 -> . MULTI_LINE_COMMENT
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (62) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (63) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (64) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (67) for_statement -> . for_part1 condition for_part3
    (68) for_statement -> . for_part1 for_part3
    (22) statement_return -> . RETURN expression SEMICOLON
    (19) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (97) array_declaration_statement -> . variable EQUALS array
    (65) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (66) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    CLOSE_TAG       shift and go to state 33
    ONE_LINE_COMMENT shift and go to state 11
    MULTI_LINE_COMMENT shift and go to state 12
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 23
    FUNCTION        shift and go to state 24
    FSCANF          shift and go to state 26
    FGETS           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    ECHO            shift and go to state 31
    ID              shift and go to state 32

    statement2                     shift and go to state 34
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
<<<<<<< HEAD
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    function_call                  shift and go to state 18
    for_part1                      shift and go to state 21
    print_function                 shift and go to state 22
    variable                       shift and go to state 25
=======
    statement_return               shift and go to state 9
    function_statement             shift and go to state 10
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    for_part1                      shift and go to state 22
    print_function                 shift and go to state 25
    variable                       shift and go to state 28
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

state 4

    (2) statements -> statement2 .

    CLOSE_TAG       reduce using rule 2 (statements -> statement2 .)
    ONE_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    MULTI_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    BREAK           reduce using rule 2 (statements -> statement2 .)
    CONTINUE        reduce using rule 2 (statements -> statement2 .)
    IF              reduce using rule 2 (statements -> statement2 .)
    WHILE           reduce using rule 2 (statements -> statement2 .)
    RETURN          reduce using rule 2 (statements -> statement2 .)
    FUNCTION        reduce using rule 2 (statements -> statement2 .)
    FSCANF          reduce using rule 2 (statements -> statement2 .)
    FGETS           reduce using rule 2 (statements -> statement2 .)
    NAME            reduce using rule 2 (statements -> statement2 .)
    FOR             reduce using rule 2 (statements -> statement2 .)
    PRINT           reduce using rule 2 (statements -> statement2 .)
    ECHO            reduce using rule 2 (statements -> statement2 .)
    ID              reduce using rule 2 (statements -> statement2 .)
    RIGHT_BRACE     reduce using rule 2 (statements -> statement2 .)


state 5

    (4) statement2 -> statement . SEMICOLON

<<<<<<< HEAD
    SEMICOLON       shift and go to state 33
=======
    SEMICOLON       shift and go to state 35
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 6

    (5) statement2 -> if_statement .

    CLOSE_TAG       reduce using rule 5 (statement2 -> if_statement .)
    ONE_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    MULTI_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    BREAK           reduce using rule 5 (statement2 -> if_statement .)
    CONTINUE        reduce using rule 5 (statement2 -> if_statement .)
    IF              reduce using rule 5 (statement2 -> if_statement .)
    WHILE           reduce using rule 5 (statement2 -> if_statement .)
    RETURN          reduce using rule 5 (statement2 -> if_statement .)
    FUNCTION        reduce using rule 5 (statement2 -> if_statement .)
    FSCANF          reduce using rule 5 (statement2 -> if_statement .)
    FGETS           reduce using rule 5 (statement2 -> if_statement .)
    NAME            reduce using rule 5 (statement2 -> if_statement .)
    FOR             reduce using rule 5 (statement2 -> if_statement .)
    PRINT           reduce using rule 5 (statement2 -> if_statement .)
    ECHO            reduce using rule 5 (statement2 -> if_statement .)
    ID              reduce using rule 5 (statement2 -> if_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement2 -> if_statement .)


state 7

    (6) statement2 -> while_statement .

    CLOSE_TAG       reduce using rule 6 (statement2 -> while_statement .)
    ONE_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    MULTI_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    BREAK           reduce using rule 6 (statement2 -> while_statement .)
    CONTINUE        reduce using rule 6 (statement2 -> while_statement .)
    IF              reduce using rule 6 (statement2 -> while_statement .)
    WHILE           reduce using rule 6 (statement2 -> while_statement .)
    RETURN          reduce using rule 6 (statement2 -> while_statement .)
    FUNCTION        reduce using rule 6 (statement2 -> while_statement .)
    FSCANF          reduce using rule 6 (statement2 -> while_statement .)
    FGETS           reduce using rule 6 (statement2 -> while_statement .)
    NAME            reduce using rule 6 (statement2 -> while_statement .)
    FOR             reduce using rule 6 (statement2 -> while_statement .)
    PRINT           reduce using rule 6 (statement2 -> while_statement .)
    ECHO            reduce using rule 6 (statement2 -> while_statement .)
    ID              reduce using rule 6 (statement2 -> while_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement2 -> while_statement .)


state 8

    (7) statement2 -> for_statement .

    CLOSE_TAG       reduce using rule 7 (statement2 -> for_statement .)
    ONE_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    MULTI_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    BREAK           reduce using rule 7 (statement2 -> for_statement .)
    CONTINUE        reduce using rule 7 (statement2 -> for_statement .)
    IF              reduce using rule 7 (statement2 -> for_statement .)
    WHILE           reduce using rule 7 (statement2 -> for_statement .)
    RETURN          reduce using rule 7 (statement2 -> for_statement .)
    FUNCTION        reduce using rule 7 (statement2 -> for_statement .)
    FSCANF          reduce using rule 7 (statement2 -> for_statement .)
    FGETS           reduce using rule 7 (statement2 -> for_statement .)
    NAME            reduce using rule 7 (statement2 -> for_statement .)
    FOR             reduce using rule 7 (statement2 -> for_statement .)
    PRINT           reduce using rule 7 (statement2 -> for_statement .)
    ECHO            reduce using rule 7 (statement2 -> for_statement .)
    ID              reduce using rule 7 (statement2 -> for_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement2 -> for_statement .)


state 9

    (8) statement2 -> statement_return .

<<<<<<< HEAD
    CLOSE_TAG       reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    NAME            reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> ONE_LINE_COMMENT .)
=======
    CLOSE_TAG       reduce using rule 8 (statement2 -> statement_return .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> statement_return .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> statement_return .)
    BREAK           reduce using rule 8 (statement2 -> statement_return .)
    CONTINUE        reduce using rule 8 (statement2 -> statement_return .)
    IF              reduce using rule 8 (statement2 -> statement_return .)
    WHILE           reduce using rule 8 (statement2 -> statement_return .)
    RETURN          reduce using rule 8 (statement2 -> statement_return .)
    FUNCTION        reduce using rule 8 (statement2 -> statement_return .)
    FSCANF          reduce using rule 8 (statement2 -> statement_return .)
    FGETS           reduce using rule 8 (statement2 -> statement_return .)
    FOR             reduce using rule 8 (statement2 -> statement_return .)
    PRINT           reduce using rule 8 (statement2 -> statement_return .)
    ECHO            reduce using rule 8 (statement2 -> statement_return .)
    ID              reduce using rule 8 (statement2 -> statement_return .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> statement_return .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 10

    (9) statement2 -> function_statement .

<<<<<<< HEAD
    CLOSE_TAG       reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    NAME            reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> MULTI_LINE_COMMENT .)
=======
    CLOSE_TAG       reduce using rule 9 (statement2 -> function_statement .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> function_statement .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> function_statement .)
    BREAK           reduce using rule 9 (statement2 -> function_statement .)
    CONTINUE        reduce using rule 9 (statement2 -> function_statement .)
    IF              reduce using rule 9 (statement2 -> function_statement .)
    WHILE           reduce using rule 9 (statement2 -> function_statement .)
    RETURN          reduce using rule 9 (statement2 -> function_statement .)
    FUNCTION        reduce using rule 9 (statement2 -> function_statement .)
    FSCANF          reduce using rule 9 (statement2 -> function_statement .)
    FGETS           reduce using rule 9 (statement2 -> function_statement .)
    FOR             reduce using rule 9 (statement2 -> function_statement .)
    PRINT           reduce using rule 9 (statement2 -> function_statement .)
    ECHO            reduce using rule 9 (statement2 -> function_statement .)
    ID              reduce using rule 9 (statement2 -> function_statement .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> function_statement .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 11

    (10) statement2 -> ONE_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    RETURN          reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    FUNCTION        reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 10 (statement2 -> ONE_LINE_COMMENT .)


state 12

    (11) statement2 -> MULTI_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    RETURN          reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    FUNCTION        reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 11 (statement2 -> MULTI_LINE_COMMENT .)


state 13

    (12) statement -> print_statement .

    SEMICOLON       reduce using rule 12 (statement -> print_statement .)
    RIGHT_PAREN     reduce using rule 12 (statement -> print_statement .)
    COMMA           reduce using rule 12 (statement -> print_statement .)


state 14

    (13) statement -> fscanf_statement .

    SEMICOLON       reduce using rule 13 (statement -> fscanf_statement .)
    RIGHT_PAREN     reduce using rule 13 (statement -> fscanf_statement .)
    COMMA           reduce using rule 13 (statement -> fscanf_statement .)


state 15

    (14) statement -> fgets_statement .

    SEMICOLON       reduce using rule 14 (statement -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 14 (statement -> fgets_statement .)
    COMMA           reduce using rule 14 (statement -> fgets_statement .)


state 16

    (15) statement -> assignment_statement .

    SEMICOLON       reduce using rule 15 (statement -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 15 (statement -> assignment_statement .)
    COMMA           reduce using rule 15 (statement -> assignment_statement .)


state 17

    (16) statement -> array_declaration_statement .

    SEMICOLON       reduce using rule 16 (statement -> array_declaration_statement .)
    RIGHT_PAREN     reduce using rule 16 (statement -> array_declaration_statement .)
    COMMA           reduce using rule 16 (statement -> array_declaration_statement .)


state 18

<<<<<<< HEAD
    (17) statement -> function_call .

    SEMICOLON       reduce using rule 17 (statement -> function_call .)
    RIGHT_PAREN     reduce using rule 17 (statement -> function_call .)
    COMMA           reduce using rule 17 (statement -> function_call .)
=======
    (17) statement -> BREAK .

    SEMICOLON       reduce using rule 17 (statement -> BREAK .)
    RIGHT_PAREN     reduce using rule 17 (statement -> BREAK .)
    COMMA           reduce using rule 17 (statement -> BREAK .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 19

<<<<<<< HEAD
    (55) if_statement -> IF . parenthesized_condition block else_if_extended if_part3
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 35
=======
    (18) statement -> CONTINUE .

    SEMICOLON       reduce using rule 18 (statement -> CONTINUE .)
    RIGHT_PAREN     reduce using rule 18 (statement -> CONTINUE .)
    COMMA           reduce using rule 18 (statement -> CONTINUE .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    parenthesized_condition        shift and go to state 34

state 20

<<<<<<< HEAD
    (62) while_statement -> WHILE . parenthesized_condition block
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 35

    parenthesized_condition        shift and go to state 36

state 21

    (65) for_statement -> for_part1 . condition for_part3
    (66) for_statement -> for_part1 . for_part3
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (67) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (68) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN

    SEMICOLON       shift and go to state 43
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54

    condition                      shift and go to state 37
    for_part3                      shift and go to state 38
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47
    expression                     shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52

state 22

    (32) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> print_function . arguments
    (36) arguments -> . argument
    (37) arguments -> . arguments DOT argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    LEFT_PAREN      shift and go to state 55
    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    arguments                      shift and go to state 56
    argument                       shift and go to state 57
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 23

    (19) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 67
=======
    (62) if_statement -> IF . LEFT_PAREN condition RIGHT_PAREN block
    (63) if_statement -> IF . LEFT_PAREN condition RIGHT_PAREN block ELSE block

    LEFT_PAREN      shift and go to state 36


state 21

    (64) while_statement -> WHILE . LEFT_PAREN condition RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 37


state 22

    (67) for_statement -> for_part1 . condition for_part3
    (68) for_statement -> for_part1 . for_part3
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (69) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (70) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    SEMICOLON       shift and go to state 45
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    ID              shift and go to state 32

    condition                      shift and go to state 38
    for_part3                      shift and go to state 39
    expression                     shift and go to state 42
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 23

    (22) statement_return -> RETURN . expression SEMICOLON
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    expression                     shift and go to state 52
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 24

<<<<<<< HEAD
    (18) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN
=======
    (19) function_statement -> FUNCTION . NAME LEFT_PAREN arguments RIGHT_PAREN block

    NAME            shift and go to state 54


state 25

    (37) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> print_function . arguments
    (41) arguments -> . argument
    (42) arguments -> . arguments DOT argument
    (43) arguments -> . arguments COMMA argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    LEFT_PAREN      shift and go to state 55
    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43

    arguments                      shift and go to state 56
    argument                       shift and go to state 57
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 25

    (23) assignment_statement -> variable . assignment_operator argument
    (24) assignment_statement -> variable . PLUS_PLUS
    (25) assignment_statement -> variable . MINUS_MINUS
    (105) array_declaration_statement -> variable . EQUALS array
    (26) assignment_operator -> . EQUALS
    (27) assignment_operator -> . PLUS_EQUALS
    (28) assignment_operator -> . MINUS_EQUALS
    (29) assignment_operator -> . TIMES_EQUALS
    (30) assignment_operator -> . DIVIDE_EQUALS
    (31) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 70
    MINUS_MINUS     shift and go to state 71
    EQUALS          shift and go to state 72
    PLUS_EQUALS     shift and go to state 73
    MINUS_EQUALS    shift and go to state 74
    TIMES_EQUALS    shift and go to state 75
    DIVIDE_EQUALS   shift and go to state 76
    MOD_EQUALS      shift and go to state 77

    assignment_operator            shift and go to state 69

state 26

<<<<<<< HEAD
    (104) function_call -> NAME . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 78
=======
    (24) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 65
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 27

<<<<<<< HEAD
    (63) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (64) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 79
=======
    (23) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 66
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 28

<<<<<<< HEAD
    (34) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 34 (print_function -> PRINT .)
    STRING          reduce using rule 34 (print_function -> PRINT .)
    NAME            reduce using rule 34 (print_function -> PRINT .)
    FGETS           reduce using rule 34 (print_function -> PRINT .)
    ID              reduce using rule 34 (print_function -> PRINT .)
    INTEGER         reduce using rule 34 (print_function -> PRINT .)
    FLOAT           reduce using rule 34 (print_function -> PRINT .)
    TRUE            reduce using rule 34 (print_function -> PRINT .)
    FALSE           reduce using rule 34 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 34 (print_function -> PRINT .)
=======
    (34) assignment_statement -> variable . assignment_operator argument
    (35) assignment_statement -> variable . PLUS_PLUS
    (36) assignment_statement -> variable . MINUS_MINUS
    (97) array_declaration_statement -> variable . EQUALS array
    (28) assignment_operator -> . EQUALS
    (29) assignment_operator -> . PLUS_EQUALS
    (30) assignment_operator -> . MINUS_EQUALS
    (31) assignment_operator -> . TIMES_EQUALS
    (32) assignment_operator -> . DIVIDE_EQUALS
    (33) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 68
    MINUS_MINUS     shift and go to state 69
    EQUALS          shift and go to state 70
    PLUS_EQUALS     shift and go to state 71
    MINUS_EQUALS    shift and go to state 72
    TIMES_EQUALS    shift and go to state 73
    DIVIDE_EQUALS   shift and go to state 74
    MOD_EQUALS      shift and go to state 75
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    assignment_operator            shift and go to state 67

state 29

<<<<<<< HEAD
    (35) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 35 (print_function -> ECHO .)
    STRING          reduce using rule 35 (print_function -> ECHO .)
    NAME            reduce using rule 35 (print_function -> ECHO .)
    FGETS           reduce using rule 35 (print_function -> ECHO .)
    ID              reduce using rule 35 (print_function -> ECHO .)
    INTEGER         reduce using rule 35 (print_function -> ECHO .)
    FLOAT           reduce using rule 35 (print_function -> ECHO .)
    TRUE            reduce using rule 35 (print_function -> ECHO .)
    FALSE           reduce using rule 35 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 35 (print_function -> ECHO .)
=======
    (65) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (66) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 76
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 30

<<<<<<< HEAD
    (22) variable -> ID .

    PLUS_PLUS       reduce using rule 22 (variable -> ID .)
    MINUS_MINUS     reduce using rule 22 (variable -> ID .)
    EQUALS          reduce using rule 22 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 22 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 22 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 22 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 22 (variable -> ID .)
    MOD_EQUALS      reduce using rule 22 (variable -> ID .)
    SEMICOLON       reduce using rule 22 (variable -> ID .)
    LOGICAL_AND     reduce using rule 22 (variable -> ID .)
    LOGICAL_OR      reduce using rule 22 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 22 (variable -> ID .)
    TIMES           reduce using rule 22 (variable -> ID .)
    DIVIDE          reduce using rule 22 (variable -> ID .)
    PLUS            reduce using rule 22 (variable -> ID .)
    MINUS           reduce using rule 22 (variable -> ID .)
    EQUAL_TO        reduce using rule 22 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 22 (variable -> ID .)
    LESS_THAN       reduce using rule 22 (variable -> ID .)
    GREATER_THAN    reduce using rule 22 (variable -> ID .)
    LESS_EQUAL      reduce using rule 22 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 22 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 22 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 22 (variable -> ID .)
    DIFFERENT       reduce using rule 22 (variable -> ID .)
    LEFT_BRACKET    reduce using rule 22 (variable -> ID .)
    DOT             reduce using rule 22 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 22 (variable -> ID .)
    COMMA           reduce using rule 22 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 22 (variable -> ID .)
=======
    (39) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 39 (print_function -> PRINT .)
    INTEGER         reduce using rule 39 (print_function -> PRINT .)
    FLOAT           reduce using rule 39 (print_function -> PRINT .)
    STRING          reduce using rule 39 (print_function -> PRINT .)
    ID              reduce using rule 39 (print_function -> PRINT .)
    TRUE            reduce using rule 39 (print_function -> PRINT .)
    FALSE           reduce using rule 39 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 39 (print_function -> PRINT .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 31

<<<<<<< HEAD
=======
    (40) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 40 (print_function -> ECHO .)
    INTEGER         reduce using rule 40 (print_function -> ECHO .)
    FLOAT           reduce using rule 40 (print_function -> ECHO .)
    STRING          reduce using rule 40 (print_function -> ECHO .)
    ID              reduce using rule 40 (print_function -> ECHO .)
    TRUE            reduce using rule 40 (print_function -> ECHO .)
    FALSE           reduce using rule 40 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 40 (print_function -> ECHO .)


state 32

    (27) variable -> ID .

    PLUS_PLUS       reduce using rule 27 (variable -> ID .)
    MINUS_MINUS     reduce using rule 27 (variable -> ID .)
    EQUALS          reduce using rule 27 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 27 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 27 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 27 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 27 (variable -> ID .)
    MOD_EQUALS      reduce using rule 27 (variable -> ID .)
    TIMES           reduce using rule 27 (variable -> ID .)
    DIVIDE          reduce using rule 27 (variable -> ID .)
    PLUS            reduce using rule 27 (variable -> ID .)
    MINUS           reduce using rule 27 (variable -> ID .)
    EQUAL_TO        reduce using rule 27 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 27 (variable -> ID .)
    LESS_THAN       reduce using rule 27 (variable -> ID .)
    GREATER_THAN    reduce using rule 27 (variable -> ID .)
    LESS_EQUAL      reduce using rule 27 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 27 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 27 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 27 (variable -> ID .)
    DIFFERENT       reduce using rule 27 (variable -> ID .)
    SEMICOLON       reduce using rule 27 (variable -> ID .)
    DOT             reduce using rule 27 (variable -> ID .)
    COMMA           reduce using rule 27 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 27 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 27 (variable -> ID .)
    LOGICAL_AND     reduce using rule 27 (variable -> ID .)
    LOGICAL_OR      reduce using rule 27 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 27 (variable -> ID .)


state 33

>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    (1) program -> OPEN_TAG statements CLOSE_TAG .

    $end            reduce using rule 1 (program -> OPEN_TAG statements CLOSE_TAG .)


<<<<<<< HEAD
state 32
=======
state 34
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    (3) statements -> statements statement2 .

    CLOSE_TAG       reduce using rule 3 (statements -> statements statement2 .)
    ONE_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    MULTI_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    BREAK           reduce using rule 3 (statements -> statements statement2 .)
    CONTINUE        reduce using rule 3 (statements -> statements statement2 .)
    IF              reduce using rule 3 (statements -> statements statement2 .)
    WHILE           reduce using rule 3 (statements -> statements statement2 .)
    RETURN          reduce using rule 3 (statements -> statements statement2 .)
    FUNCTION        reduce using rule 3 (statements -> statements statement2 .)
    FSCANF          reduce using rule 3 (statements -> statements statement2 .)
    FGETS           reduce using rule 3 (statements -> statements statement2 .)
    NAME            reduce using rule 3 (statements -> statements statement2 .)
    FOR             reduce using rule 3 (statements -> statements statement2 .)
    PRINT           reduce using rule 3 (statements -> statements statement2 .)
    ECHO            reduce using rule 3 (statements -> statements statement2 .)
    ID              reduce using rule 3 (statements -> statements statement2 .)
    RIGHT_BRACE     reduce using rule 3 (statements -> statements statement2 .)


<<<<<<< HEAD
state 33
=======
state 35
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    (4) statement2 -> statement SEMICOLON .

    CLOSE_TAG       reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    BREAK           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    IF              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RETURN          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FSCANF          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FGETS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    NAME            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FOR             reduce using rule 4 (statement2 -> statement SEMICOLON .)
    PRINT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ECHO            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ID              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RIGHT_BRACE     reduce using rule 4 (statement2 -> statement SEMICOLON .)


<<<<<<< HEAD
state 34

    (55) if_statement -> IF parenthesized_condition . block else_if_extended if_part3
    (75) block -> . LEFT_BRACE statements RIGHT_BRACE
    (76) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 81

    block                          shift and go to state 80

state 35

    (87) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54

    condition                      shift and go to state 82
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47
    expression                     shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52

state 36

    (62) while_statement -> WHILE parenthesized_condition . block
    (75) block -> . LEFT_BRACE statements RIGHT_BRACE
    (76) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 81

    block                          shift and go to state 83

state 37

    (65) for_statement -> for_part1 condition . for_part3
    (86) complex_condition -> condition . logical_operator condition
    (53) factor -> condition .
    (67) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (68) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (98) logical_operator -> . LOGICAL_AND
    (99) logical_operator -> . LOGICAL_OR
    (100) logical_operator -> . LOGICAL_XOR

    TIMES           reduce using rule 53 (factor -> condition .)
    DIVIDE          reduce using rule 53 (factor -> condition .)
    PLUS            reduce using rule 53 (factor -> condition .)
    MINUS           reduce using rule 53 (factor -> condition .)
    EQUAL_TO        reduce using rule 53 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 53 (factor -> condition .)
    LESS_THAN       reduce using rule 53 (factor -> condition .)
    GREATER_THAN    reduce using rule 53 (factor -> condition .)
    LESS_EQUAL      reduce using rule 53 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 53 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 53 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 53 (factor -> condition .)
    DIFFERENT       reduce using rule 53 (factor -> condition .)
    SEMICOLON       shift and go to state 43
    LOGICAL_AND     shift and go to state 86
    LOGICAL_OR      shift and go to state 87
    LOGICAL_XOR     shift and go to state 88

    for_part3                      shift and go to state 84
    logical_operator               shift and go to state 85

state 38

    (66) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    NAME            reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 66 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 66 (for_statement -> for_part1 for_part3 .)


state 39

    (77) condition -> simple_condition .

    SEMICOLON       reduce using rule 77 (condition -> simple_condition .)
    LOGICAL_AND     reduce using rule 77 (condition -> simple_condition .)
    LOGICAL_OR      reduce using rule 77 (condition -> simple_condition .)
    LOGICAL_XOR     reduce using rule 77 (condition -> simple_condition .)
    TIMES           reduce using rule 77 (condition -> simple_condition .)
    DIVIDE          reduce using rule 77 (condition -> simple_condition .)
    PLUS            reduce using rule 77 (condition -> simple_condition .)
    MINUS           reduce using rule 77 (condition -> simple_condition .)
    EQUAL_TO        reduce using rule 77 (condition -> simple_condition .)
    NOT_EQUAL_TO    reduce using rule 77 (condition -> simple_condition .)
    LESS_THAN       reduce using rule 77 (condition -> simple_condition .)
    GREATER_THAN    reduce using rule 77 (condition -> simple_condition .)
    LESS_EQUAL      reduce using rule 77 (condition -> simple_condition .)
    GREATER_EQUAL   reduce using rule 77 (condition -> simple_condition .)
    IDENTICAL_TO    reduce using rule 77 (condition -> simple_condition .)
    NOT_IDENTICAL_TO reduce using rule 77 (condition -> simple_condition .)
    DIFFERENT       reduce using rule 77 (condition -> simple_condition .)
    DOT             reduce using rule 77 (condition -> simple_condition .)
    RIGHT_PAREN     reduce using rule 77 (condition -> simple_condition .)
    COMMA           reduce using rule 77 (condition -> simple_condition .)
    RIGHT_BRACKET   reduce using rule 77 (condition -> simple_condition .)
=======
state 36

    (62) if_statement -> IF LEFT_PAREN . condition RIGHT_PAREN block
    (63) if_statement -> IF LEFT_PAREN . condition RIGHT_PAREN block ELSE block
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    ID              shift and go to state 32

    condition                      shift and go to state 77
    expression                     shift and go to state 42
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 37

    (64) while_statement -> WHILE LEFT_PAREN . condition RIGHT_PAREN block
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    ID              shift and go to state 32

    condition                      shift and go to state 78
    expression                     shift and go to state 42
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 38

    (67) for_statement -> for_part1 condition . for_part3
    (82) condition -> condition . logical_operator condition
    (69) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (70) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

    SEMICOLON       shift and go to state 45
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

    for_part3                      shift and go to state 79
    logical_operator               shift and go to state 80

state 39

    (68) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    RETURN          reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    FUNCTION        reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 68 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 68 (for_statement -> for_part1 for_part3 .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 40

<<<<<<< HEAD
    (78) condition -> negated_condition .

    SEMICOLON       reduce using rule 78 (condition -> negated_condition .)
    LOGICAL_AND     reduce using rule 78 (condition -> negated_condition .)
    LOGICAL_OR      reduce using rule 78 (condition -> negated_condition .)
    LOGICAL_XOR     reduce using rule 78 (condition -> negated_condition .)
    TIMES           reduce using rule 78 (condition -> negated_condition .)
    DIVIDE          reduce using rule 78 (condition -> negated_condition .)
    PLUS            reduce using rule 78 (condition -> negated_condition .)
    MINUS           reduce using rule 78 (condition -> negated_condition .)
    EQUAL_TO        reduce using rule 78 (condition -> negated_condition .)
    NOT_EQUAL_TO    reduce using rule 78 (condition -> negated_condition .)
    LESS_THAN       reduce using rule 78 (condition -> negated_condition .)
    GREATER_THAN    reduce using rule 78 (condition -> negated_condition .)
    LESS_EQUAL      reduce using rule 78 (condition -> negated_condition .)
    GREATER_EQUAL   reduce using rule 78 (condition -> negated_condition .)
    IDENTICAL_TO    reduce using rule 78 (condition -> negated_condition .)
    NOT_IDENTICAL_TO reduce using rule 78 (condition -> negated_condition .)
    DIFFERENT       reduce using rule 78 (condition -> negated_condition .)
    DOT             reduce using rule 78 (condition -> negated_condition .)
    RIGHT_PAREN     reduce using rule 78 (condition -> negated_condition .)
    COMMA           reduce using rule 78 (condition -> negated_condition .)
    RIGHT_BRACKET   reduce using rule 78 (condition -> negated_condition .)
=======
    (79) condition -> TRUE .

    SEMICOLON       reduce using rule 79 (condition -> TRUE .)
    LOGICAL_AND     reduce using rule 79 (condition -> TRUE .)
    LOGICAL_OR      reduce using rule 79 (condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 79 (condition -> TRUE .)
    DOT             reduce using rule 79 (condition -> TRUE .)
    COMMA           reduce using rule 79 (condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 79 (condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 79 (condition -> TRUE .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 41

<<<<<<< HEAD
    (79) condition -> complex_condition .

    SEMICOLON       reduce using rule 79 (condition -> complex_condition .)
    LOGICAL_AND     reduce using rule 79 (condition -> complex_condition .)
    LOGICAL_OR      reduce using rule 79 (condition -> complex_condition .)
    LOGICAL_XOR     reduce using rule 79 (condition -> complex_condition .)
    TIMES           reduce using rule 79 (condition -> complex_condition .)
    DIVIDE          reduce using rule 79 (condition -> complex_condition .)
    PLUS            reduce using rule 79 (condition -> complex_condition .)
    MINUS           reduce using rule 79 (condition -> complex_condition .)
    EQUAL_TO        reduce using rule 79 (condition -> complex_condition .)
    NOT_EQUAL_TO    reduce using rule 79 (condition -> complex_condition .)
    LESS_THAN       reduce using rule 79 (condition -> complex_condition .)
    GREATER_THAN    reduce using rule 79 (condition -> complex_condition .)
    LESS_EQUAL      reduce using rule 79 (condition -> complex_condition .)
    GREATER_EQUAL   reduce using rule 79 (condition -> complex_condition .)
    IDENTICAL_TO    reduce using rule 79 (condition -> complex_condition .)
    NOT_IDENTICAL_TO reduce using rule 79 (condition -> complex_condition .)
    DIFFERENT       reduce using rule 79 (condition -> complex_condition .)
    DOT             reduce using rule 79 (condition -> complex_condition .)
    RIGHT_PAREN     reduce using rule 79 (condition -> complex_condition .)
    COMMA           reduce using rule 79 (condition -> complex_condition .)
    RIGHT_BRACKET   reduce using rule 79 (condition -> complex_condition .)
=======
    (80) condition -> FALSE .

    SEMICOLON       reduce using rule 80 (condition -> FALSE .)
    LOGICAL_AND     reduce using rule 80 (condition -> FALSE .)
    LOGICAL_OR      reduce using rule 80 (condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 80 (condition -> FALSE .)
    DOT             reduce using rule 80 (condition -> FALSE .)
    COMMA           reduce using rule 80 (condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 80 (condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 80 (condition -> FALSE .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 42

<<<<<<< HEAD
    (80) condition -> parenthesized_condition .

    SEMICOLON       reduce using rule 80 (condition -> parenthesized_condition .)
    LOGICAL_AND     reduce using rule 80 (condition -> parenthesized_condition .)
    LOGICAL_OR      reduce using rule 80 (condition -> parenthesized_condition .)
    LOGICAL_XOR     reduce using rule 80 (condition -> parenthesized_condition .)
    TIMES           reduce using rule 80 (condition -> parenthesized_condition .)
    DIVIDE          reduce using rule 80 (condition -> parenthesized_condition .)
    PLUS            reduce using rule 80 (condition -> parenthesized_condition .)
    MINUS           reduce using rule 80 (condition -> parenthesized_condition .)
    EQUAL_TO        reduce using rule 80 (condition -> parenthesized_condition .)
    NOT_EQUAL_TO    reduce using rule 80 (condition -> parenthesized_condition .)
    LESS_THAN       reduce using rule 80 (condition -> parenthesized_condition .)
    GREATER_THAN    reduce using rule 80 (condition -> parenthesized_condition .)
    LESS_EQUAL      reduce using rule 80 (condition -> parenthesized_condition .)
    GREATER_EQUAL   reduce using rule 80 (condition -> parenthesized_condition .)
    IDENTICAL_TO    reduce using rule 80 (condition -> parenthesized_condition .)
    NOT_IDENTICAL_TO reduce using rule 80 (condition -> parenthesized_condition .)
    DIFFERENT       reduce using rule 80 (condition -> parenthesized_condition .)
    DOT             reduce using rule 80 (condition -> parenthesized_condition .)
    RIGHT_PAREN     reduce using rule 80 (condition -> parenthesized_condition .)
    COMMA           reduce using rule 80 (condition -> parenthesized_condition .)
    RIGHT_BRACKET   reduce using rule 80 (condition -> parenthesized_condition .)
=======
    (81) condition -> expression . relational_operator expression
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (85) relational_operator -> . EQUAL_TO
    (86) relational_operator -> . NOT_EQUAL_TO
    (87) relational_operator -> . LESS_THAN
    (88) relational_operator -> . GREATER_THAN
    (89) relational_operator -> . LESS_EQUAL
    (90) relational_operator -> . GREATER_EQUAL
    (91) relational_operator -> . IDENTICAL_TO
    (92) relational_operator -> . NOT_IDENTICAL_TO
    (93) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    EQUAL_TO        shift and go to state 87
    NOT_EQUAL_TO    shift and go to state 88
    LESS_THAN       shift and go to state 89
    GREATER_THAN    shift and go to state 90
    LESS_EQUAL      shift and go to state 91
    GREATER_EQUAL   shift and go to state 92
    IDENTICAL_TO    shift and go to state 93
    NOT_IDENTICAL_TO shift and go to state 94
    DIFFERENT       shift and go to state 95
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    relational_operator            shift and go to state 84

state 43

<<<<<<< HEAD
    (67) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (68) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (73) statement_list -> . statement
    (74) statement_list -> . statement_list COMMA statement
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (17) statement -> . function_call
    (32) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> . print_function arguments
    (19) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (105) array_declaration_statement -> . variable EQUALS array
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (34) print_function -> . PRINT
    (35) print_function -> . ECHO
    (22) variable -> . ID

    RIGHT_PAREN     shift and go to state 90
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    FSCANF          shift and go to state 23
    FGETS           shift and go to state 24
    NAME            shift and go to state 26
    PRINT           shift and go to state 28
    ECHO            shift and go to state 29
    ID              shift and go to state 30

    statement_list                 shift and go to state 89
    statement                      shift and go to state 91
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    function_call                  shift and go to state 18
    print_function                 shift and go to state 22
    variable                       shift and go to state 25
=======
    (83) condition -> LOGICAL_NOT . condition
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    ID              shift and go to state 32

    condition                      shift and go to state 96
    expression                     shift and go to state 42
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 44

    (84) condition -> LEFT_PAREN . condition RIGHT_PAREN
    (61) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    ID              shift and go to state 32

    condition                      shift and go to state 97
    expression                     shift and go to state 98
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 45

    (69) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (70) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (75) statement_list -> . statement
    (76) statement_list -> . statement_list COMMA statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (97) array_declaration_statement -> . variable EQUALS array
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    RIGHT_PAREN     shift and go to state 100
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 26
    FGETS           shift and go to state 27
    PRINT           shift and go to state 30
    ECHO            shift and go to state 31
    ID              shift and go to state 32

    statement_list                 shift and go to state 99
    statement                      shift and go to state 101
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    print_function                 shift and go to state 25
    variable                       shift and go to state 28

state 46

    (53) expression -> term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

    PLUS            reduce using rule 53 (expression -> term .)
    MINUS           reduce using rule 53 (expression -> term .)
    EQUAL_TO        reduce using rule 53 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 53 (expression -> term .)
    LESS_THAN       reduce using rule 53 (expression -> term .)
    GREATER_THAN    reduce using rule 53 (expression -> term .)
    LESS_EQUAL      reduce using rule 53 (expression -> term .)
    GREATER_EQUAL   reduce using rule 53 (expression -> term .)
    IDENTICAL_TO    reduce using rule 53 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 53 (expression -> term .)
    DIFFERENT       reduce using rule 53 (expression -> term .)
    SEMICOLON       reduce using rule 53 (expression -> term .)
    DOT             reduce using rule 53 (expression -> term .)
    COMMA           reduce using rule 53 (expression -> term .)
    RIGHT_PAREN     reduce using rule 53 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 53 (expression -> term .)
    LOGICAL_AND     reduce using rule 53 (expression -> term .)
    LOGICAL_OR      reduce using rule 53 (expression -> term .)
    LOGICAL_XOR     reduce using rule 53 (expression -> term .)
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103


state 47

    (56) term -> factor .

    TIMES           reduce using rule 56 (term -> factor .)
    DIVIDE          reduce using rule 56 (term -> factor .)
    PLUS            reduce using rule 56 (term -> factor .)
    MINUS           reduce using rule 56 (term -> factor .)
    EQUAL_TO        reduce using rule 56 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 56 (term -> factor .)
    LESS_THAN       reduce using rule 56 (term -> factor .)
    GREATER_THAN    reduce using rule 56 (term -> factor .)
    LESS_EQUAL      reduce using rule 56 (term -> factor .)
    GREATER_EQUAL   reduce using rule 56 (term -> factor .)
    IDENTICAL_TO    reduce using rule 56 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 56 (term -> factor .)
    DIFFERENT       reduce using rule 56 (term -> factor .)
    SEMICOLON       reduce using rule 56 (term -> factor .)
    DOT             reduce using rule 56 (term -> factor .)
    COMMA           reduce using rule 56 (term -> factor .)
    RIGHT_PAREN     reduce using rule 56 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 56 (term -> factor .)
    LOGICAL_AND     reduce using rule 56 (term -> factor .)
    LOGICAL_OR      reduce using rule 56 (term -> factor .)
    LOGICAL_XOR     reduce using rule 56 (term -> factor .)


state 48

    (57) factor -> INTEGER .

    TIMES           reduce using rule 57 (factor -> INTEGER .)
    DIVIDE          reduce using rule 57 (factor -> INTEGER .)
    PLUS            reduce using rule 57 (factor -> INTEGER .)
    MINUS           reduce using rule 57 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 57 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 57 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 57 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 57 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 57 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 57 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 57 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 57 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 57 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 57 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 57 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 57 (factor -> INTEGER .)
    DOT             reduce using rule 57 (factor -> INTEGER .)
    COMMA           reduce using rule 57 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 57 (factor -> INTEGER .)


state 49

    (58) factor -> FLOAT .

    TIMES           reduce using rule 58 (factor -> FLOAT .)
    DIVIDE          reduce using rule 58 (factor -> FLOAT .)
    PLUS            reduce using rule 58 (factor -> FLOAT .)
    MINUS           reduce using rule 58 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 58 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 58 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 58 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 58 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 58 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 58 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 58 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 58 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 58 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 58 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 58 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 58 (factor -> FLOAT .)
    DOT             reduce using rule 58 (factor -> FLOAT .)
    COMMA           reduce using rule 58 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 58 (factor -> FLOAT .)


state 50

    (59) factor -> variable .

    TIMES           reduce using rule 59 (factor -> variable .)
    DIVIDE          reduce using rule 59 (factor -> variable .)
    PLUS            reduce using rule 59 (factor -> variable .)
    MINUS           reduce using rule 59 (factor -> variable .)
    EQUAL_TO        reduce using rule 59 (factor -> variable .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> variable .)
    LESS_THAN       reduce using rule 59 (factor -> variable .)
    GREATER_THAN    reduce using rule 59 (factor -> variable .)
    LESS_EQUAL      reduce using rule 59 (factor -> variable .)
    GREATER_EQUAL   reduce using rule 59 (factor -> variable .)
    IDENTICAL_TO    reduce using rule 59 (factor -> variable .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> variable .)
    DIFFERENT       reduce using rule 59 (factor -> variable .)
    SEMICOLON       reduce using rule 59 (factor -> variable .)
    RIGHT_PAREN     reduce using rule 59 (factor -> variable .)
    LOGICAL_AND     reduce using rule 59 (factor -> variable .)
    LOGICAL_OR      reduce using rule 59 (factor -> variable .)
    LOGICAL_XOR     reduce using rule 59 (factor -> variable .)
    DOT             reduce using rule 59 (factor -> variable .)
    COMMA           reduce using rule 59 (factor -> variable .)
    RIGHT_BRACKET   reduce using rule 59 (factor -> variable .)


state 51

    (60) factor -> STRING .

    TIMES           reduce using rule 60 (factor -> STRING .)
    DIVIDE          reduce using rule 60 (factor -> STRING .)
    PLUS            reduce using rule 60 (factor -> STRING .)
    MINUS           reduce using rule 60 (factor -> STRING .)
    EQUAL_TO        reduce using rule 60 (factor -> STRING .)
    NOT_EQUAL_TO    reduce using rule 60 (factor -> STRING .)
    LESS_THAN       reduce using rule 60 (factor -> STRING .)
    GREATER_THAN    reduce using rule 60 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 60 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 60 (factor -> STRING .)
    IDENTICAL_TO    reduce using rule 60 (factor -> STRING .)
    NOT_IDENTICAL_TO reduce using rule 60 (factor -> STRING .)
    DIFFERENT       reduce using rule 60 (factor -> STRING .)
    SEMICOLON       reduce using rule 60 (factor -> STRING .)
    RIGHT_PAREN     reduce using rule 60 (factor -> STRING .)
    LOGICAL_AND     reduce using rule 60 (factor -> STRING .)
    LOGICAL_OR      reduce using rule 60 (factor -> STRING .)
    LOGICAL_XOR     reduce using rule 60 (factor -> STRING .)
    DOT             reduce using rule 60 (factor -> STRING .)
    COMMA           reduce using rule 60 (factor -> STRING .)
    RIGHT_BRACKET   reduce using rule 60 (factor -> STRING .)


state 52

    (22) statement_return -> RETURN expression . SEMICOLON
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 104
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86


state 53

    (61) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32

    expression                     shift and go to state 105
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 54

    (19) function_statement -> FUNCTION NAME . LEFT_PAREN arguments RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 106


state 55

    (37) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (84) condition -> LEFT_PAREN . condition RIGHT_PAREN
    (61) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (41) arguments -> . argument
    (42) arguments -> . arguments DOT argument
    (43) arguments -> . arguments COMMA argument
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (27) variable -> . ID
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32

    arguments                      shift and go to state 107
    condition                      shift and go to state 108
    expression                     shift and go to state 109
    argument                       shift and go to state 57
    term                           shift and go to state 46
    variable                       shift and go to state 61
    assignment_statement           shift and go to state 64
    factor                         shift and go to state 47

state 56

    (38) print_statement -> print_function arguments .
    (42) arguments -> arguments . DOT argument
    (43) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 38 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 38 (print_statement -> print_function arguments .)
    DOT             shift and go to state 110
    COMMA           shift and go to state 111

  ! COMMA           [ reduce using rule 38 (print_statement -> print_function arguments .) ]


state 57

    (41) arguments -> argument .

    DOT             reduce using rule 41 (arguments -> argument .)
    COMMA           reduce using rule 41 (arguments -> argument .)
    SEMICOLON       reduce using rule 41 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 41 (arguments -> argument .)


state 58

    (44) argument -> INTEGER .
    (57) factor -> INTEGER .

  ! reduce/reduce conflict for DOT resolved using rule 44 (argument -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 44 (argument -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 44 (argument -> INTEGER .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 44 (argument -> INTEGER .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 44 (argument -> INTEGER .)
    DOT             reduce using rule 44 (argument -> INTEGER .)
    COMMA           reduce using rule 44 (argument -> INTEGER .)
    SEMICOLON       reduce using rule 44 (argument -> INTEGER .)
    RIGHT_PAREN     reduce using rule 44 (argument -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 44 (argument -> INTEGER .)
    TIMES           reduce using rule 57 (factor -> INTEGER .)
    DIVIDE          reduce using rule 57 (factor -> INTEGER .)
    PLUS            reduce using rule 57 (factor -> INTEGER .)
    MINUS           reduce using rule 57 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 57 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 57 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 57 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 57 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 57 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 57 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 57 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 57 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 57 (factor -> INTEGER .)

  ! DOT             [ reduce using rule 57 (factor -> INTEGER .) ]
  ! COMMA           [ reduce using rule 57 (factor -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 57 (factor -> INTEGER .) ]
  ! RIGHT_PAREN     [ reduce using rule 57 (factor -> INTEGER .) ]
  ! RIGHT_BRACKET   [ reduce using rule 57 (factor -> INTEGER .) ]


state 59

    (45) argument -> FLOAT .
    (58) factor -> FLOAT .

  ! reduce/reduce conflict for DOT resolved using rule 45 (argument -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 45 (argument -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (argument -> FLOAT .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 45 (argument -> FLOAT .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 45 (argument -> FLOAT .)
    DOT             reduce using rule 45 (argument -> FLOAT .)
    COMMA           reduce using rule 45 (argument -> FLOAT .)
    SEMICOLON       reduce using rule 45 (argument -> FLOAT .)
    RIGHT_PAREN     reduce using rule 45 (argument -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 45 (argument -> FLOAT .)
    TIMES           reduce using rule 58 (factor -> FLOAT .)
    DIVIDE          reduce using rule 58 (factor -> FLOAT .)
    PLUS            reduce using rule 58 (factor -> FLOAT .)
    MINUS           reduce using rule 58 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 58 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 58 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 58 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 58 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 58 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 58 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 58 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 58 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 58 (factor -> FLOAT .)

  ! DOT             [ reduce using rule 58 (factor -> FLOAT .) ]
  ! COMMA           [ reduce using rule 58 (factor -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 58 (factor -> FLOAT .) ]
  ! RIGHT_PAREN     [ reduce using rule 58 (factor -> FLOAT .) ]
  ! RIGHT_BRACKET   [ reduce using rule 58 (factor -> FLOAT .) ]


state 60

    (46) argument -> STRING .
    (60) factor -> STRING .

  ! reduce/reduce conflict for DOT resolved using rule 46 (argument -> STRING .)
  ! reduce/reduce conflict for COMMA resolved using rule 46 (argument -> STRING .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 46 (argument -> STRING .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 46 (argument -> STRING .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 46 (argument -> STRING .)
    DOT             reduce using rule 46 (argument -> STRING .)
    COMMA           reduce using rule 46 (argument -> STRING .)
    SEMICOLON       reduce using rule 46 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 46 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 46 (argument -> STRING .)
    TIMES           reduce using rule 60 (factor -> STRING .)
    DIVIDE          reduce using rule 60 (factor -> STRING .)
    PLUS            reduce using rule 60 (factor -> STRING .)
    MINUS           reduce using rule 60 (factor -> STRING .)
    EQUAL_TO        reduce using rule 60 (factor -> STRING .)
    NOT_EQUAL_TO    reduce using rule 60 (factor -> STRING .)
    LESS_THAN       reduce using rule 60 (factor -> STRING .)
    GREATER_THAN    reduce using rule 60 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 60 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 60 (factor -> STRING .)
    IDENTICAL_TO    reduce using rule 60 (factor -> STRING .)
    NOT_IDENTICAL_TO reduce using rule 60 (factor -> STRING .)
    DIFFERENT       reduce using rule 60 (factor -> STRING .)

  ! DOT             [ reduce using rule 60 (factor -> STRING .) ]
  ! COMMA           [ reduce using rule 60 (factor -> STRING .) ]
  ! SEMICOLON       [ reduce using rule 60 (factor -> STRING .) ]
  ! RIGHT_PAREN     [ reduce using rule 60 (factor -> STRING .) ]
  ! RIGHT_BRACKET   [ reduce using rule 60 (factor -> STRING .) ]


state 61

    (47) argument -> variable .
    (34) assignment_statement -> variable . assignment_operator argument
    (35) assignment_statement -> variable . PLUS_PLUS
    (36) assignment_statement -> variable . MINUS_MINUS
    (59) factor -> variable .
    (28) assignment_operator -> . EQUALS
    (29) assignment_operator -> . PLUS_EQUALS
    (30) assignment_operator -> . MINUS_EQUALS
    (31) assignment_operator -> . TIMES_EQUALS
    (32) assignment_operator -> . DIVIDE_EQUALS
    (33) assignment_operator -> . MOD_EQUALS

  ! reduce/reduce conflict for DOT resolved using rule 47 (argument -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 47 (argument -> variable .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 47 (argument -> variable .)
  ! reduce/reduce conflict for RIGHT_PAREN resolved using rule 47 (argument -> variable .)
  ! reduce/reduce conflict for RIGHT_BRACKET resolved using rule 47 (argument -> variable .)
    DOT             reduce using rule 47 (argument -> variable .)
    COMMA           reduce using rule 47 (argument -> variable .)
    SEMICOLON       reduce using rule 47 (argument -> variable .)
    RIGHT_PAREN     reduce using rule 47 (argument -> variable .)
    RIGHT_BRACKET   reduce using rule 47 (argument -> variable .)
    PLUS_PLUS       shift and go to state 68
    MINUS_MINUS     shift and go to state 69
    TIMES           reduce using rule 59 (factor -> variable .)
    DIVIDE          reduce using rule 59 (factor -> variable .)
    PLUS            reduce using rule 59 (factor -> variable .)
    MINUS           reduce using rule 59 (factor -> variable .)
    EQUAL_TO        reduce using rule 59 (factor -> variable .)
    NOT_EQUAL_TO    reduce using rule 59 (factor -> variable .)
    LESS_THAN       reduce using rule 59 (factor -> variable .)
    GREATER_THAN    reduce using rule 59 (factor -> variable .)
    LESS_EQUAL      reduce using rule 59 (factor -> variable .)
    GREATER_EQUAL   reduce using rule 59 (factor -> variable .)
    IDENTICAL_TO    reduce using rule 59 (factor -> variable .)
    NOT_IDENTICAL_TO reduce using rule 59 (factor -> variable .)
    DIFFERENT       reduce using rule 59 (factor -> variable .)
    EQUALS          shift and go to state 112
    PLUS_EQUALS     shift and go to state 71
    MINUS_EQUALS    shift and go to state 72
    TIMES_EQUALS    shift and go to state 73
    DIVIDE_EQUALS   shift and go to state 74
    MOD_EQUALS      shift and go to state 75

  ! DOT             [ reduce using rule 59 (factor -> variable .) ]
  ! COMMA           [ reduce using rule 59 (factor -> variable .) ]
  ! SEMICOLON       [ reduce using rule 59 (factor -> variable .) ]
  ! RIGHT_PAREN     [ reduce using rule 59 (factor -> variable .) ]
  ! RIGHT_BRACKET   [ reduce using rule 59 (factor -> variable .) ]

    assignment_operator            shift and go to state 67

state 62

    (48) argument -> expression .
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (81) condition -> expression . relational_operator expression
    (85) relational_operator -> . EQUAL_TO
    (86) relational_operator -> . NOT_EQUAL_TO
    (87) relational_operator -> . LESS_THAN
    (88) relational_operator -> . GREATER_THAN
    (89) relational_operator -> . LESS_EQUAL
    (90) relational_operator -> . GREATER_EQUAL
    (91) relational_operator -> . IDENTICAL_TO
    (92) relational_operator -> . NOT_IDENTICAL_TO
    (93) relational_operator -> . DIFFERENT

    DOT             reduce using rule 48 (argument -> expression .)
    COMMA           reduce using rule 48 (argument -> expression .)
    SEMICOLON       reduce using rule 48 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 48 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 48 (argument -> expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    EQUAL_TO        shift and go to state 87
    NOT_EQUAL_TO    shift and go to state 88
    LESS_THAN       shift and go to state 89
    GREATER_THAN    shift and go to state 90
    LESS_EQUAL      shift and go to state 91
    GREATER_EQUAL   shift and go to state 92
    IDENTICAL_TO    shift and go to state 93
    NOT_IDENTICAL_TO shift and go to state 94
    DIFFERENT       shift and go to state 95

    relational_operator            shift and go to state 84

state 63

    (49) argument -> condition .
    (82) condition -> condition . logical_operator condition
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

    DOT             reduce using rule 49 (argument -> condition .)
    COMMA           reduce using rule 49 (argument -> condition .)
    SEMICOLON       reduce using rule 49 (argument -> condition .)
    RIGHT_PAREN     reduce using rule 49 (argument -> condition .)
    RIGHT_BRACKET   reduce using rule 49 (argument -> condition .)
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

    logical_operator               shift and go to state 80

state 64

    (50) argument -> assignment_statement .

    DOT             reduce using rule 50 (argument -> assignment_statement .)
    COMMA           reduce using rule 50 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 50 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 50 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 50 (argument -> assignment_statement .)


state 65

    (24) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 113


state 66

    (23) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 114


state 67

    (34) assignment_statement -> variable assignment_operator . argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    variable                       shift and go to state 61
    argument                       shift and go to state 115
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 68

    (35) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 35 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 35 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 35 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 35 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 35 (assignment_statement -> variable PLUS_PLUS .)


state 69

    (36) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 36 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 36 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 36 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 36 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 36 (assignment_statement -> variable MINUS_MINUS .)


state 70

    (97) array_declaration_statement -> variable EQUALS . array
    (28) assignment_operator -> EQUALS .
    (98) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (99) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

    INTEGER         reduce using rule 28 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 28 (assignment_operator -> EQUALS .)
    STRING          reduce using rule 28 (assignment_operator -> EQUALS .)
    ID              reduce using rule 28 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 28 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 28 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 28 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 28 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 117
    LEFT_BRACKET    shift and go to state 118

    array                          shift and go to state 116

state 71

    (29) assignment_operator -> PLUS_EQUALS .

    INTEGER         reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    STRING          reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 29 (assignment_operator -> PLUS_EQUALS .)


state 72

    (30) assignment_operator -> MINUS_EQUALS .

    INTEGER         reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    STRING          reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 30 (assignment_operator -> MINUS_EQUALS .)


state 73

    (31) assignment_operator -> TIMES_EQUALS .

    INTEGER         reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    STRING          reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 31 (assignment_operator -> TIMES_EQUALS .)


state 74

    (32) assignment_operator -> DIVIDE_EQUALS .

    INTEGER         reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    STRING          reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 32 (assignment_operator -> DIVIDE_EQUALS .)


state 75

    (33) assignment_operator -> MOD_EQUALS .

    INTEGER         reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    STRING          reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 33 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 33 (assignment_operator -> MOD_EQUALS .)


state 76

    (65) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (66) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (73) assignment_list -> . assignment_statement
    (74) assignment_list -> . assignment_list COMMA assignment_statement
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (27) variable -> . ID

    SEMICOLON       shift and go to state 120
    ID              shift and go to state 32

    assignment_list                shift and go to state 119
    assignment_statement           shift and go to state 121
    variable                       shift and go to state 122

state 77

    (62) if_statement -> IF LEFT_PAREN condition . RIGHT_PAREN block
    (63) if_statement -> IF LEFT_PAREN condition . RIGHT_PAREN block ELSE block
    (82) condition -> condition . logical_operator condition
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

    RIGHT_PAREN     shift and go to state 123
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

    logical_operator               shift and go to state 80

state 78

    (64) while_statement -> WHILE LEFT_PAREN condition . RIGHT_PAREN block
    (82) condition -> condition . logical_operator condition
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

    RIGHT_PAREN     shift and go to state 124
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

    logical_operator               shift and go to state 80

state 79

    (67) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    RETURN          reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    FUNCTION        reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 67 (for_statement -> for_part1 condition for_part3 .)


state 80

    (82) condition -> condition logical_operator . condition
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    ID              shift and go to state 32

    condition                      shift and go to state 125
    expression                     shift and go to state 42
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 81

    (94) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    STRING          reduce using rule 94 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 94 (logical_operator -> LOGICAL_AND .)


state 82

    (95) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    STRING          reduce using rule 95 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 95 (logical_operator -> LOGICAL_OR .)


state 83

    (96) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    STRING          reduce using rule 96 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 96 (logical_operator -> LOGICAL_XOR .)


state 84

    (81) condition -> expression relational_operator . expression
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32

    expression                     shift and go to state 126
    term                           shift and go to state 46
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 85

    (51) expression -> expression PLUS . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32

    term                           shift and go to state 127
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 86

    (52) expression -> expression MINUS . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32

    term                           shift and go to state 128
    factor                         shift and go to state 47
    variable                       shift and go to state 50

state 87

    (85) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 85 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 85 (relational_operator -> EQUAL_TO .)
    STRING          reduce using rule 85 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 85 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 85 (relational_operator -> EQUAL_TO .)


state 88

    (86) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 86 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 86 (relational_operator -> NOT_EQUAL_TO .)
    STRING          reduce using rule 86 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 86 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 86 (relational_operator -> NOT_EQUAL_TO .)


state 89

    (87) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 87 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 87 (relational_operator -> LESS_THAN .)
    STRING          reduce using rule 87 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 87 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 87 (relational_operator -> LESS_THAN .)


state 90

    (88) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 88 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 88 (relational_operator -> GREATER_THAN .)
    STRING          reduce using rule 88 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 88 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 88 (relational_operator -> GREATER_THAN .)


state 91

    (89) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 89 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 89 (relational_operator -> LESS_EQUAL .)
    STRING          reduce using rule 89 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 89 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 89 (relational_operator -> LESS_EQUAL .)


state 92

    (90) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 90 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 90 (relational_operator -> GREATER_EQUAL .)
    STRING          reduce using rule 90 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 90 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 90 (relational_operator -> GREATER_EQUAL .)


state 93

    (91) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 91 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 91 (relational_operator -> IDENTICAL_TO .)
    STRING          reduce using rule 91 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 91 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 91 (relational_operator -> IDENTICAL_TO .)


state 94

    (92) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 92 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 92 (relational_operator -> NOT_IDENTICAL_TO .)
    STRING          reduce using rule 92 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 92 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 92 (relational_operator -> NOT_IDENTICAL_TO .)


state 95

    (93) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 93 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 93 (relational_operator -> DIFFERENT .)
    STRING          reduce using rule 93 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 93 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 93 (relational_operator -> DIFFERENT .)


state 96

    (83) condition -> LOGICAL_NOT condition .
    (82) condition -> condition . logical_operator condition
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 83 (condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 83 (condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 83 (condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 83 (condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 83 (condition -> LOGICAL_NOT condition .)
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

  ! LOGICAL_AND     [ reduce using rule 83 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 83 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 83 (condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 80

state 97

    (84) condition -> LEFT_PAREN condition . RIGHT_PAREN
    (82) condition -> condition . logical_operator condition
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

    RIGHT_PAREN     shift and go to state 129
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

    logical_operator               shift and go to state 80

state 98

    (61) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (81) condition -> expression . relational_operator expression
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (85) relational_operator -> . EQUAL_TO
    (86) relational_operator -> . NOT_EQUAL_TO
    (87) relational_operator -> . LESS_THAN
    (88) relational_operator -> . GREATER_THAN
    (89) relational_operator -> . LESS_EQUAL
    (90) relational_operator -> . GREATER_EQUAL
    (91) relational_operator -> . IDENTICAL_TO
    (92) relational_operator -> . NOT_IDENTICAL_TO
    (93) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 130
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    EQUAL_TO        shift and go to state 87
    NOT_EQUAL_TO    shift and go to state 88
    LESS_THAN       shift and go to state 89
    GREATER_THAN    shift and go to state 90
    LESS_EQUAL      shift and go to state 91
    GREATER_EQUAL   shift and go to state 92
    IDENTICAL_TO    shift and go to state 93
    NOT_IDENTICAL_TO shift and go to state 94
    DIFFERENT       shift and go to state 95

    relational_operator            shift and go to state 84

state 99

    (69) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (76) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 131
    COMMA           shift and go to state 132


state 100

    (70) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (71) for_part4 -> . block
    (72) for_part4 -> . SEMICOLON
    (77) block -> . LEFT_BRACE statements RIGHT_BRACE
    (78) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 133
    LEFT_BRACE      shift and go to state 136

    for_part4                      shift and go to state 134
    block                          shift and go to state 135

state 101

    (75) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 75 (statement_list -> statement .)
    COMMA           reduce using rule 75 (statement_list -> statement .)


state 102

    (54) term -> term TIMES . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32

    factor                         shift and go to state 137
    variable                       shift and go to state 50

state 103

    (55) term -> term DIVIDE . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (27) variable -> . ID

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 51
    LEFT_PAREN      shift and go to state 53
    ID              shift and go to state 32

    factor                         shift and go to state 138
    variable                       shift and go to state 50

state 104

    (22) statement_return -> RETURN expression SEMICOLON .

    CLOSE_TAG       reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    IF              reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    FUNCTION        reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    FSCANF          reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    FGETS           reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    ECHO            reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    ID              reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 22 (statement_return -> RETURN expression SEMICOLON .)


state 105

    (61) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 130
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86


state 106

    (19) function_statement -> FUNCTION NAME LEFT_PAREN . arguments RIGHT_PAREN block
    (41) arguments -> . argument
    (42) arguments -> . arguments DOT argument
    (43) arguments -> . arguments COMMA argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    arguments                      shift and go to state 139
    argument                       shift and go to state 57
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 107

    (37) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (42) arguments -> arguments . DOT argument
    (43) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 140
    DOT             shift and go to state 110
    COMMA           shift and go to state 111


state 108

    (84) condition -> LEFT_PAREN condition . RIGHT_PAREN
    (82) condition -> condition . logical_operator condition
    (49) argument -> condition .
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 129
    DOT             reduce using rule 49 (argument -> condition .)
    COMMA           reduce using rule 49 (argument -> condition .)
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

  ! RIGHT_PAREN     [ reduce using rule 49 (argument -> condition .) ]

    logical_operator               shift and go to state 80

state 109

    (61) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (81) condition -> expression . relational_operator expression
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term
    (48) argument -> expression .
    (85) relational_operator -> . EQUAL_TO
    (86) relational_operator -> . NOT_EQUAL_TO
    (87) relational_operator -> . LESS_THAN
    (88) relational_operator -> . GREATER_THAN
    (89) relational_operator -> . LESS_EQUAL
    (90) relational_operator -> . GREATER_EQUAL
    (91) relational_operator -> . IDENTICAL_TO
    (92) relational_operator -> . NOT_IDENTICAL_TO
    (93) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 130
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    DOT             reduce using rule 48 (argument -> expression .)
    COMMA           reduce using rule 48 (argument -> expression .)
    EQUAL_TO        shift and go to state 87
    NOT_EQUAL_TO    shift and go to state 88
    LESS_THAN       shift and go to state 89
    GREATER_THAN    shift and go to state 90
    LESS_EQUAL      shift and go to state 91
    GREATER_EQUAL   shift and go to state 92
    IDENTICAL_TO    shift and go to state 93
    NOT_IDENTICAL_TO shift and go to state 94
    DIFFERENT       shift and go to state 95

  ! RIGHT_PAREN     [ reduce using rule 48 (argument -> expression .) ]

    relational_operator            shift and go to state 84

state 110

    (42) arguments -> arguments DOT . argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    argument                       shift and go to state 141
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 111

    (43) arguments -> arguments COMMA . argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    argument                       shift and go to state 142
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 112

    (28) assignment_operator -> EQUALS .

    INTEGER         reduce using rule 28 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 28 (assignment_operator -> EQUALS .)
    STRING          reduce using rule 28 (assignment_operator -> EQUALS .)
    ID              reduce using rule 28 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 28 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 28 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 28 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 28 (assignment_operator -> EQUALS .)


state 113

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 143


state 114

    (23) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 144


state 115

    (34) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 34 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 34 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 34 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 34 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 34 (assignment_statement -> variable assignment_operator argument .)


state 116

    (97) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 97 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 97 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 97 (array_declaration_statement -> variable EQUALS array .)


state 117

    (98) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 145


state 118

    (99) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (100) array_elements -> . argument
    (101) array_elements -> . array_elements COMMA argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    array_elements                 shift and go to state 146
    argument                       shift and go to state 147
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 119

    (65) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (74) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 148
    COMMA           shift and go to state 149


state 120

    (66) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    TRUE            reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    STRING          reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 66 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 121

    (73) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 73 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 73 (assignment_list -> assignment_statement .)

>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

state 44

<<<<<<< HEAD
    (81) simple_condition -> TRUE .

    SEMICOLON       reduce using rule 81 (simple_condition -> TRUE .)
    LOGICAL_AND     reduce using rule 81 (simple_condition -> TRUE .)
    LOGICAL_OR      reduce using rule 81 (simple_condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 81 (simple_condition -> TRUE .)
    TIMES           reduce using rule 81 (simple_condition -> TRUE .)
    DIVIDE          reduce using rule 81 (simple_condition -> TRUE .)
    PLUS            reduce using rule 81 (simple_condition -> TRUE .)
    MINUS           reduce using rule 81 (simple_condition -> TRUE .)
    EQUAL_TO        reduce using rule 81 (simple_condition -> TRUE .)
    NOT_EQUAL_TO    reduce using rule 81 (simple_condition -> TRUE .)
    LESS_THAN       reduce using rule 81 (simple_condition -> TRUE .)
    GREATER_THAN    reduce using rule 81 (simple_condition -> TRUE .)
    LESS_EQUAL      reduce using rule 81 (simple_condition -> TRUE .)
    GREATER_EQUAL   reduce using rule 81 (simple_condition -> TRUE .)
    IDENTICAL_TO    reduce using rule 81 (simple_condition -> TRUE .)
    NOT_IDENTICAL_TO reduce using rule 81 (simple_condition -> TRUE .)
    DIFFERENT       reduce using rule 81 (simple_condition -> TRUE .)
    DOT             reduce using rule 81 (simple_condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 81 (simple_condition -> TRUE .)
    COMMA           reduce using rule 81 (simple_condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 81 (simple_condition -> TRUE .)
=======
    (34) assignment_statement -> variable . assignment_operator argument
    (35) assignment_statement -> variable . PLUS_PLUS
    (36) assignment_statement -> variable . MINUS_MINUS
    (28) assignment_operator -> . EQUALS
    (29) assignment_operator -> . PLUS_EQUALS
    (30) assignment_operator -> . MINUS_EQUALS
    (31) assignment_operator -> . TIMES_EQUALS
    (32) assignment_operator -> . DIVIDE_EQUALS
    (33) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 68
    MINUS_MINUS     shift and go to state 69
    EQUALS          shift and go to state 112
    PLUS_EQUALS     shift and go to state 71
    MINUS_EQUALS    shift and go to state 72
    TIMES_EQUALS    shift and go to state 73
    DIVIDE_EQUALS   shift and go to state 74
    MOD_EQUALS      shift and go to state 75
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    assignment_operator            shift and go to state 67

state 45

<<<<<<< HEAD
    (82) simple_condition -> FALSE .

    SEMICOLON       reduce using rule 82 (simple_condition -> FALSE .)
    LOGICAL_AND     reduce using rule 82 (simple_condition -> FALSE .)
    LOGICAL_OR      reduce using rule 82 (simple_condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 82 (simple_condition -> FALSE .)
    TIMES           reduce using rule 82 (simple_condition -> FALSE .)
    DIVIDE          reduce using rule 82 (simple_condition -> FALSE .)
    PLUS            reduce using rule 82 (simple_condition -> FALSE .)
    MINUS           reduce using rule 82 (simple_condition -> FALSE .)
    EQUAL_TO        reduce using rule 82 (simple_condition -> FALSE .)
    NOT_EQUAL_TO    reduce using rule 82 (simple_condition -> FALSE .)
    LESS_THAN       reduce using rule 82 (simple_condition -> FALSE .)
    GREATER_THAN    reduce using rule 82 (simple_condition -> FALSE .)
    LESS_EQUAL      reduce using rule 82 (simple_condition -> FALSE .)
    GREATER_EQUAL   reduce using rule 82 (simple_condition -> FALSE .)
    IDENTICAL_TO    reduce using rule 82 (simple_condition -> FALSE .)
    NOT_IDENTICAL_TO reduce using rule 82 (simple_condition -> FALSE .)
    DIFFERENT       reduce using rule 82 (simple_condition -> FALSE .)
    DOT             reduce using rule 82 (simple_condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 82 (simple_condition -> FALSE .)
    COMMA           reduce using rule 82 (simple_condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 82 (simple_condition -> FALSE .)
=======
    (62) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN . block
    (63) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN . block ELSE block
    (77) block -> . LEFT_BRACE statements RIGHT_BRACE
    (78) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 136
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    block                          shift and go to state 150

state 46

<<<<<<< HEAD
    (83) simple_condition -> variable .

    SEMICOLON       reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 83 (simple_condition -> variable .)
    TIMES           reduce using rule 83 (simple_condition -> variable .)
    DIVIDE          reduce using rule 83 (simple_condition -> variable .)
    PLUS            reduce using rule 83 (simple_condition -> variable .)
    MINUS           reduce using rule 83 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 83 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 83 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 83 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 83 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 83 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 83 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 83 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 83 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 83 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 83 (simple_condition -> variable .)
    DOT             reduce using rule 83 (simple_condition -> variable .)
    COMMA           reduce using rule 83 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 83 (simple_condition -> variable .)
=======
    (64) while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN . block
    (77) block -> . LEFT_BRACE statements RIGHT_BRACE
    (78) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 136
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    block                          shift and go to state 151

state 47

<<<<<<< HEAD
    (84) simple_condition -> relational_expression .

    SEMICOLON       reduce using rule 84 (simple_condition -> relational_expression .)
    LOGICAL_AND     reduce using rule 84 (simple_condition -> relational_expression .)
    LOGICAL_OR      reduce using rule 84 (simple_condition -> relational_expression .)
    LOGICAL_XOR     reduce using rule 84 (simple_condition -> relational_expression .)
    TIMES           reduce using rule 84 (simple_condition -> relational_expression .)
    DIVIDE          reduce using rule 84 (simple_condition -> relational_expression .)
    PLUS            reduce using rule 84 (simple_condition -> relational_expression .)
    MINUS           reduce using rule 84 (simple_condition -> relational_expression .)
    EQUAL_TO        reduce using rule 84 (simple_condition -> relational_expression .)
    NOT_EQUAL_TO    reduce using rule 84 (simple_condition -> relational_expression .)
    LESS_THAN       reduce using rule 84 (simple_condition -> relational_expression .)
    GREATER_THAN    reduce using rule 84 (simple_condition -> relational_expression .)
    LESS_EQUAL      reduce using rule 84 (simple_condition -> relational_expression .)
    GREATER_EQUAL   reduce using rule 84 (simple_condition -> relational_expression .)
    IDENTICAL_TO    reduce using rule 84 (simple_condition -> relational_expression .)
    NOT_IDENTICAL_TO reduce using rule 84 (simple_condition -> relational_expression .)
    DIFFERENT       reduce using rule 84 (simple_condition -> relational_expression .)
    DOT             reduce using rule 84 (simple_condition -> relational_expression .)
    RIGHT_PAREN     reduce using rule 84 (simple_condition -> relational_expression .)
    COMMA           reduce using rule 84 (simple_condition -> relational_expression .)
    RIGHT_BRACKET   reduce using rule 84 (simple_condition -> relational_expression .)


state 48

    (85) negated_condition -> LOGICAL_NOT . condition
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54

    condition                      shift and go to state 92
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47
    expression                     shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52

state 49

    (87) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (54) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54

    condition                      shift and go to state 82
    expression                     shift and go to state 93
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    term                           shift and go to state 51
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47
    factor                         shift and go to state 52

state 50

    (88) relational_expression -> expression . relational_operator expression
    (45) expression -> expression . PLUS term
    (46) expression -> expression . MINUS term
    (89) relational_operator -> . EQUAL_TO
    (90) relational_operator -> . NOT_EQUAL_TO
    (91) relational_operator -> . LESS_THAN
    (92) relational_operator -> . GREATER_THAN
    (93) relational_operator -> . LESS_EQUAL
    (94) relational_operator -> . GREATER_EQUAL
    (95) relational_operator -> . IDENTICAL_TO
    (96) relational_operator -> . NOT_IDENTICAL_TO
    (97) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    EQUAL_TO        shift and go to state 97
    NOT_EQUAL_TO    shift and go to state 98
    LESS_THAN       shift and go to state 99
    GREATER_THAN    shift and go to state 100
    LESS_EQUAL      shift and go to state 101
    GREATER_EQUAL   shift and go to state 102
    IDENTICAL_TO    shift and go to state 103
    NOT_IDENTICAL_TO shift and go to state 104
    DIFFERENT       shift and go to state 105

    relational_operator            shift and go to state 94

state 51

    (47) expression -> term .
    (48) term -> term . TIMES factor
    (49) term -> term . DIVIDE factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 47 (expression -> term .)
    MINUS           reduce using rule 47 (expression -> term .)
    EQUAL_TO        reduce using rule 47 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 47 (expression -> term .)
    LESS_THAN       reduce using rule 47 (expression -> term .)
    GREATER_THAN    reduce using rule 47 (expression -> term .)
    LESS_EQUAL      reduce using rule 47 (expression -> term .)
    GREATER_EQUAL   reduce using rule 47 (expression -> term .)
    IDENTICAL_TO    reduce using rule 47 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 47 (expression -> term .)
    DIFFERENT       reduce using rule 47 (expression -> term .)
    DOT             reduce using rule 47 (expression -> term .)
    SEMICOLON       reduce using rule 47 (expression -> term .)
    RIGHT_PAREN     reduce using rule 47 (expression -> term .)
    COMMA           reduce using rule 47 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 47 (expression -> term .)
    LOGICAL_AND     reduce using rule 47 (expression -> term .)
    LOGICAL_OR      reduce using rule 47 (expression -> term .)
    LOGICAL_XOR     reduce using rule 47 (expression -> term .)
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107

  ! TIMES           [ reduce using rule 47 (expression -> term .) ]
  ! DIVIDE          [ reduce using rule 47 (expression -> term .) ]


state 52

    (50) term -> factor .

    TIMES           reduce using rule 50 (term -> factor .)
    DIVIDE          reduce using rule 50 (term -> factor .)
    PLUS            reduce using rule 50 (term -> factor .)
    MINUS           reduce using rule 50 (term -> factor .)
    EQUAL_TO        reduce using rule 50 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 50 (term -> factor .)
    LESS_THAN       reduce using rule 50 (term -> factor .)
    GREATER_THAN    reduce using rule 50 (term -> factor .)
    LESS_EQUAL      reduce using rule 50 (term -> factor .)
    GREATER_EQUAL   reduce using rule 50 (term -> factor .)
    IDENTICAL_TO    reduce using rule 50 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 50 (term -> factor .)
    DIFFERENT       reduce using rule 50 (term -> factor .)
    DOT             reduce using rule 50 (term -> factor .)
    SEMICOLON       reduce using rule 50 (term -> factor .)
    RIGHT_PAREN     reduce using rule 50 (term -> factor .)
    COMMA           reduce using rule 50 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 50 (term -> factor .)
    LOGICAL_AND     reduce using rule 50 (term -> factor .)
    LOGICAL_OR      reduce using rule 50 (term -> factor .)
    LOGICAL_XOR     reduce using rule 50 (term -> factor .)


state 53

    (51) factor -> INTEGER .

    TIMES           reduce using rule 51 (factor -> INTEGER .)
    DIVIDE          reduce using rule 51 (factor -> INTEGER .)
    PLUS            reduce using rule 51 (factor -> INTEGER .)
    MINUS           reduce using rule 51 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 51 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 51 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 51 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 51 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 51 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 51 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 51 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 51 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 51 (factor -> INTEGER .)
    DOT             reduce using rule 51 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 51 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 51 (factor -> INTEGER .)
    COMMA           reduce using rule 51 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 51 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 51 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 51 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 51 (factor -> INTEGER .)


state 54

    (52) factor -> FLOAT .

    TIMES           reduce using rule 52 (factor -> FLOAT .)
    DIVIDE          reduce using rule 52 (factor -> FLOAT .)
    PLUS            reduce using rule 52 (factor -> FLOAT .)
    MINUS           reduce using rule 52 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 52 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 52 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 52 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 52 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 52 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 52 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 52 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 52 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 52 (factor -> FLOAT .)
    DOT             reduce using rule 52 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 52 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 52 (factor -> FLOAT .)
    COMMA           reduce using rule 52 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 52 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 52 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 52 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 52 (factor -> FLOAT .)


state 55

    (32) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (101) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (54) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (87) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (36) arguments -> . argument
    (37) arguments -> . arguments DOT argument
    (102) casting_type -> . INT_TYPE
    (103) casting_type -> . FLOAT_TYPE
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 112
    FLOAT_TYPE      shift and go to state 113
    STRING          shift and go to state 58
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 108
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    ID              shift and go to state 30

    arguments                      shift and go to state 109
    casting_type                   shift and go to state 110
    expression                     shift and go to state 111
    condition                      shift and go to state 82
    argument                       shift and go to state 57
    term                           shift and go to state 51
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    factor                         shift and go to state 52
    variable                       shift and go to state 114
    relational_expression          shift and go to state 47

state 56

    (33) print_statement -> print_function arguments .
    (37) arguments -> arguments . DOT argument

    SEMICOLON       reduce using rule 33 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 33 (print_statement -> print_function arguments .)
    COMMA           reduce using rule 33 (print_statement -> print_function arguments .)
    DOT             shift and go to state 115


state 57

    (36) arguments -> argument .

    DOT             reduce using rule 36 (arguments -> argument .)
    SEMICOLON       reduce using rule 36 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 36 (arguments -> argument .)
    COMMA           reduce using rule 36 (arguments -> argument .)


state 58

    (38) argument -> STRING .

    DOT             reduce using rule 38 (argument -> STRING .)
    SEMICOLON       reduce using rule 38 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 38 (argument -> STRING .)
    COMMA           reduce using rule 38 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 38 (argument -> STRING .)


state 59

    (39) argument -> expression .
    (45) expression -> expression . PLUS term
    (46) expression -> expression . MINUS term
    (88) relational_expression -> expression . relational_operator expression
    (89) relational_operator -> . EQUAL_TO
    (90) relational_operator -> . NOT_EQUAL_TO
    (91) relational_operator -> . LESS_THAN
    (92) relational_operator -> . GREATER_THAN
    (93) relational_operator -> . LESS_EQUAL
    (94) relational_operator -> . GREATER_EQUAL
    (95) relational_operator -> . IDENTICAL_TO
    (96) relational_operator -> . NOT_IDENTICAL_TO
    (97) relational_operator -> . DIFFERENT

    DOT             reduce using rule 39 (argument -> expression .)
    SEMICOLON       reduce using rule 39 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 39 (argument -> expression .)
    COMMA           reduce using rule 39 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 39 (argument -> expression .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    EQUAL_TO        shift and go to state 97
    NOT_EQUAL_TO    shift and go to state 98
    LESS_THAN       shift and go to state 99
    GREATER_THAN    shift and go to state 100
    LESS_EQUAL      shift and go to state 101
    GREATER_EQUAL   shift and go to state 102
    IDENTICAL_TO    shift and go to state 103
    NOT_IDENTICAL_TO shift and go to state 104
    DIFFERENT       shift and go to state 105

    relational_operator            shift and go to state 94

state 60

    (40) argument -> assignment_statement .

    DOT             reduce using rule 40 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 40 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 40 (argument -> assignment_statement .)
    COMMA           reduce using rule 40 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 40 (argument -> assignment_statement .)


state 61

    (41) argument -> function_call .

    DOT             reduce using rule 41 (argument -> function_call .)
    SEMICOLON       reduce using rule 41 (argument -> function_call .)
    RIGHT_PAREN     reduce using rule 41 (argument -> function_call .)
    COMMA           reduce using rule 41 (argument -> function_call .)
    RIGHT_BRACKET   reduce using rule 41 (argument -> function_call .)


state 62

    (42) argument -> fgets_statement .

    DOT             reduce using rule 42 (argument -> fgets_statement .)
    SEMICOLON       reduce using rule 42 (argument -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 42 (argument -> fgets_statement .)
    COMMA           reduce using rule 42 (argument -> fgets_statement .)
    RIGHT_BRACKET   reduce using rule 42 (argument -> fgets_statement .)


state 63

    (43) argument -> array_indexing .

    DOT             reduce using rule 43 (argument -> array_indexing .)
    SEMICOLON       reduce using rule 43 (argument -> array_indexing .)
    RIGHT_PAREN     reduce using rule 43 (argument -> array_indexing .)
    COMMA           reduce using rule 43 (argument -> array_indexing .)
    RIGHT_BRACKET   reduce using rule 43 (argument -> array_indexing .)


state 64

    (44) argument -> casting . argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    casting                        shift and go to state 64
    argument                       shift and go to state 116
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 65

    (23) assignment_statement -> variable . assignment_operator argument
    (24) assignment_statement -> variable . PLUS_PLUS
    (25) assignment_statement -> variable . MINUS_MINUS
    (110) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (83) simple_condition -> variable .
    (26) assignment_operator -> . EQUALS
    (27) assignment_operator -> . PLUS_EQUALS
    (28) assignment_operator -> . MINUS_EQUALS
    (29) assignment_operator -> . TIMES_EQUALS
    (30) assignment_operator -> . DIVIDE_EQUALS
    (31) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 70
    MINUS_MINUS     shift and go to state 71
    LEFT_BRACKET    shift and go to state 118
    LOGICAL_AND     reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 83 (simple_condition -> variable .)
    TIMES           reduce using rule 83 (simple_condition -> variable .)
    DIVIDE          reduce using rule 83 (simple_condition -> variable .)
    PLUS            reduce using rule 83 (simple_condition -> variable .)
    MINUS           reduce using rule 83 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 83 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 83 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 83 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 83 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 83 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 83 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 83 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 83 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 83 (simple_condition -> variable .)
    DOT             reduce using rule 83 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 83 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 83 (simple_condition -> variable .)
    COMMA           reduce using rule 83 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 83 (simple_condition -> variable .)
    EQUALS          shift and go to state 119
    PLUS_EQUALS     shift and go to state 73
    MINUS_EQUALS    shift and go to state 74
    TIMES_EQUALS    shift and go to state 75
    DIVIDE_EQUALS   shift and go to state 76
    MOD_EQUALS      shift and go to state 77

    assignment_operator            shift and go to state 69

state 66

    (53) factor -> condition .
    (86) complex_condition -> condition . logical_operator condition
    (98) logical_operator -> . LOGICAL_AND
    (99) logical_operator -> . LOGICAL_OR
    (100) logical_operator -> . LOGICAL_XOR
=======
    (82) condition -> condition logical_operator condition .
    (82) condition -> condition . logical_operator condition
    (94) logical_operator -> . LOGICAL_AND
    (95) logical_operator -> . LOGICAL_OR
    (96) logical_operator -> . LOGICAL_XOR
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
<<<<<<< HEAD
    TIMES           reduce using rule 53 (factor -> condition .)
    DIVIDE          reduce using rule 53 (factor -> condition .)
    PLUS            reduce using rule 53 (factor -> condition .)
    MINUS           reduce using rule 53 (factor -> condition .)
    EQUAL_TO        reduce using rule 53 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 53 (factor -> condition .)
    LESS_THAN       reduce using rule 53 (factor -> condition .)
    GREATER_THAN    reduce using rule 53 (factor -> condition .)
    LESS_EQUAL      reduce using rule 53 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 53 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 53 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 53 (factor -> condition .)
    DIFFERENT       reduce using rule 53 (factor -> condition .)
    DOT             reduce using rule 53 (factor -> condition .)
    SEMICOLON       reduce using rule 53 (factor -> condition .)
    RIGHT_PAREN     reduce using rule 53 (factor -> condition .)
    COMMA           reduce using rule 53 (factor -> condition .)
    RIGHT_BRACKET   reduce using rule 53 (factor -> condition .)
    LOGICAL_AND     shift and go to state 86
    LOGICAL_OR      shift and go to state 87
    LOGICAL_XOR     shift and go to state 88

  ! LOGICAL_AND     [ reduce using rule 53 (factor -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 53 (factor -> condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 53 (factor -> condition .) ]

    logical_operator               shift and go to state 85

state 67

    (19) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 120


state 68

    (18) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 121


state 69

    (23) assignment_statement -> variable assignment_operator . argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    variable                       shift and go to state 65
    argument                       shift and go to state 122
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 70

    (24) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 24 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 24 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 24 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 24 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 24 (assignment_statement -> variable PLUS_PLUS .)


state 71

    (25) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 25 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 25 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 25 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 25 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 25 (assignment_statement -> variable MINUS_MINUS .)


state 72

    (105) array_declaration_statement -> variable EQUALS . array
    (26) assignment_operator -> EQUALS .
    (106) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (107) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

    STRING          reduce using rule 26 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 26 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 26 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 26 (assignment_operator -> EQUALS .)
    ID              reduce using rule 26 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 26 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 26 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 26 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 26 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 26 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 124
    LEFT_BRACKET    shift and go to state 125

    array                          shift and go to state 123

state 73

    (27) assignment_operator -> PLUS_EQUALS .

    STRING          reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    NAME            reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    FGETS           reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    INTEGER         reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 27 (assignment_operator -> PLUS_EQUALS .)


state 74

    (28) assignment_operator -> MINUS_EQUALS .

    STRING          reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    NAME            reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    FGETS           reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    INTEGER         reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 28 (assignment_operator -> MINUS_EQUALS .)


state 75

    (29) assignment_operator -> TIMES_EQUALS .

    STRING          reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    NAME            reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    FGETS           reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    INTEGER         reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 29 (assignment_operator -> TIMES_EQUALS .)


state 76

    (30) assignment_operator -> DIVIDE_EQUALS .

    STRING          reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    NAME            reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    FGETS           reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    INTEGER         reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 30 (assignment_operator -> DIVIDE_EQUALS .)


state 77

    (31) assignment_operator -> MOD_EQUALS .

    STRING          reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    NAME            reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    FGETS           reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    INTEGER         reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 31 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 31 (assignment_operator -> MOD_EQUALS .)


state 78

    (104) function_call -> NAME LEFT_PAREN . array_elements RIGHT_PAREN
    (108) array_elements -> . argument
    (109) array_elements -> . array_elements COMMA argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    array_elements                 shift and go to state 126
    argument                       shift and go to state 127
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 79

    (63) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (64) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (71) assignment_list -> . assignment_statement
    (72) assignment_list -> . assignment_list COMMA assignment_statement
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (22) variable -> . ID

    SEMICOLON       shift and go to state 129
    ID              shift and go to state 30

    assignment_list                shift and go to state 128
    assignment_statement           shift and go to state 130
    variable                       shift and go to state 131

state 80

    (55) if_statement -> IF parenthesized_condition block . else_if_extended if_part3
    (56) else_if_extended -> . if_part2
    (57) else_if_extended -> . else_if_extended if_part2
    (58) if_part2 -> . ELSEIF parenthesized_condition block
    (59) if_part2 -> .

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSEIF          shift and go to state 134
    ELSE            reduce using rule 59 (if_part2 -> .)
    CLOSE_TAG       reduce using rule 59 (if_part2 -> .)
    ONE_LINE_COMMENT reduce using rule 59 (if_part2 -> .)
    MULTI_LINE_COMMENT reduce using rule 59 (if_part2 -> .)
    BREAK           reduce using rule 59 (if_part2 -> .)
    CONTINUE        reduce using rule 59 (if_part2 -> .)
    IF              reduce using rule 59 (if_part2 -> .)
    WHILE           reduce using rule 59 (if_part2 -> .)
    FSCANF          reduce using rule 59 (if_part2 -> .)
    FGETS           reduce using rule 59 (if_part2 -> .)
    NAME            reduce using rule 59 (if_part2 -> .)
    FOR             reduce using rule 59 (if_part2 -> .)
    PRINT           reduce using rule 59 (if_part2 -> .)
    ECHO            reduce using rule 59 (if_part2 -> .)
    ID              reduce using rule 59 (if_part2 -> .)
    RIGHT_BRACE     reduce using rule 59 (if_part2 -> .)

  ! ELSEIF          [ reduce using rule 59 (if_part2 -> .) ]

    else_if_extended               shift and go to state 132
    if_part2                       shift and go to state 133

state 81

    (75) block -> LEFT_BRACE . statements RIGHT_BRACE
    (76) block -> LEFT_BRACE . RIGHT_BRACE
=======
    SEMICOLON       reduce using rule 82 (condition -> condition logical_operator condition .)
    DOT             reduce using rule 82 (condition -> condition logical_operator condition .)
    COMMA           reduce using rule 82 (condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 82 (condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 82 (condition -> condition logical_operator condition .)
    LOGICAL_AND     shift and go to state 81
    LOGICAL_OR      shift and go to state 82
    LOGICAL_XOR     shift and go to state 83

  ! LOGICAL_AND     [ reduce using rule 82 (condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 82 (condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 82 (condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 80

state 126

    (81) condition -> expression relational_operator expression .
    (51) expression -> expression . PLUS term
    (52) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 81 (condition -> expression relational_operator expression .)
    LOGICAL_AND     reduce using rule 81 (condition -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 81 (condition -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 81 (condition -> expression relational_operator expression .)
    DOT             reduce using rule 81 (condition -> expression relational_operator expression .)
    COMMA           reduce using rule 81 (condition -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 81 (condition -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 81 (condition -> expression relational_operator expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86


state 127

    (51) expression -> expression PLUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

    PLUS            reduce using rule 51 (expression -> expression PLUS term .)
    MINUS           reduce using rule 51 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 51 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 51 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 51 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 51 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 51 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 51 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 51 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 51 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 51 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 51 (expression -> expression PLUS term .)
    DOT             reduce using rule 51 (expression -> expression PLUS term .)
    COMMA           reduce using rule 51 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 51 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 51 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 51 (expression -> expression PLUS term .)
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103


state 128

    (52) expression -> expression MINUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

    PLUS            reduce using rule 52 (expression -> expression MINUS term .)
    MINUS           reduce using rule 52 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 52 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 52 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 52 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 52 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 52 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 52 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 52 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 52 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 52 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 52 (expression -> expression MINUS term .)
    DOT             reduce using rule 52 (expression -> expression MINUS term .)
    COMMA           reduce using rule 52 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 52 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 52 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 52 (expression -> expression MINUS term .)
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103


state 129

    (84) condition -> LEFT_PAREN condition RIGHT_PAREN .

    SEMICOLON       reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 84 (condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 130

    (61) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 61 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 131

    (69) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (71) for_part4 -> . block
    (72) for_part4 -> . SEMICOLON
    (77) block -> . LEFT_BRACE statements RIGHT_BRACE
    (78) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 133
    LEFT_BRACE      shift and go to state 136

    for_part4                      shift and go to state 152
    block                          shift and go to state 135

state 132

    (76) statement_list -> statement_list COMMA . statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (97) array_declaration_statement -> . variable EQUALS array
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 26
    FGETS           shift and go to state 27
    PRINT           shift and go to state 30
    ECHO            shift and go to state 31
    ID              shift and go to state 32

    statement                      shift and go to state 153
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    print_function                 shift and go to state 25
    variable                       shift and go to state 28

state 133

    (72) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 72 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 72 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 72 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 72 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 72 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 72 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 72 (for_part4 -> SEMICOLON .)
    RETURN          reduce using rule 72 (for_part4 -> SEMICOLON .)
    FUNCTION        reduce using rule 72 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 72 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 72 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 72 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 72 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 72 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 72 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 72 (for_part4 -> SEMICOLON .)


state 134

    (70) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 70 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 135

    (71) for_part4 -> block .

    CLOSE_TAG       reduce using rule 71 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 71 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 71 (for_part4 -> block .)
    BREAK           reduce using rule 71 (for_part4 -> block .)
    CONTINUE        reduce using rule 71 (for_part4 -> block .)
    IF              reduce using rule 71 (for_part4 -> block .)
    WHILE           reduce using rule 71 (for_part4 -> block .)
    RETURN          reduce using rule 71 (for_part4 -> block .)
    FUNCTION        reduce using rule 71 (for_part4 -> block .)
    FSCANF          reduce using rule 71 (for_part4 -> block .)
    FGETS           reduce using rule 71 (for_part4 -> block .)
    FOR             reduce using rule 71 (for_part4 -> block .)
    PRINT           reduce using rule 71 (for_part4 -> block .)
    ECHO            reduce using rule 71 (for_part4 -> block .)
    ID              reduce using rule 71 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 71 (for_part4 -> block .)


state 136

    (77) block -> LEFT_BRACE . statements RIGHT_BRACE
    (78) block -> LEFT_BRACE . RIGHT_BRACE
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
<<<<<<< HEAD
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (17) statement -> . function_call
    (55) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (62) while_statement -> . WHILE parenthesized_condition block
    (65) for_statement -> . for_part1 condition for_part3
    (66) for_statement -> . for_part1 for_part3
    (32) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> . print_function arguments
    (19) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (105) array_declaration_statement -> . variable EQUALS array
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (63) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (64) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (34) print_function -> . PRINT
    (35) print_function -> . ECHO
    (22) variable -> . ID

    RIGHT_BRACE     shift and go to state 136
    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    FSCANF          shift and go to state 23
    FGETS           shift and go to state 24
    NAME            shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    ECHO            shift and go to state 29
    ID              shift and go to state 30

    statements                     shift and go to state 135
=======
    (8) statement2 -> . statement_return
    (9) statement2 -> . function_statement
    (10) statement2 -> . ONE_LINE_COMMENT
    (11) statement2 -> . MULTI_LINE_COMMENT
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (62) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (63) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (64) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (67) for_statement -> . for_part1 condition for_part3
    (68) for_statement -> . for_part1 for_part3
    (22) statement_return -> . RETURN expression SEMICOLON
    (19) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (97) array_declaration_statement -> . variable EQUALS array
    (65) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (66) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    RIGHT_BRACE     shift and go to state 155
    ONE_LINE_COMMENT shift and go to state 11
    MULTI_LINE_COMMENT shift and go to state 12
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 23
    FUNCTION        shift and go to state 24
    FSCANF          shift and go to state 26
    FGETS           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    ECHO            shift and go to state 31
    ID              shift and go to state 32

    statements                     shift and go to state 154
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
<<<<<<< HEAD
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    function_call                  shift and go to state 18
    for_part1                      shift and go to state 21
    print_function                 shift and go to state 22
    variable                       shift and go to state 25

state 82

    (87) parenthesized_condition -> LEFT_PAREN condition . RIGHT_PAREN
    (86) complex_condition -> condition . logical_operator condition
    (53) factor -> condition .
    (98) logical_operator -> . LOGICAL_AND
    (99) logical_operator -> . LOGICAL_OR
    (100) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 137
    TIMES           reduce using rule 53 (factor -> condition .)
    DIVIDE          reduce using rule 53 (factor -> condition .)
    PLUS            reduce using rule 53 (factor -> condition .)
    MINUS           reduce using rule 53 (factor -> condition .)
    EQUAL_TO        reduce using rule 53 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 53 (factor -> condition .)
    LESS_THAN       reduce using rule 53 (factor -> condition .)
    GREATER_THAN    reduce using rule 53 (factor -> condition .)
    LESS_EQUAL      reduce using rule 53 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 53 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 53 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 53 (factor -> condition .)
    DIFFERENT       reduce using rule 53 (factor -> condition .)
    DOT             reduce using rule 53 (factor -> condition .)
    LOGICAL_AND     shift and go to state 86
    LOGICAL_OR      shift and go to state 87
    LOGICAL_XOR     shift and go to state 88

  ! RIGHT_PAREN     [ reduce using rule 53 (factor -> condition .) ]

    logical_operator               shift and go to state 85

state 83

    (62) while_statement -> WHILE parenthesized_condition block .

    CLOSE_TAG       reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    BREAK           reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    CONTINUE        reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    IF              reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    WHILE           reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    FSCANF          reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    FGETS           reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    NAME            reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    FOR             reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    PRINT           reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    ECHO            reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    ID              reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 62 (while_statement -> WHILE parenthesized_condition block .)


state 84

    (65) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    NAME            reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 65 (for_statement -> for_part1 condition for_part3 .)


state 85

    (86) complex_condition -> condition logical_operator . condition
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54

    condition                      shift and go to state 138
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47
    expression                     shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52

state 86

    (98) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 98 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 98 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 98 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 98 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 98 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 98 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 98 (logical_operator -> LOGICAL_AND .)


state 87

    (99) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 99 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 99 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 99 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 99 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 99 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 99 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 99 (logical_operator -> LOGICAL_OR .)


state 88

    (100) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 100 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 100 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 100 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 100 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 100 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 100 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 100 (logical_operator -> LOGICAL_XOR .)


state 89

    (67) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (74) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 139
    COMMA           shift and go to state 140


state 90

    (68) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (69) for_part4 -> . block
    (70) for_part4 -> . SEMICOLON
    (75) block -> . LEFT_BRACE statements RIGHT_BRACE
    (76) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 141
    LEFT_BRACE      shift and go to state 81

    for_part4                      shift and go to state 142
    block                          shift and go to state 143

state 91

    (73) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 73 (statement_list -> statement .)
    COMMA           reduce using rule 73 (statement_list -> statement .)


state 92

    (85) negated_condition -> LOGICAL_NOT condition .
    (86) complex_condition -> condition . logical_operator condition
    (53) factor -> condition .
    (98) logical_operator -> . LOGICAL_AND
    (99) logical_operator -> . LOGICAL_OR
    (100) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 53 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .)
    TIMES           reduce using rule 53 (factor -> condition .)
    DIVIDE          reduce using rule 53 (factor -> condition .)
    PLUS            reduce using rule 53 (factor -> condition .)
    MINUS           reduce using rule 53 (factor -> condition .)
    EQUAL_TO        reduce using rule 53 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 53 (factor -> condition .)
    LESS_THAN       reduce using rule 53 (factor -> condition .)
    GREATER_THAN    reduce using rule 53 (factor -> condition .)
    LESS_EQUAL      reduce using rule 53 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 53 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 53 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 53 (factor -> condition .)
    DIFFERENT       reduce using rule 53 (factor -> condition .)
    LOGICAL_AND     shift and go to state 86
    LOGICAL_OR      shift and go to state 87
    LOGICAL_XOR     shift and go to state 88

  ! LOGICAL_AND     [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! TIMES           [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIVIDE          [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! PLUS            [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MINUS           [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! EQUAL_TO        [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_THAN       [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_THAN    [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIFFERENT       [ reduce using rule 85 (negated_condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 85

state 93

    (54) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (45) expression -> expression . PLUS term
    (46) expression -> expression . MINUS term
    (88) relational_expression -> expression . relational_operator expression
    (89) relational_operator -> . EQUAL_TO
    (90) relational_operator -> . NOT_EQUAL_TO
    (91) relational_operator -> . LESS_THAN
    (92) relational_operator -> . GREATER_THAN
    (93) relational_operator -> . LESS_EQUAL
    (94) relational_operator -> . GREATER_EQUAL
    (95) relational_operator -> . IDENTICAL_TO
    (96) relational_operator -> . NOT_IDENTICAL_TO
    (97) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 144
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    EQUAL_TO        shift and go to state 97
    NOT_EQUAL_TO    shift and go to state 98
    LESS_THAN       shift and go to state 99
    GREATER_THAN    shift and go to state 100
    LESS_EQUAL      shift and go to state 101
    GREATER_EQUAL   shift and go to state 102
    IDENTICAL_TO    shift and go to state 103
    NOT_IDENTICAL_TO shift and go to state 104
    DIFFERENT       shift and go to state 105

    relational_operator            shift and go to state 94

state 94

    (88) relational_expression -> expression relational_operator . expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression

    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    LEFT_PAREN      shift and go to state 146
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    ID              shift and go to state 30

    expression                     shift and go to state 145
    term                           shift and go to state 51
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 95

    (45) expression -> expression PLUS . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term

    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    LEFT_PAREN      shift and go to state 146
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    ID              shift and go to state 30

    expression                     shift and go to state 50
    term                           shift and go to state 147
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 96

    (46) expression -> expression MINUS . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term

    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    LEFT_PAREN      shift and go to state 146
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    ID              shift and go to state 30

    expression                     shift and go to state 50
    term                           shift and go to state 148
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 97

    (89) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 89 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 89 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 89 (relational_operator -> EQUAL_TO .)
    TRUE            reduce using rule 89 (relational_operator -> EQUAL_TO .)
    FALSE           reduce using rule 89 (relational_operator -> EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 89 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 89 (relational_operator -> EQUAL_TO .)


state 98

    (90) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)
    TRUE            reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)
    FALSE           reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 90 (relational_operator -> NOT_EQUAL_TO .)


state 99

    (91) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 91 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 91 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 91 (relational_operator -> LESS_THAN .)
    TRUE            reduce using rule 91 (relational_operator -> LESS_THAN .)
    FALSE           reduce using rule 91 (relational_operator -> LESS_THAN .)
    LOGICAL_NOT     reduce using rule 91 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 91 (relational_operator -> LESS_THAN .)


state 100

    (92) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 92 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 92 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 92 (relational_operator -> GREATER_THAN .)
    TRUE            reduce using rule 92 (relational_operator -> GREATER_THAN .)
    FALSE           reduce using rule 92 (relational_operator -> GREATER_THAN .)
    LOGICAL_NOT     reduce using rule 92 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 92 (relational_operator -> GREATER_THAN .)


state 101

    (93) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 93 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 93 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 93 (relational_operator -> LESS_EQUAL .)
    TRUE            reduce using rule 93 (relational_operator -> LESS_EQUAL .)
    FALSE           reduce using rule 93 (relational_operator -> LESS_EQUAL .)
    LOGICAL_NOT     reduce using rule 93 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 93 (relational_operator -> LESS_EQUAL .)


state 102

    (94) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 94 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 94 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 94 (relational_operator -> GREATER_EQUAL .)
    TRUE            reduce using rule 94 (relational_operator -> GREATER_EQUAL .)
    FALSE           reduce using rule 94 (relational_operator -> GREATER_EQUAL .)
    LOGICAL_NOT     reduce using rule 94 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 94 (relational_operator -> GREATER_EQUAL .)


state 103

    (95) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 95 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 95 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 95 (relational_operator -> IDENTICAL_TO .)
    TRUE            reduce using rule 95 (relational_operator -> IDENTICAL_TO .)
    FALSE           reduce using rule 95 (relational_operator -> IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 95 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 95 (relational_operator -> IDENTICAL_TO .)


state 104

    (96) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)
    TRUE            reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)
    FALSE           reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 96 (relational_operator -> NOT_IDENTICAL_TO .)


state 105

    (97) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 97 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 97 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 97 (relational_operator -> DIFFERENT .)
    TRUE            reduce using rule 97 (relational_operator -> DIFFERENT .)
    FALSE           reduce using rule 97 (relational_operator -> DIFFERENT .)
    LOGICAL_NOT     reduce using rule 97 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 97 (relational_operator -> DIFFERENT .)


state 106

    (48) term -> term TIMES . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor

    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    LEFT_PAREN      shift and go to state 146
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    ID              shift and go to state 30

    term                           shift and go to state 51
    factor                         shift and go to state 149
    condition                      shift and go to state 66
    expression                     shift and go to state 50
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 107

    (49) term -> term DIVIDE . factor
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor

    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    LEFT_PAREN      shift and go to state 146
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    ID              shift and go to state 30

    term                           shift and go to state 51
    factor                         shift and go to state 150
    condition                      shift and go to state 66
    expression                     shift and go to state 50
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 108

    (87) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (101) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (54) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (102) casting_type -> . INT_TYPE
    (103) casting_type -> . FLOAT_TYPE
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INT_TYPE        shift and go to state 112
    FLOAT_TYPE      shift and go to state 113
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54

    condition                      shift and go to state 82
    casting_type                   shift and go to state 110
    expression                     shift and go to state 93
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    term                           shift and go to state 51
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47
    factor                         shift and go to state 52

state 109

    (32) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (37) arguments -> arguments . DOT argument

    RIGHT_PAREN     shift and go to state 151
    DOT             shift and go to state 115


state 110

    (101) casting -> LEFT_PAREN casting_type . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 152


state 111

    (54) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (45) expression -> expression . PLUS term
    (46) expression -> expression . MINUS term
    (39) argument -> expression .
    (88) relational_expression -> expression . relational_operator expression
    (89) relational_operator -> . EQUAL_TO
    (90) relational_operator -> . NOT_EQUAL_TO
    (91) relational_operator -> . LESS_THAN
    (92) relational_operator -> . GREATER_THAN
    (93) relational_operator -> . LESS_EQUAL
    (94) relational_operator -> . GREATER_EQUAL
    (95) relational_operator -> . IDENTICAL_TO
    (96) relational_operator -> . NOT_IDENTICAL_TO
    (97) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 144
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    DOT             reduce using rule 39 (argument -> expression .)
    EQUAL_TO        shift and go to state 97
    NOT_EQUAL_TO    shift and go to state 98
    LESS_THAN       shift and go to state 99
    GREATER_THAN    shift and go to state 100
    LESS_EQUAL      shift and go to state 101
    GREATER_EQUAL   shift and go to state 102
    IDENTICAL_TO    shift and go to state 103
    NOT_IDENTICAL_TO shift and go to state 104
    DIFFERENT       shift and go to state 105

  ! RIGHT_PAREN     [ reduce using rule 39 (argument -> expression .) ]

    relational_operator            shift and go to state 94

state 112

    (102) casting_type -> INT_TYPE .

    RIGHT_PAREN     reduce using rule 102 (casting_type -> INT_TYPE .)


state 113

    (103) casting_type -> FLOAT_TYPE .

    RIGHT_PAREN     reduce using rule 103 (casting_type -> FLOAT_TYPE .)


state 114

    (83) simple_condition -> variable .
    (23) assignment_statement -> variable . assignment_operator argument
    (24) assignment_statement -> variable . PLUS_PLUS
    (25) assignment_statement -> variable . MINUS_MINUS
    (110) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (26) assignment_operator -> . EQUALS
    (27) assignment_operator -> . PLUS_EQUALS
    (28) assignment_operator -> . MINUS_EQUALS
    (29) assignment_operator -> . TIMES_EQUALS
    (30) assignment_operator -> . DIVIDE_EQUALS
    (31) assignment_operator -> . MOD_EQUALS

    RIGHT_PAREN     reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 83 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 83 (simple_condition -> variable .)
    TIMES           reduce using rule 83 (simple_condition -> variable .)
    DIVIDE          reduce using rule 83 (simple_condition -> variable .)
    PLUS            reduce using rule 83 (simple_condition -> variable .)
    MINUS           reduce using rule 83 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 83 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 83 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 83 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 83 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 83 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 83 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 83 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 83 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 83 (simple_condition -> variable .)
    DOT             reduce using rule 83 (simple_condition -> variable .)
    PLUS_PLUS       shift and go to state 70
    MINUS_MINUS     shift and go to state 71
    LEFT_BRACKET    shift and go to state 118
    EQUALS          shift and go to state 119
    PLUS_EQUALS     shift and go to state 73
    MINUS_EQUALS    shift and go to state 74
    TIMES_EQUALS    shift and go to state 75
    DIVIDE_EQUALS   shift and go to state 76
    MOD_EQUALS      shift and go to state 77

    assignment_operator            shift and go to state 69

state 115

    (37) arguments -> arguments DOT . argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    argument                       shift and go to state 153
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 116

    (44) argument -> casting argument .

    DOT             reduce using rule 44 (argument -> casting argument .)
    SEMICOLON       reduce using rule 44 (argument -> casting argument .)
    RIGHT_PAREN     reduce using rule 44 (argument -> casting argument .)
    COMMA           reduce using rule 44 (argument -> casting argument .)
    RIGHT_BRACKET   reduce using rule 44 (argument -> casting argument .)


state 117

    (101) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (54) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (87) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (102) casting_type -> . INT_TYPE
    (103) casting_type -> . FLOAT_TYPE
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 112
    FLOAT_TYPE      shift and go to state 113
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    ID              shift and go to state 30

    casting_type                   shift and go to state 110
    expression                     shift and go to state 93
    condition                      shift and go to state 82
    term                           shift and go to state 51
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    factor                         shift and go to state 52
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 118

    (110) array_indexing -> variable LEFT_BRACKET . INTEGER RIGHT_BRACKET

    INTEGER         shift and go to state 154


state 119

    (26) assignment_operator -> EQUALS .

    STRING          reduce using rule 26 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 26 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 26 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 26 (assignment_operator -> EQUALS .)
    ID              reduce using rule 26 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 26 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 26 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 26 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 26 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 26 (assignment_operator -> EQUALS .)


state 120

    (19) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 155


state 121

    (18) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 156


state 122

    (23) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 23 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 23 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 23 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 23 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 23 (assignment_statement -> variable assignment_operator argument .)


state 123

    (105) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 105 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 105 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 105 (array_declaration_statement -> variable EQUALS array .)


state 124

    (106) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 157


state 125

    (107) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (108) array_elements -> . argument
    (109) array_elements -> . array_elements COMMA argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    array_elements                 shift and go to state 158
    argument                       shift and go to state 127
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 126

    (104) function_call -> NAME LEFT_PAREN array_elements . RIGHT_PAREN
    (109) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 159
    COMMA           shift and go to state 160


state 127

    (108) array_elements -> argument .

    RIGHT_PAREN     reduce using rule 108 (array_elements -> argument .)
    COMMA           reduce using rule 108 (array_elements -> argument .)
    RIGHT_BRACKET   reduce using rule 108 (array_elements -> argument .)


state 128

    (63) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (72) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 161
    COMMA           shift and go to state 162


state 129

    (64) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    SEMICOLON       reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    TRUE            reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 64 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 130

    (71) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 71 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 71 (assignment_list -> assignment_statement .)


state 131

    (23) assignment_statement -> variable . assignment_operator argument
    (24) assignment_statement -> variable . PLUS_PLUS
    (25) assignment_statement -> variable . MINUS_MINUS
    (26) assignment_operator -> . EQUALS
    (27) assignment_operator -> . PLUS_EQUALS
    (28) assignment_operator -> . MINUS_EQUALS
    (29) assignment_operator -> . TIMES_EQUALS
    (30) assignment_operator -> . DIVIDE_EQUALS
    (31) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 70
    MINUS_MINUS     shift and go to state 71
    EQUALS          shift and go to state 119
    PLUS_EQUALS     shift and go to state 73
    MINUS_EQUALS    shift and go to state 74
    TIMES_EQUALS    shift and go to state 75
    DIVIDE_EQUALS   shift and go to state 76
    MOD_EQUALS      shift and go to state 77

    assignment_operator            shift and go to state 69

state 132

    (55) if_statement -> IF parenthesized_condition block else_if_extended . if_part3
    (57) else_if_extended -> else_if_extended . if_part2
    (60) if_part3 -> . ELSE block
    (61) if_part3 -> .
    (58) if_part2 -> . ELSEIF parenthesized_condition block
    (59) if_part2 -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSEIF resolved as shift
  ! reduce/reduce conflict for CLOSE_TAG resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for ONE_LINE_COMMENT resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for MULTI_LINE_COMMENT resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for IF resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for FSCANF resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for FGETS resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for NAME resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for FOR resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for ECHO resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for ID resolved using rule 59 (if_part2 -> .)
  ! reduce/reduce conflict for RIGHT_BRACE resolved using rule 59 (if_part2 -> .)
    ELSE            shift and go to state 165
    ELSEIF          shift and go to state 134
    CLOSE_TAG       reduce using rule 59 (if_part2 -> .)
    ONE_LINE_COMMENT reduce using rule 59 (if_part2 -> .)
    MULTI_LINE_COMMENT reduce using rule 59 (if_part2 -> .)
    BREAK           reduce using rule 59 (if_part2 -> .)
    CONTINUE        reduce using rule 59 (if_part2 -> .)
    IF              reduce using rule 59 (if_part2 -> .)
    WHILE           reduce using rule 59 (if_part2 -> .)
    FSCANF          reduce using rule 59 (if_part2 -> .)
    FGETS           reduce using rule 59 (if_part2 -> .)
    NAME            reduce using rule 59 (if_part2 -> .)
    FOR             reduce using rule 59 (if_part2 -> .)
    PRINT           reduce using rule 59 (if_part2 -> .)
    ECHO            reduce using rule 59 (if_part2 -> .)
    ID              reduce using rule 59 (if_part2 -> .)
    RIGHT_BRACE     reduce using rule 59 (if_part2 -> .)

  ! CLOSE_TAG       [ reduce using rule 61 (if_part3 -> .) ]
  ! ONE_LINE_COMMENT [ reduce using rule 61 (if_part3 -> .) ]
  ! MULTI_LINE_COMMENT [ reduce using rule 61 (if_part3 -> .) ]
  ! BREAK           [ reduce using rule 61 (if_part3 -> .) ]
  ! CONTINUE        [ reduce using rule 61 (if_part3 -> .) ]
  ! IF              [ reduce using rule 61 (if_part3 -> .) ]
  ! WHILE           [ reduce using rule 61 (if_part3 -> .) ]
  ! FSCANF          [ reduce using rule 61 (if_part3 -> .) ]
  ! FGETS           [ reduce using rule 61 (if_part3 -> .) ]
  ! NAME            [ reduce using rule 61 (if_part3 -> .) ]
  ! FOR             [ reduce using rule 61 (if_part3 -> .) ]
  ! PRINT           [ reduce using rule 61 (if_part3 -> .) ]
  ! ECHO            [ reduce using rule 61 (if_part3 -> .) ]
  ! ID              [ reduce using rule 61 (if_part3 -> .) ]
  ! RIGHT_BRACE     [ reduce using rule 61 (if_part3 -> .) ]
  ! ELSE            [ reduce using rule 59 (if_part2 -> .) ]
  ! ELSEIF          [ reduce using rule 59 (if_part2 -> .) ]

    if_part3                       shift and go to state 163
    if_part2                       shift and go to state 164

state 133

    (56) else_if_extended -> if_part2 .

    ELSE            reduce using rule 56 (else_if_extended -> if_part2 .)
    ELSEIF          reduce using rule 56 (else_if_extended -> if_part2 .)
    CLOSE_TAG       reduce using rule 56 (else_if_extended -> if_part2 .)
    ONE_LINE_COMMENT reduce using rule 56 (else_if_extended -> if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 56 (else_if_extended -> if_part2 .)
    BREAK           reduce using rule 56 (else_if_extended -> if_part2 .)
    CONTINUE        reduce using rule 56 (else_if_extended -> if_part2 .)
    IF              reduce using rule 56 (else_if_extended -> if_part2 .)
    WHILE           reduce using rule 56 (else_if_extended -> if_part2 .)
    FSCANF          reduce using rule 56 (else_if_extended -> if_part2 .)
    FGETS           reduce using rule 56 (else_if_extended -> if_part2 .)
    NAME            reduce using rule 56 (else_if_extended -> if_part2 .)
    FOR             reduce using rule 56 (else_if_extended -> if_part2 .)
    PRINT           reduce using rule 56 (else_if_extended -> if_part2 .)
    ECHO            reduce using rule 56 (else_if_extended -> if_part2 .)
    ID              reduce using rule 56 (else_if_extended -> if_part2 .)
    RIGHT_BRACE     reduce using rule 56 (else_if_extended -> if_part2 .)


state 134

    (58) if_part2 -> ELSEIF . parenthesized_condition block
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 35

    parenthesized_condition        shift and go to state 166

state 135

    (75) block -> LEFT_BRACE statements . RIGHT_BRACE
=======
    statement_return               shift and go to state 9
    function_statement             shift and go to state 10
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    for_part1                      shift and go to state 22
    print_function                 shift and go to state 25
    variable                       shift and go to state 28

state 137

    (54) term -> term TIMES factor .

    TIMES           reduce using rule 54 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 54 (term -> term TIMES factor .)
    PLUS            reduce using rule 54 (term -> term TIMES factor .)
    MINUS           reduce using rule 54 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 54 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 54 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 54 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 54 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 54 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 54 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 54 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 54 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 54 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 54 (term -> term TIMES factor .)
    DOT             reduce using rule 54 (term -> term TIMES factor .)
    COMMA           reduce using rule 54 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 54 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 54 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 54 (term -> term TIMES factor .)


state 138

    (55) term -> term DIVIDE factor .

    TIMES           reduce using rule 55 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 55 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 55 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 55 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 55 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 55 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 55 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 55 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 55 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 55 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 55 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 55 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 55 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 55 (term -> term DIVIDE factor .)
    DOT             reduce using rule 55 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 55 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 55 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 55 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 55 (term -> term DIVIDE factor .)


state 139

    (19) function_statement -> FUNCTION NAME LEFT_PAREN arguments . RIGHT_PAREN block
    (42) arguments -> arguments . DOT argument
    (43) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 156
    DOT             shift and go to state 110
    COMMA           shift and go to state 111


state 140

    (37) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 37 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 37 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 37 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 141

    (42) arguments -> arguments DOT argument .

    DOT             reduce using rule 42 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 42 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 42 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 42 (arguments -> arguments DOT argument .)


state 142

    (43) arguments -> arguments COMMA argument .

    DOT             reduce using rule 43 (arguments -> arguments COMMA argument .)
    COMMA           reduce using rule 43 (arguments -> arguments COMMA argument .)
    SEMICOLON       reduce using rule 43 (arguments -> arguments COMMA argument .)
    RIGHT_PAREN     reduce using rule 43 (arguments -> arguments COMMA argument .)


state 143

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 157


state 144

    (23) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 23 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)


state 145

    (98) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (100) array_elements -> . argument
    (101) array_elements -> . array_elements COMMA argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    array_elements                 shift and go to state 158
    argument                       shift and go to state 147
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 146

    (99) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (101) array_elements -> array_elements . COMMA argument

    RIGHT_BRACKET   shift and go to state 159
    COMMA           shift and go to state 160


state 147

    (100) array_elements -> argument .

    RIGHT_BRACKET   reduce using rule 100 (array_elements -> argument .)
    COMMA           reduce using rule 100 (array_elements -> argument .)
    RIGHT_PAREN     reduce using rule 100 (array_elements -> argument .)


state 148

    (65) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    TRUE            reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    SEMICOLON       reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    STRING          reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 65 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)


state 149

    (74) assignment_list -> assignment_list COMMA . assignment_statement
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (27) variable -> . ID

    ID              shift and go to state 32

    assignment_statement           shift and go to state 161
    variable                       shift and go to state 122

state 150

    (62) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .
    (63) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block . ELSE block

    CLOSE_TAG       reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    BREAK           reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    CONTINUE        reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    IF              reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    WHILE           reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    RETURN          reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FUNCTION        reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FSCANF          reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FGETS           reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    FOR             reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    PRINT           reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ECHO            reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ID              reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 62 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block .)
    ELSE            shift and go to state 162


state 151

    (64) while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    BREAK           reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    CONTINUE        reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    IF              reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    WHILE           reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    RETURN          reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FUNCTION        reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FSCANF          reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FGETS           reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    FOR             reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    PRINT           reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    ECHO            reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    ID              reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 64 (while_statement -> WHILE LEFT_PAREN condition RIGHT_PAREN block .)


state 152

    (69) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 69 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)


state 153

    (76) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 76 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 76 (statement_list -> statement_list COMMA statement .)


state 154

    (77) block -> LEFT_BRACE statements . RIGHT_BRACE
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
<<<<<<< HEAD
    (8) statement2 -> . ONE_LINE_COMMENT
    (9) statement2 -> . MULTI_LINE_COMMENT
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (17) statement -> . function_call
    (55) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (62) while_statement -> . WHILE parenthesized_condition block
    (65) for_statement -> . for_part1 condition for_part3
    (66) for_statement -> . for_part1 for_part3
    (32) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> . print_function arguments
    (19) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (105) array_declaration_statement -> . variable EQUALS array
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (63) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (64) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (34) print_function -> . PRINT
    (35) print_function -> . ECHO
    (22) variable -> . ID

    RIGHT_BRACE     shift and go to state 167
    ONE_LINE_COMMENT shift and go to state 9
    MULTI_LINE_COMMENT shift and go to state 10
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    FSCANF          shift and go to state 23
    FGETS           shift and go to state 24
    NAME            shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    ECHO            shift and go to state 29
    ID              shift and go to state 30

    statement2                     shift and go to state 32
=======
    (8) statement2 -> . statement_return
    (9) statement2 -> . function_statement
    (10) statement2 -> . ONE_LINE_COMMENT
    (11) statement2 -> . MULTI_LINE_COMMENT
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (62) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block
    (63) if_statement -> . IF LEFT_PAREN condition RIGHT_PAREN block ELSE block
    (64) while_statement -> . WHILE LEFT_PAREN condition RIGHT_PAREN block
    (67) for_statement -> . for_part1 condition for_part3
    (68) for_statement -> . for_part1 for_part3
    (22) statement_return -> . RETURN expression SEMICOLON
    (19) function_statement -> . FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block
    (37) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (38) print_statement -> . print_function arguments
    (24) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (23) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (97) array_declaration_statement -> . variable EQUALS array
    (65) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (66) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (39) print_function -> . PRINT
    (40) print_function -> . ECHO
    (27) variable -> . ID

    RIGHT_BRACE     shift and go to state 163
    ONE_LINE_COMMENT shift and go to state 11
    MULTI_LINE_COMMENT shift and go to state 12
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    RETURN          shift and go to state 23
    FUNCTION        shift and go to state 24
    FSCANF          shift and go to state 26
    FGETS           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    ECHO            shift and go to state 31
    ID              shift and go to state 32

    statement2                     shift and go to state 34
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
<<<<<<< HEAD
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    function_call                  shift and go to state 18
    for_part1                      shift and go to state 21
    print_function                 shift and go to state 22
    variable                       shift and go to state 25

state 136

    (76) block -> LEFT_BRACE RIGHT_BRACE .

    ELSEIF          reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSE            reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 76 (block -> LEFT_BRACE RIGHT_BRACE .)


state 137

    (87) parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .

    LEFT_BRACE      reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    SEMICOLON       reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    TIMES           reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIVIDE          reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    PLUS            reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MINUS           reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_THAN       reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIFFERENT       reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 87 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 138

    (86) complex_condition -> condition logical_operator condition .
    (86) complex_condition -> condition . logical_operator condition
    (53) factor -> condition .
    (98) logical_operator -> . LOGICAL_AND
    (99) logical_operator -> . LOGICAL_OR
    (100) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 53 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 53 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 86 (complex_condition -> condition logical_operator condition .)
    DOT             reduce using rule 86 (complex_condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 86 (complex_condition -> condition logical_operator condition .)
    COMMA           reduce using rule 86 (complex_condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 86 (complex_condition -> condition logical_operator condition .)
    TIMES           reduce using rule 53 (factor -> condition .)
    DIVIDE          reduce using rule 53 (factor -> condition .)
    PLUS            reduce using rule 53 (factor -> condition .)
    MINUS           reduce using rule 53 (factor -> condition .)
    EQUAL_TO        reduce using rule 53 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 53 (factor -> condition .)
    LESS_THAN       reduce using rule 53 (factor -> condition .)
    GREATER_THAN    reduce using rule 53 (factor -> condition .)
    LESS_EQUAL      reduce using rule 53 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 53 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 53 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 53 (factor -> condition .)
    DIFFERENT       reduce using rule 53 (factor -> condition .)
    LOGICAL_AND     shift and go to state 86
    LOGICAL_OR      shift and go to state 87
    LOGICAL_XOR     shift and go to state 88

  ! LOGICAL_AND     [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! TIMES           [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! DIVIDE          [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! PLUS            [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! MINUS           [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! EQUAL_TO        [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_THAN       [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_THAN    [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_EQUAL      [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]
  ! DIFFERENT       [ reduce using rule 86 (complex_condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 85

state 139

    (67) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (69) for_part4 -> . block
    (70) for_part4 -> . SEMICOLON
    (75) block -> . LEFT_BRACE statements RIGHT_BRACE
    (76) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 141
    LEFT_BRACE      shift and go to state 81

    for_part4                      shift and go to state 168
    block                          shift and go to state 143

state 140

    (74) statement_list -> statement_list COMMA . statement
    (10) statement -> . print_statement
    (11) statement -> . fscanf_statement
    (12) statement -> . fgets_statement
    (13) statement -> . assignment_statement
    (14) statement -> . array_declaration_statement
    (15) statement -> . BREAK
    (16) statement -> . CONTINUE
    (17) statement -> . function_call
    (32) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (33) print_statement -> . print_function arguments
    (19) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (105) array_declaration_statement -> . variable EQUALS array
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (34) print_function -> . PRINT
    (35) print_function -> . ECHO
    (22) variable -> . ID

    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    FSCANF          shift and go to state 23
    FGETS           shift and go to state 24
    NAME            shift and go to state 26
    PRINT           shift and go to state 28
    ECHO            shift and go to state 29
    ID              shift and go to state 30

    statement                      shift and go to state 169
    print_statement                shift and go to state 11
    fscanf_statement               shift and go to state 12
    fgets_statement                shift and go to state 13
    assignment_statement           shift and go to state 14
    array_declaration_statement    shift and go to state 15
    function_call                  shift and go to state 18
    print_function                 shift and go to state 22
    variable                       shift and go to state 25

state 141

    (70) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 70 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 70 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 70 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 70 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 70 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 70 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 70 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 70 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 70 (for_part4 -> SEMICOLON .)
    NAME            reduce using rule 70 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 70 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 70 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 70 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 70 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 70 (for_part4 -> SEMICOLON .)


state 142

    (68) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 68 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 143

    (69) for_part4 -> block .

    CLOSE_TAG       reduce using rule 69 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 69 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 69 (for_part4 -> block .)
    BREAK           reduce using rule 69 (for_part4 -> block .)
    CONTINUE        reduce using rule 69 (for_part4 -> block .)
    IF              reduce using rule 69 (for_part4 -> block .)
    WHILE           reduce using rule 69 (for_part4 -> block .)
    FSCANF          reduce using rule 69 (for_part4 -> block .)
    FGETS           reduce using rule 69 (for_part4 -> block .)
    NAME            reduce using rule 69 (for_part4 -> block .)
    FOR             reduce using rule 69 (for_part4 -> block .)
    PRINT           reduce using rule 69 (for_part4 -> block .)
    ECHO            reduce using rule 69 (for_part4 -> block .)
    ID              reduce using rule 69 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 69 (for_part4 -> block .)


state 144

    (54) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 54 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 145

    (88) relational_expression -> expression relational_operator expression .
    (45) expression -> expression . PLUS term
    (46) expression -> expression . MINUS term
    (88) relational_expression -> expression . relational_operator expression
    (89) relational_operator -> . EQUAL_TO
    (90) relational_operator -> . NOT_EQUAL_TO
    (91) relational_operator -> . LESS_THAN
    (92) relational_operator -> . GREATER_THAN
    (93) relational_operator -> . LESS_EQUAL
    (94) relational_operator -> . GREATER_EQUAL
    (95) relational_operator -> . IDENTICAL_TO
    (96) relational_operator -> . NOT_IDENTICAL_TO
    (97) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL_TO resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for NOT_IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    SEMICOLON       reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    LOGICAL_AND     reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    TIMES           reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    DIVIDE          reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    DOT             reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    COMMA           reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 88 (relational_expression -> expression relational_operator expression .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    EQUAL_TO        shift and go to state 97
    NOT_EQUAL_TO    shift and go to state 98
    LESS_THAN       shift and go to state 99
    GREATER_THAN    shift and go to state 100
    LESS_EQUAL      shift and go to state 101
    GREATER_EQUAL   shift and go to state 102
    IDENTICAL_TO    shift and go to state 103
    NOT_IDENTICAL_TO shift and go to state 104
    DIFFERENT       shift and go to state 105

  ! PLUS            [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! MINUS           [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! EQUAL_TO        [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_THAN       [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_THAN    [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_EQUAL      [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! IDENTICAL_TO    [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]
  ! DIFFERENT       [ reduce using rule 88 (relational_expression -> expression relational_operator expression .) ]

    relational_operator            shift and go to state 94

state 146

    (54) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (87) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (22) variable -> . ID
    (88) relational_expression -> . expression relational_operator expression

    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48
    LEFT_PAREN      shift and go to state 49
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    ID              shift and go to state 30

    expression                     shift and go to state 93
    condition                      shift and go to state 82
    term                           shift and go to state 51
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    factor                         shift and go to state 52
    variable                       shift and go to state 46
    relational_expression          shift and go to state 47

state 147

    (45) expression -> expression PLUS term .
    (48) term -> term . TIMES factor
    (49) term -> term . DIVIDE factor
    (47) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 45 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 45 (expression -> expression PLUS term .)
    PLUS            reduce using rule 45 (expression -> expression PLUS term .)
    MINUS           reduce using rule 45 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 45 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 45 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 45 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 45 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 45 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 45 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 45 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 45 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 45 (expression -> expression PLUS term .)
    DOT             reduce using rule 45 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 45 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 45 (expression -> expression PLUS term .)
    COMMA           reduce using rule 45 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 45 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 45 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 45 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 45 (expression -> expression PLUS term .)
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107

  ! TIMES           [ reduce using rule 45 (expression -> expression PLUS term .) ]
  ! DIVIDE          [ reduce using rule 45 (expression -> expression PLUS term .) ]
  ! PLUS            [ reduce using rule 47 (expression -> term .) ]
  ! MINUS           [ reduce using rule 47 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 47 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 47 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 47 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 47 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 47 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 47 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 47 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 47 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 47 (expression -> term .) ]


state 148

    (46) expression -> expression MINUS term .
    (48) term -> term . TIMES factor
    (49) term -> term . DIVIDE factor
    (47) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 46 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 46 (expression -> expression MINUS term .)
    PLUS            reduce using rule 46 (expression -> expression MINUS term .)
    MINUS           reduce using rule 46 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 46 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 46 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 46 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 46 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 46 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 46 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 46 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 46 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 46 (expression -> expression MINUS term .)
    DOT             reduce using rule 46 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 46 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 46 (expression -> expression MINUS term .)
    COMMA           reduce using rule 46 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 46 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 46 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 46 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 46 (expression -> expression MINUS term .)
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107

  ! TIMES           [ reduce using rule 46 (expression -> expression MINUS term .) ]
  ! DIVIDE          [ reduce using rule 46 (expression -> expression MINUS term .) ]
  ! PLUS            [ reduce using rule 47 (expression -> term .) ]
  ! MINUS           [ reduce using rule 47 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 47 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 47 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 47 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 47 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 47 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 47 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 47 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 47 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 47 (expression -> term .) ]


state 149

    (48) term -> term TIMES factor .
    (50) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 48 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 48 (term -> term TIMES factor .)
    TIMES           reduce using rule 48 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 48 (term -> term TIMES factor .)
    PLUS            reduce using rule 48 (term -> term TIMES factor .)
    MINUS           reduce using rule 48 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 48 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 48 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 48 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 48 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 48 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 48 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 48 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 48 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 48 (term -> term TIMES factor .)
    DOT             reduce using rule 48 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 48 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 48 (term -> term TIMES factor .)
    COMMA           reduce using rule 48 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 48 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 48 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 48 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 48 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 50 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 50 (term -> factor .) ]
  ! PLUS            [ reduce using rule 50 (term -> factor .) ]
  ! MINUS           [ reduce using rule 50 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 50 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 50 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 50 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 50 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 50 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 50 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 50 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 50 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 50 (term -> factor .) ]


state 150

    (49) term -> term DIVIDE factor .
    (50) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 49 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 49 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 49 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 49 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 49 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 49 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 49 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 49 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 49 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 49 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 49 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 49 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 49 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 49 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 49 (term -> term DIVIDE factor .)
    DOT             reduce using rule 49 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 49 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 49 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 49 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 49 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 49 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 49 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 49 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 50 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 50 (term -> factor .) ]
  ! PLUS            [ reduce using rule 50 (term -> factor .) ]
  ! MINUS           [ reduce using rule 50 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 50 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 50 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 50 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 50 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 50 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 50 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 50 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 50 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 50 (term -> factor .) ]


state 151

    (32) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 32 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 32 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 32 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 152

    (101) casting -> LEFT_PAREN casting_type RIGHT_PAREN .

    STRING          reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NAME            reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FGETS           reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ID              reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    INTEGER         reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FLOAT           reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    TRUE            reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FALSE           reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 101 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)


state 153

    (37) arguments -> arguments DOT argument .

    DOT             reduce using rule 37 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 37 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 37 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 37 (arguments -> arguments DOT argument .)


state 154

    (110) array_indexing -> variable LEFT_BRACKET INTEGER . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 170


state 155

    (19) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 171
=======
    statement_return               shift and go to state 9
    function_statement             shift and go to state 10
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    for_part1                      shift and go to state 22
    print_function                 shift and go to state 25
    variable                       shift and go to state 28

state 155

    (78) block -> LEFT_BRACE RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSE            reduce using rule 78 (block -> LEFT_BRACE RIGHT_BRACE .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 156

<<<<<<< HEAD
    (18) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 18 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    DOT             reduce using rule 18 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 18 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 18 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 18 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
=======
    (19) function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN . block
    (77) block -> . LEFT_BRACE statements RIGHT_BRACE
    (78) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 136
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

    block                          shift and go to state 164

state 157

<<<<<<< HEAD
    (106) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (108) array_elements -> . argument
    (109) array_elements -> . array_elements COMMA argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    array_elements                 shift and go to state 172
    argument                       shift and go to state 127
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 158

    (107) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (109) array_elements -> array_elements . COMMA argument

    RIGHT_BRACKET   shift and go to state 173
=======
    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 165


state 158

    (98) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (101) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 166
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
    COMMA           shift and go to state 160


state 159

<<<<<<< HEAD
    (104) function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 104 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    DOT             reduce using rule 104 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 104 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 104 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 104 (function_call -> NAME LEFT_PAREN array_elements RIGHT_PAREN .)
=======
    (99) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    SEMICOLON       reduce using rule 99 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 99 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 99 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 160

<<<<<<< HEAD
    (109) array_elements -> array_elements COMMA . argument
    (38) argument -> . STRING
    (39) argument -> . expression
    (40) argument -> . assignment_statement
    (41) argument -> . function_call
    (42) argument -> . fgets_statement
    (43) argument -> . array_indexing
    (44) argument -> . casting argument
    (45) expression -> . expression PLUS term
    (46) expression -> . expression MINUS term
    (47) expression -> . term
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (104) function_call -> . NAME LEFT_PAREN array_elements RIGHT_PAREN
    (18) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (110) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (101) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (22) variable -> . ID
    (51) factor -> . INTEGER
    (52) factor -> . FLOAT
    (53) factor -> . condition
    (54) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (77) condition -> . simple_condition
    (78) condition -> . negated_condition
    (79) condition -> . complex_condition
    (80) condition -> . parenthesized_condition
    (81) simple_condition -> . TRUE
    (82) simple_condition -> . FALSE
    (83) simple_condition -> . variable
    (84) simple_condition -> . relational_expression
    (85) negated_condition -> . LOGICAL_NOT condition
    (86) complex_condition -> . condition logical_operator condition
    (87) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (88) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 58
    NAME            shift and go to state 26
    FGETS           shift and go to state 24
    LEFT_PAREN      shift and go to state 117
    ID              shift and go to state 30
    INTEGER         shift and go to state 53
    FLOAT           shift and go to state 54
    TRUE            shift and go to state 44
    FALSE           shift and go to state 45
    LOGICAL_NOT     shift and go to state 48

    argument                       shift and go to state 174
    expression                     shift and go to state 59
    assignment_statement           shift and go to state 60
    function_call                  shift and go to state 61
    fgets_statement                shift and go to state 62
    array_indexing                 shift and go to state 63
    casting                        shift and go to state 64
    term                           shift and go to state 51
    variable                       shift and go to state 65
    factor                         shift and go to state 52
    condition                      shift and go to state 66
    simple_condition               shift and go to state 39
    negated_condition              shift and go to state 40
    complex_condition              shift and go to state 41
    parenthesized_condition        shift and go to state 42
    relational_expression          shift and go to state 47

state 161

    (63) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    SEMICOLON       reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    TRUE            reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 63 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
=======
    (101) array_elements -> array_elements COMMA . argument
    (44) argument -> . INTEGER
    (45) argument -> . FLOAT
    (46) argument -> . STRING
    (47) argument -> . variable
    (48) argument -> . expression
    (49) argument -> . condition
    (50) argument -> . assignment_statement
    (27) variable -> . ID
    (51) expression -> . expression PLUS term
    (52) expression -> . expression MINUS term
    (53) expression -> . term
    (79) condition -> . TRUE
    (80) condition -> . FALSE
    (81) condition -> . expression relational_operator expression
    (82) condition -> . condition logical_operator condition
    (83) condition -> . LOGICAL_NOT condition
    (84) condition -> . LEFT_PAREN condition RIGHT_PAREN
    (34) assignment_statement -> . variable assignment_operator argument
    (35) assignment_statement -> . variable PLUS_PLUS
    (36) assignment_statement -> . variable MINUS_MINUS
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . factor
    (57) factor -> . INTEGER
    (58) factor -> . FLOAT
    (59) factor -> . variable
    (60) factor -> . STRING
    (61) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    ID              shift and go to state 32
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LOGICAL_NOT     shift and go to state 43
    LEFT_PAREN      shift and go to state 44

    argument                       shift and go to state 167
    variable                       shift and go to state 61
    expression                     shift and go to state 62
    condition                      shift and go to state 63
    assignment_statement           shift and go to state 64
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 161

    (74) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 74 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 74 (assignment_list -> assignment_list COMMA assignment_statement .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 162

<<<<<<< HEAD
    (72) assignment_list -> assignment_list COMMA . assignment_statement
    (23) assignment_statement -> . variable assignment_operator argument
    (24) assignment_statement -> . variable PLUS_PLUS
    (25) assignment_statement -> . variable MINUS_MINUS
    (22) variable -> . ID

    ID              shift and go to state 30

    assignment_statement           shift and go to state 175
    variable                       shift and go to state 131

state 163

    (55) if_statement -> IF parenthesized_condition block else_if_extended if_part3 .

    CLOSE_TAG       reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ONE_LINE_COMMENT reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    BREAK           reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CONTINUE        reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    IF              reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    WHILE           reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FSCANF          reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FGETS           reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    NAME            reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FOR             reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    PRINT           reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ECHO            reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ID              reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RIGHT_BRACE     reduce using rule 55 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
=======
    (63) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE . block
    (77) block -> . LEFT_BRACE statements RIGHT_BRACE
    (78) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 136

    block                          shift and go to state 168

state 163

    (77) block -> LEFT_BRACE statements RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RETURN          reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSE            reduce using rule 77 (block -> LEFT_BRACE statements RIGHT_BRACE .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 164

<<<<<<< HEAD
    (57) else_if_extended -> else_if_extended if_part2 .

    ELSE            reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    ELSEIF          reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    CLOSE_TAG       reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    ONE_LINE_COMMENT reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    BREAK           reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    CONTINUE        reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    IF              reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    WHILE           reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    FSCANF          reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    FGETS           reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    NAME            reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    FOR             reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    PRINT           reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    ECHO            reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    ID              reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
    RIGHT_BRACE     reduce using rule 57 (else_if_extended -> else_if_extended if_part2 .)
=======
    (19) function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    BREAK           reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    CONTINUE        reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    IF              reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    WHILE           reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    RETURN          reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FUNCTION        reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FSCANF          reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FGETS           reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    FOR             reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    PRINT           reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    ECHO            reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    ID              reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 19 (function_statement -> FUNCTION NAME LEFT_PAREN arguments RIGHT_PAREN block .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 165

<<<<<<< HEAD
    (60) if_part3 -> ELSE . block
    (75) block -> . LEFT_BRACE statements RIGHT_BRACE
    (76) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 81

    block                          shift and go to state 176

state 166

    (58) if_part2 -> ELSEIF parenthesized_condition . block
    (75) block -> . LEFT_BRACE statements RIGHT_BRACE
    (76) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 81

    block                          shift and go to state 177

state 167

    (75) block -> LEFT_BRACE statements RIGHT_BRACE .

    ELSEIF          reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSE            reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    NAME            reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 75 (block -> LEFT_BRACE statements RIGHT_BRACE .)
=======
    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (25) variable_list -> . variable
    (26) variable_list -> . variable_list COMMA variable
    (27) variable -> . ID

    ID              shift and go to state 32

    variable_list                  shift and go to state 169
    variable                       shift and go to state 170

state 166

    (98) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 98 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 98 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 98 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 167

    (101) array_elements -> array_elements COMMA argument .

    RIGHT_BRACKET   reduce using rule 101 (array_elements -> array_elements COMMA argument .)
    COMMA           reduce using rule 101 (array_elements -> array_elements COMMA argument .)
    RIGHT_PAREN     reduce using rule 101 (array_elements -> array_elements COMMA argument .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 168

<<<<<<< HEAD
    (67) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 67 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
=======
    (63) if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .

    CLOSE_TAG       reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ONE_LINE_COMMENT reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    BREAK           reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    CONTINUE        reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    IF              reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    WHILE           reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    RETURN          reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FUNCTION        reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FSCANF          reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FGETS           reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    FOR             reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    PRINT           reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ECHO            reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    ID              reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
    RIGHT_BRACE     reduce using rule 63 (if_statement -> IF LEFT_PAREN condition RIGHT_PAREN block ELSE block .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 169

<<<<<<< HEAD
    (74) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 74 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 74 (statement_list -> statement_list COMMA statement .)
=======
    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (26) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 172
    COMMA           shift and go to state 171
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 170

<<<<<<< HEAD
    (110) array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .

    DOT             reduce using rule 110 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 110 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 110 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    COMMA           reduce using rule 110 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 110 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
=======
    (25) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 25 (variable_list -> variable .)
    COMMA           reduce using rule 25 (variable_list -> variable .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 171

<<<<<<< HEAD
    (19) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 178


state 172

    (106) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (109) array_elements -> array_elements . COMMA argument

    RIGHT_PAREN     shift and go to state 179
    COMMA           shift and go to state 160
=======
    (26) variable_list -> variable_list COMMA . variable
    (27) variable -> . ID

    ID              shift and go to state 32

    variable                       shift and go to state 173

state 172

    (24) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 24 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 24 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 24 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62


state 173

<<<<<<< HEAD
    (107) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    SEMICOLON       reduce using rule 107 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 107 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 107 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)


state 174

    (109) array_elements -> array_elements COMMA argument .

    RIGHT_PAREN     reduce using rule 109 (array_elements -> array_elements COMMA argument .)
    COMMA           reduce using rule 109 (array_elements -> array_elements COMMA argument .)
    RIGHT_BRACKET   reduce using rule 109 (array_elements -> array_elements COMMA argument .)


state 175

    (72) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 72 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 72 (assignment_list -> assignment_list COMMA assignment_statement .)


state 176

    (60) if_part3 -> ELSE block .

    CLOSE_TAG       reduce using rule 60 (if_part3 -> ELSE block .)
    ONE_LINE_COMMENT reduce using rule 60 (if_part3 -> ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 60 (if_part3 -> ELSE block .)
    BREAK           reduce using rule 60 (if_part3 -> ELSE block .)
    CONTINUE        reduce using rule 60 (if_part3 -> ELSE block .)
    IF              reduce using rule 60 (if_part3 -> ELSE block .)
    WHILE           reduce using rule 60 (if_part3 -> ELSE block .)
    FSCANF          reduce using rule 60 (if_part3 -> ELSE block .)
    FGETS           reduce using rule 60 (if_part3 -> ELSE block .)
    NAME            reduce using rule 60 (if_part3 -> ELSE block .)
    FOR             reduce using rule 60 (if_part3 -> ELSE block .)
    PRINT           reduce using rule 60 (if_part3 -> ELSE block .)
    ECHO            reduce using rule 60 (if_part3 -> ELSE block .)
    ID              reduce using rule 60 (if_part3 -> ELSE block .)
    RIGHT_BRACE     reduce using rule 60 (if_part3 -> ELSE block .)


state 177

    (58) if_part2 -> ELSEIF parenthesized_condition block .

    ELSE            reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    ELSEIF          reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLOSE_TAG       reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    BREAK           reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    CONTINUE        reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    IF              reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    WHILE           reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    FSCANF          reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    FGETS           reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    NAME            reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    FOR             reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    PRINT           reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    ECHO            reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    ID              reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 58 (if_part2 -> ELSEIF parenthesized_condition block .)


state 178

    (19) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (20) variable_list -> . variable
    (21) variable_list -> . variable_list COMMA variable
    (22) variable -> . ID

    ID              shift and go to state 30

    variable_list                  shift and go to state 180
    variable                       shift and go to state 181

state 179

    (106) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    SEMICOLON       reduce using rule 106 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 106 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 106 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 180

    (19) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (21) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 183
    COMMA           shift and go to state 182


state 181

    (20) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 20 (variable_list -> variable .)
    COMMA           reduce using rule 20 (variable_list -> variable .)


state 182

    (21) variable_list -> variable_list COMMA . variable
    (22) variable -> . ID

    ID              shift and go to state 30

    variable                       shift and go to state 184

state 183

    (19) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 19 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 19 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 19 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)


state 184

    (21) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 21 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 21 (variable_list -> variable_list COMMA variable .)
=======
    (26) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 26 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 26 (variable_list -> variable_list COMMA variable .)
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62

WARNING: 
WARNING: Conflicts:
WARNING: 
<<<<<<< HEAD
WARNING: shift/reduce conflict for TIMES in state 51 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 51 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 66 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 66 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 66 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 80 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 82 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 92 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 92 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 92 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 111 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 132 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 132 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 138 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 138 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 145 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL_TO in state 145 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 145 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 145 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 145 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 145 resolved as shift
WARNING: shift/reduce conflict for IDENTICAL_TO in state 145 resolved as shift
WARNING: shift/reduce conflict for NOT_IDENTICAL_TO in state 145 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 145 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: reduce/reduce conflict in state 92 resolved using rule (factor -> condition)
WARNING: rejected rule (negated_condition -> LOGICAL_NOT condition) in state 92
WARNING: reduce/reduce conflict in state 132 resolved using rule (if_part2 -> <empty>)
WARNING: rejected rule (if_part3 -> <empty>) in state 132
WARNING: reduce/reduce conflict in state 138 resolved using rule (factor -> condition)
WARNING: rejected rule (complex_condition -> condition logical_operator condition) in state 138
WARNING: reduce/reduce conflict in state 147 resolved using rule (expression -> expression PLUS term)
WARNING: rejected rule (expression -> term) in state 147
WARNING: reduce/reduce conflict in state 148 resolved using rule (expression -> expression MINUS term)
WARNING: rejected rule (expression -> term) in state 148
WARNING: reduce/reduce conflict in state 149 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 149
WARNING: reduce/reduce conflict in state 150 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 150
WARNING: Rule (if_part3 -> <empty>) is never reduced
=======
WARNING: shift/reduce conflict for COMMA in state 56 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 96 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 96 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 96 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 108 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 125 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 125 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 125 resolved as shift
WARNING: reduce/reduce conflict in state 58 resolved using rule (argument -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 58
WARNING: reduce/reduce conflict in state 59 resolved using rule (argument -> FLOAT)
WARNING: rejected rule (factor -> FLOAT) in state 59
WARNING: reduce/reduce conflict in state 60 resolved using rule (argument -> STRING)
WARNING: rejected rule (factor -> STRING) in state 60
WARNING: reduce/reduce conflict in state 61 resolved using rule (argument -> variable)
WARNING: rejected rule (factor -> variable) in state 61
>>>>>>> 415af9ebad94e8e318d4a22725ef05b17ff7ed62
