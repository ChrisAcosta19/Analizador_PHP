Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASYNC
    AWAIT
    BOOL
    CALLABLE
    CASE
    CATCH
    CLONE
    COLON
    CONST
    DECLARE
    DEFAULT
    DIE
    DO
    EMPTY
    ENDDECLARE
    ENDFOR
    ENDFOREACH
    ENDIF
    ENDSWITCH
    ENDWHILE
    ENUM
    EVAL
    EXIT
    EXTENDS
    FINAL
    FINALLY
    FN
    FOREACH
    GLOBAL
    GOTO
    HALT_COMPILER
    IMPLEMENTS
    INCLUDE
    INCLUDE_ONCE
    INSTANCEOF
    INSTEADOF
    INTERFACE
    ISSET
    ITERABLE
    LIST
    LPAREN
    MATCH
    MIXED
    NAMESPACE
    NULL
    OBJECT
    REQUIRE
    REQUIRE_ONCE
    RPAREN
    SELF
    STATIC
    SWITCH
    THROW
    TRAIT
    TRY
    UNSET
    USE
    VAR
    VOID
    YIELD
    YIELD_FROM

Grammar

Rule 0     S' -> program
Rule 1     program -> OPEN_TAG statements CLOSE_TAG
Rule 2     statements -> statement2
Rule 3     statements -> statements statement2
Rule 4     statement2 -> statement SEMICOLON
Rule 5     statement2 -> if_statement
Rule 6     statement2 -> while_statement
Rule 7     statement2 -> for_statement
Rule 8     statement2 -> function_statement
Rule 9     statement2 -> ONE_LINE_COMMENT
Rule 10    statement2 -> MULTI_LINE_COMMENT
Rule 11    statement2 -> class_declaration
Rule 12    statement -> print_statement
Rule 13    statement -> fscanf_statement
Rule 14    statement -> fgets_statement
Rule 15    statement -> assignment_statement
Rule 16    statement -> array_declaration_statement
Rule 17    statement -> BREAK
Rule 18    statement -> CONTINUE
Rule 19    statement -> function_call
Rule 20    statement -> return_statement
Rule 21    statement -> expression
Rule 22    function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
Rule 23    function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
Rule 24    anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
Rule 25    anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block
Rule 26    return_statement -> RETURN arguments
Rule 27    function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN
Rule 28    function_call -> function_name LEFT_PAREN RIGHT_PAREN
Rule 29    function_name -> NAME
Rule 30    function_name -> variable
Rule 31    fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN
Rule 32    fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
Rule 33    variable_list -> variable
Rule 34    variable_list -> variable_list COMMA variable
Rule 35    variable -> ID
Rule 36    variable -> ID CALL NAME
Rule 37    assignment_statement -> variable assignment_operator argument
Rule 38    assignment_statement -> variable PLUS_PLUS
Rule 39    assignment_statement -> variable MINUS_MINUS
Rule 40    assignment_operator -> EQUALS
Rule 41    assignment_operator -> PLUS_EQUALS
Rule 42    assignment_operator -> MINUS_EQUALS
Rule 43    assignment_operator -> TIMES_EQUALS
Rule 44    assignment_operator -> DIVIDE_EQUALS
Rule 45    assignment_operator -> MOD_EQUALS
Rule 46    print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN
Rule 47    print_statement -> print_function arguments
Rule 48    print_function -> PRINT
Rule 49    print_function -> ECHO
Rule 50    arguments -> argument
Rule 51    arguments -> arguments DOT argument
Rule 52    arguments -> arguments COMMA argument
Rule 53    argument -> STRING
Rule 54    argument -> expression
Rule 55    argument -> array
Rule 56    argument -> array_indexing
Rule 57    argument -> function_call
Rule 58    argument -> variable CALL function_call
Rule 59    argument -> anonymous_function
Rule 60    argument -> assignment_statement
Rule 61    argument -> fgets_statement
Rule 62    argument -> object_creation
Rule 63    argument -> casting argument
Rule 64    expression -> expression PLUS term
Rule 65    expression -> expression MINUS term
Rule 66    expression -> term
Rule 67    term -> term TIMES factor
Rule 68    term -> term DIVIDE factor
Rule 69    term -> term MOD factor
Rule 70    term -> term POWER factor
Rule 71    term -> factor
Rule 72    factor -> INTEGER
Rule 73    factor -> FLOAT
Rule 74    factor -> condition
Rule 75    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 76    if_statement -> IF parenthesized_condition block
Rule 77    if_statement -> IF parenthesized_condition block else_if_extended
Rule 78    if_statement -> IF parenthesized_condition block else_if_extended if_part3
Rule 79    if_statement -> IF parenthesized_condition block if_part3
Rule 80    else_if_extended -> if_part2
Rule 81    else_if_extended -> else_if_extended if_part2
Rule 82    if_part2 -> ELSEIF parenthesized_condition block
Rule 83    if_part3 -> ELSE block
Rule 84    while_statement -> WHILE parenthesized_condition block
Rule 85    for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON
Rule 86    for_part1 -> FOR LEFT_PAREN SEMICOLON
Rule 87    for_statement -> for_part1 condition for_part3
Rule 88    for_statement -> for_part1 for_part3
Rule 89    for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4
Rule 90    for_part3 -> SEMICOLON RIGHT_PAREN for_part4
Rule 91    for_part4 -> block
Rule 92    for_part4 -> SEMICOLON
Rule 93    assignment_list -> assignment_statement
Rule 94    assignment_list -> assignment_list COMMA assignment_statement
Rule 95    statement_list -> statement
Rule 96    statement_list -> statement_list COMMA statement
Rule 97    block -> LEFT_BRACE statements RIGHT_BRACE
Rule 98    block -> LEFT_BRACE RIGHT_BRACE
Rule 99    condition -> simple_condition
Rule 100   condition -> negated_condition
Rule 101   condition -> complex_condition
Rule 102   condition -> parenthesized_condition
Rule 103   simple_condition -> TRUE
Rule 104   simple_condition -> FALSE
Rule 105   simple_condition -> variable
Rule 106   simple_condition -> relational_expression
Rule 107   negated_condition -> LOGICAL_NOT condition
Rule 108   complex_condition -> condition logical_operator condition
Rule 109   parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN
Rule 110   relational_expression -> expression relational_operator expression
Rule 111   relational_operator -> EQUAL_TO
Rule 112   relational_operator -> NOT_EQUAL_TO
Rule 113   relational_operator -> LESS_THAN
Rule 114   relational_operator -> GREATER_THAN
Rule 115   relational_operator -> LESS_EQUAL
Rule 116   relational_operator -> GREATER_EQUAL
Rule 117   relational_operator -> IDENTICAL_TO
Rule 118   relational_operator -> NOT_IDENTICAL_TO
Rule 119   relational_operator -> DIFFERENT
Rule 120   logical_operator -> LOGICAL_AND
Rule 121   logical_operator -> LOGICAL_OR
Rule 122   logical_operator -> LOGICAL_XOR
Rule 123   casting -> LEFT_PAREN casting_type RIGHT_PAREN
Rule 124   casting_type -> INT_TYPE
Rule 125   casting_type -> FLOAT_TYPE
Rule 126   array_declaration_statement -> variable EQUALS array
Rule 127   array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN
Rule 128   array -> LEFT_BRACKET array_elements RIGHT_BRACKET
Rule 129   array_elements -> array_argument
Rule 130   array_elements -> array_elements COMMA array_argument
Rule 131   array_argument -> argument
Rule 132   array_argument -> clave KEY_VALUE argument
Rule 133   clave -> STRING
Rule 134   clave -> INTEGER
Rule 135   array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET
Rule 136   class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
Rule 137   class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE
Rule 138   class_statements -> class_statement
Rule 139   class_statements -> class_statements class_statement
Rule 140   class_statement -> method_declaration
Rule 141   class_statement -> property_declaration
Rule 142   class_statement -> ONE_LINE_COMMENT
Rule 143   class_statement -> MULTI_LINE_COMMENT
Rule 144   method_declaration -> visibility_operator function_statement
Rule 145   property_declaration -> visibility_operator variable SEMICOLON
Rule 146   visibility_operator -> PUBLIC
Rule 147   visibility_operator -> PRIVATE
Rule 148   visibility_operator -> PROTECTED
Rule 149   object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN
Rule 150   object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN

Terminals, with rules where they appear

ABSTRACT             : 
ARRAY                : 127
AS                   : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 17
CALL                 : 36 58
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 136 137
CLONE                : 
CLOSE_TAG            : 1
COLON                : 
COMMA                : 32 32 34 52 94 96 130
CONST                : 
CONTINUE             : 18
DECLARE              : 
DEFAULT              : 
DIE                  : 
DIFFERENT            : 119
DIVIDE               : 68
DIVIDE_EQUALS        : 44
DO                   : 
DOT                  : 51
ECHO                 : 49
ELSE                 : 83
ELSEIF               : 82
EMPTY                : 
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
ENUM                 : 
EQUALS               : 40 126
EQUAL_TO             : 111
EVAL                 : 
EXIT                 : 
EXTENDS              : 
FALSE                : 104
FGETS                : 31
FINAL                : 
FINALLY              : 
FLOAT                : 73
FLOAT_TYPE           : 125
FN                   : 
FOR                  : 85 86
FOREACH              : 
FSCANF               : 32
FUNCTION             : 22 23 24 25
GLOBAL               : 
GOTO                 : 
GREATER_EQUAL        : 116
GREATER_THAN         : 114
HALT_COMPILER        : 
ID                   : 35 36
IDENTICAL_TO         : 117
IF                   : 76 77 78 79
IMPLEMENTS           : 
INCLUDE              : 
INCLUDE_ONCE         : 
INSTANCEOF           : 
INSTEADOF            : 
INTEGER              : 72 134 135
INTERFACE            : 
INT_TYPE             : 124
ISSET                : 
ITERABLE             : 
KEY_VALUE            : 132
LEFT_BRACE           : 97 98 136 137
LEFT_BRACKET         : 128 135
LEFT_PAREN           : 22 23 24 25 27 28 31 32 46 75 85 86 109 123 127 149 150
LESS_EQUAL           : 115
LESS_THAN            : 113
LIST                 : 
LOGICAL_AND          : 120
LOGICAL_NOT          : 107
LOGICAL_OR           : 121
LOGICAL_XOR          : 122
LPAREN               : 
MATCH                : 
MINUS                : 65
MINUS_EQUALS         : 42
MINUS_MINUS          : 39
MIXED                : 
MOD                  : 69
MOD_EQUALS           : 45
MULTI_LINE_COMMENT   : 10 143
NAME                 : 22 23 29 36 136 137 149 150
NAMESPACE            : 
NEW                  : 149 150
NOT_EQUAL_TO         : 112
NOT_IDENTICAL_TO     : 118
NULL                 : 
OBJECT               : 
ONE_LINE_COMMENT     : 9 142
OPEN_TAG             : 1
PLUS                 : 64
PLUS_EQUALS          : 41
PLUS_PLUS            : 38
POWER                : 70
PRINT                : 48
PRIVATE              : 147
PROTECTED            : 148
PUBLIC               : 146
REQUIRE              : 
REQUIRE_ONCE         : 
RETURN               : 26
RIGHT_BRACE          : 97 98 136 137
RIGHT_BRACKET        : 128 135
RIGHT_PAREN          : 22 23 24 25 27 28 31 32 46 75 89 90 109 123 127 149 150
RPAREN               : 
SELF                 : 
SEMICOLON            : 4 85 86 89 90 92 145
STATIC               : 
STDIN                : 31 32
STRING               : 32 53 133
SWITCH               : 
THROW                : 
TIMES                : 67
TIMES_EQUALS         : 43
TRAIT                : 
TRUE                 : 103
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
VOID                 : 
WHILE                : 84
YIELD                : 
YIELD_FROM           : 
error                : 

Nonterminals, with rules where they appear

anonymous_function   : 59
argument             : 37 50 51 52 63 131 132
arguments            : 26 27 46 47 51 52 150
array                : 55 126
array_argument       : 129 130
array_declaration_statement : 16
array_elements       : 22 24 127 128 130
array_indexing       : 56
assignment_list      : 85 94
assignment_operator  : 37
assignment_statement : 15 60 93 94
block                : 22 23 24 25 76 77 78 79 82 83 84 91
casting              : 63
casting_type         : 123
class_declaration    : 11
class_statement      : 138 139
class_statements     : 136 139
clave                : 132
complex_condition    : 101
condition            : 74 87 107 108 108 109
else_if_extended     : 77 78 81
expression           : 21 54 64 65 75 110 110
factor               : 67 68 69 70 71
fgets_statement      : 14 61
for_part1            : 87 88
for_part3            : 87 88
for_part4            : 89 90
for_statement        : 7
fscanf_statement     : 13
function_call        : 19 57 58
function_name        : 27 28
function_statement   : 8 144
if_part2             : 80 81
if_part3             : 78 79
if_statement         : 5
logical_operator     : 108
method_declaration   : 140
negated_condition    : 100
object_creation      : 62
parenthesized_condition : 76 77 78 79 82 84 102
print_function       : 46 47
print_statement      : 12
program              : 0
property_declaration : 141
relational_expression : 106
relational_operator  : 110
return_statement     : 20
simple_condition     : 99
statement            : 4 95 96
statement2           : 2 3
statement_list       : 89 96
statements           : 1 3 97
term                 : 64 65 66 67 68 69 70
variable             : 30 33 34 37 38 39 58 105 126 135 145
variable_list        : 32 34
visibility_operator  : 144 145
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . OPEN_TAG statements CLOSE_TAG

    OPEN_TAG        shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> OPEN_TAG . statements CLOSE_TAG
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . expression
    (76) if_statement -> . IF parenthesized_condition block
    (77) if_statement -> . IF parenthesized_condition block else_if_extended
    (78) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (79) if_statement -> . IF parenthesized_condition block if_part3
    (84) while_statement -> . WHILE parenthesized_condition block
    (87) for_statement -> . for_part1 condition for_part3
    (88) for_statement -> . for_part1 for_part3
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (136) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (137) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (46) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> . print_function arguments
    (32) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (126) array_declaration_statement -> . variable EQUALS array
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (26) return_statement -> . RETURN arguments
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (85) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (86) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (48) print_function -> . PRINT
    (49) print_function -> . ECHO
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 23
    WHILE           shift and go to state 25
    FUNCTION        shift and go to state 28
    CLASS           shift and go to state 31
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    RETURN          shift and go to state 37
    FOR             shift and go to state 39
    PRINT           shift and go to state 40
    ECHO            shift and go to state 41
    ID              shift and go to state 42
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    statements                     shift and go to state 3
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    expression                     shift and go to state 22
    parenthesized_condition        shift and go to state 24
    for_part1                      shift and go to state 26
    condition                      shift and go to state 27
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    function_name                  shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 43
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    relational_expression          shift and go to state 51

state 3

    (1) program -> OPEN_TAG statements . CLOSE_TAG
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . expression
    (76) if_statement -> . IF parenthesized_condition block
    (77) if_statement -> . IF parenthesized_condition block else_if_extended
    (78) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (79) if_statement -> . IF parenthesized_condition block if_part3
    (84) while_statement -> . WHILE parenthesized_condition block
    (87) for_statement -> . for_part1 condition for_part3
    (88) for_statement -> . for_part1 for_part3
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (136) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (137) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (46) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> . print_function arguments
    (32) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (126) array_declaration_statement -> . variable EQUALS array
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (26) return_statement -> . RETURN arguments
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (85) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (86) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (48) print_function -> . PRINT
    (49) print_function -> . ECHO
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    CLOSE_TAG       shift and go to state 53
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 23
    WHILE           shift and go to state 25
    FUNCTION        shift and go to state 28
    CLASS           shift and go to state 31
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    RETURN          shift and go to state 37
    FOR             shift and go to state 39
    PRINT           shift and go to state 40
    ECHO            shift and go to state 41
    ID              shift and go to state 42
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    statement2                     shift and go to state 54
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    expression                     shift and go to state 22
    parenthesized_condition        shift and go to state 24
    for_part1                      shift and go to state 26
    condition                      shift and go to state 27
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    function_name                  shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 43
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    relational_expression          shift and go to state 51

state 4

    (2) statements -> statement2 .

    CLOSE_TAG       reduce using rule 2 (statements -> statement2 .)
    ONE_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    MULTI_LINE_COMMENT reduce using rule 2 (statements -> statement2 .)
    BREAK           reduce using rule 2 (statements -> statement2 .)
    CONTINUE        reduce using rule 2 (statements -> statement2 .)
    IF              reduce using rule 2 (statements -> statement2 .)
    WHILE           reduce using rule 2 (statements -> statement2 .)
    FUNCTION        reduce using rule 2 (statements -> statement2 .)
    CLASS           reduce using rule 2 (statements -> statement2 .)
    FSCANF          reduce using rule 2 (statements -> statement2 .)
    FGETS           reduce using rule 2 (statements -> statement2 .)
    RETURN          reduce using rule 2 (statements -> statement2 .)
    FOR             reduce using rule 2 (statements -> statement2 .)
    PRINT           reduce using rule 2 (statements -> statement2 .)
    ECHO            reduce using rule 2 (statements -> statement2 .)
    ID              reduce using rule 2 (statements -> statement2 .)
    NAME            reduce using rule 2 (statements -> statement2 .)
    INTEGER         reduce using rule 2 (statements -> statement2 .)
    FLOAT           reduce using rule 2 (statements -> statement2 .)
    LEFT_PAREN      reduce using rule 2 (statements -> statement2 .)
    TRUE            reduce using rule 2 (statements -> statement2 .)
    FALSE           reduce using rule 2 (statements -> statement2 .)
    LOGICAL_NOT     reduce using rule 2 (statements -> statement2 .)
    RIGHT_BRACE     reduce using rule 2 (statements -> statement2 .)


state 5

    (4) statement2 -> statement . SEMICOLON

    SEMICOLON       shift and go to state 55


state 6

    (5) statement2 -> if_statement .

    CLOSE_TAG       reduce using rule 5 (statement2 -> if_statement .)
    ONE_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    MULTI_LINE_COMMENT reduce using rule 5 (statement2 -> if_statement .)
    BREAK           reduce using rule 5 (statement2 -> if_statement .)
    CONTINUE        reduce using rule 5 (statement2 -> if_statement .)
    IF              reduce using rule 5 (statement2 -> if_statement .)
    WHILE           reduce using rule 5 (statement2 -> if_statement .)
    FUNCTION        reduce using rule 5 (statement2 -> if_statement .)
    CLASS           reduce using rule 5 (statement2 -> if_statement .)
    FSCANF          reduce using rule 5 (statement2 -> if_statement .)
    FGETS           reduce using rule 5 (statement2 -> if_statement .)
    RETURN          reduce using rule 5 (statement2 -> if_statement .)
    FOR             reduce using rule 5 (statement2 -> if_statement .)
    PRINT           reduce using rule 5 (statement2 -> if_statement .)
    ECHO            reduce using rule 5 (statement2 -> if_statement .)
    ID              reduce using rule 5 (statement2 -> if_statement .)
    NAME            reduce using rule 5 (statement2 -> if_statement .)
    INTEGER         reduce using rule 5 (statement2 -> if_statement .)
    FLOAT           reduce using rule 5 (statement2 -> if_statement .)
    LEFT_PAREN      reduce using rule 5 (statement2 -> if_statement .)
    TRUE            reduce using rule 5 (statement2 -> if_statement .)
    FALSE           reduce using rule 5 (statement2 -> if_statement .)
    LOGICAL_NOT     reduce using rule 5 (statement2 -> if_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement2 -> if_statement .)


state 7

    (6) statement2 -> while_statement .

    CLOSE_TAG       reduce using rule 6 (statement2 -> while_statement .)
    ONE_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    MULTI_LINE_COMMENT reduce using rule 6 (statement2 -> while_statement .)
    BREAK           reduce using rule 6 (statement2 -> while_statement .)
    CONTINUE        reduce using rule 6 (statement2 -> while_statement .)
    IF              reduce using rule 6 (statement2 -> while_statement .)
    WHILE           reduce using rule 6 (statement2 -> while_statement .)
    FUNCTION        reduce using rule 6 (statement2 -> while_statement .)
    CLASS           reduce using rule 6 (statement2 -> while_statement .)
    FSCANF          reduce using rule 6 (statement2 -> while_statement .)
    FGETS           reduce using rule 6 (statement2 -> while_statement .)
    RETURN          reduce using rule 6 (statement2 -> while_statement .)
    FOR             reduce using rule 6 (statement2 -> while_statement .)
    PRINT           reduce using rule 6 (statement2 -> while_statement .)
    ECHO            reduce using rule 6 (statement2 -> while_statement .)
    ID              reduce using rule 6 (statement2 -> while_statement .)
    NAME            reduce using rule 6 (statement2 -> while_statement .)
    INTEGER         reduce using rule 6 (statement2 -> while_statement .)
    FLOAT           reduce using rule 6 (statement2 -> while_statement .)
    LEFT_PAREN      reduce using rule 6 (statement2 -> while_statement .)
    TRUE            reduce using rule 6 (statement2 -> while_statement .)
    FALSE           reduce using rule 6 (statement2 -> while_statement .)
    LOGICAL_NOT     reduce using rule 6 (statement2 -> while_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement2 -> while_statement .)


state 8

    (7) statement2 -> for_statement .

    CLOSE_TAG       reduce using rule 7 (statement2 -> for_statement .)
    ONE_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    MULTI_LINE_COMMENT reduce using rule 7 (statement2 -> for_statement .)
    BREAK           reduce using rule 7 (statement2 -> for_statement .)
    CONTINUE        reduce using rule 7 (statement2 -> for_statement .)
    IF              reduce using rule 7 (statement2 -> for_statement .)
    WHILE           reduce using rule 7 (statement2 -> for_statement .)
    FUNCTION        reduce using rule 7 (statement2 -> for_statement .)
    CLASS           reduce using rule 7 (statement2 -> for_statement .)
    FSCANF          reduce using rule 7 (statement2 -> for_statement .)
    FGETS           reduce using rule 7 (statement2 -> for_statement .)
    RETURN          reduce using rule 7 (statement2 -> for_statement .)
    FOR             reduce using rule 7 (statement2 -> for_statement .)
    PRINT           reduce using rule 7 (statement2 -> for_statement .)
    ECHO            reduce using rule 7 (statement2 -> for_statement .)
    ID              reduce using rule 7 (statement2 -> for_statement .)
    NAME            reduce using rule 7 (statement2 -> for_statement .)
    INTEGER         reduce using rule 7 (statement2 -> for_statement .)
    FLOAT           reduce using rule 7 (statement2 -> for_statement .)
    LEFT_PAREN      reduce using rule 7 (statement2 -> for_statement .)
    TRUE            reduce using rule 7 (statement2 -> for_statement .)
    FALSE           reduce using rule 7 (statement2 -> for_statement .)
    LOGICAL_NOT     reduce using rule 7 (statement2 -> for_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement2 -> for_statement .)


state 9

    (8) statement2 -> function_statement .

    CLOSE_TAG       reduce using rule 8 (statement2 -> function_statement .)
    ONE_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    MULTI_LINE_COMMENT reduce using rule 8 (statement2 -> function_statement .)
    BREAK           reduce using rule 8 (statement2 -> function_statement .)
    CONTINUE        reduce using rule 8 (statement2 -> function_statement .)
    IF              reduce using rule 8 (statement2 -> function_statement .)
    WHILE           reduce using rule 8 (statement2 -> function_statement .)
    FUNCTION        reduce using rule 8 (statement2 -> function_statement .)
    CLASS           reduce using rule 8 (statement2 -> function_statement .)
    FSCANF          reduce using rule 8 (statement2 -> function_statement .)
    FGETS           reduce using rule 8 (statement2 -> function_statement .)
    RETURN          reduce using rule 8 (statement2 -> function_statement .)
    FOR             reduce using rule 8 (statement2 -> function_statement .)
    PRINT           reduce using rule 8 (statement2 -> function_statement .)
    ECHO            reduce using rule 8 (statement2 -> function_statement .)
    ID              reduce using rule 8 (statement2 -> function_statement .)
    NAME            reduce using rule 8 (statement2 -> function_statement .)
    INTEGER         reduce using rule 8 (statement2 -> function_statement .)
    FLOAT           reduce using rule 8 (statement2 -> function_statement .)
    LEFT_PAREN      reduce using rule 8 (statement2 -> function_statement .)
    TRUE            reduce using rule 8 (statement2 -> function_statement .)
    FALSE           reduce using rule 8 (statement2 -> function_statement .)
    LOGICAL_NOT     reduce using rule 8 (statement2 -> function_statement .)
    RIGHT_BRACE     reduce using rule 8 (statement2 -> function_statement .)


state 10

    (9) statement2 -> ONE_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    BREAK           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CONTINUE        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    IF              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    WHILE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FUNCTION        reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    CLASS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FSCANF          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FGETS           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RETURN          reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FOR             reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    PRINT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ECHO            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    ID              reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    NAME            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    INTEGER         reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FLOAT           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    LEFT_PAREN      reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    TRUE            reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    FALSE           reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    LOGICAL_NOT     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 9 (statement2 -> ONE_LINE_COMMENT .)


state 11

    (10) statement2 -> MULTI_LINE_COMMENT .

    CLOSE_TAG       reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    BREAK           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CONTINUE        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    IF              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    WHILE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FUNCTION        reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    CLASS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FSCANF          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FGETS           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RETURN          reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FOR             reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    PRINT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ECHO            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    ID              reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    NAME            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    INTEGER         reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FLOAT           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    LEFT_PAREN      reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    TRUE            reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    FALSE           reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    LOGICAL_NOT     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)
    RIGHT_BRACE     reduce using rule 10 (statement2 -> MULTI_LINE_COMMENT .)


state 12

    (11) statement2 -> class_declaration .

    CLOSE_TAG       reduce using rule 11 (statement2 -> class_declaration .)
    ONE_LINE_COMMENT reduce using rule 11 (statement2 -> class_declaration .)
    MULTI_LINE_COMMENT reduce using rule 11 (statement2 -> class_declaration .)
    BREAK           reduce using rule 11 (statement2 -> class_declaration .)
    CONTINUE        reduce using rule 11 (statement2 -> class_declaration .)
    IF              reduce using rule 11 (statement2 -> class_declaration .)
    WHILE           reduce using rule 11 (statement2 -> class_declaration .)
    FUNCTION        reduce using rule 11 (statement2 -> class_declaration .)
    CLASS           reduce using rule 11 (statement2 -> class_declaration .)
    FSCANF          reduce using rule 11 (statement2 -> class_declaration .)
    FGETS           reduce using rule 11 (statement2 -> class_declaration .)
    RETURN          reduce using rule 11 (statement2 -> class_declaration .)
    FOR             reduce using rule 11 (statement2 -> class_declaration .)
    PRINT           reduce using rule 11 (statement2 -> class_declaration .)
    ECHO            reduce using rule 11 (statement2 -> class_declaration .)
    ID              reduce using rule 11 (statement2 -> class_declaration .)
    NAME            reduce using rule 11 (statement2 -> class_declaration .)
    INTEGER         reduce using rule 11 (statement2 -> class_declaration .)
    FLOAT           reduce using rule 11 (statement2 -> class_declaration .)
    LEFT_PAREN      reduce using rule 11 (statement2 -> class_declaration .)
    TRUE            reduce using rule 11 (statement2 -> class_declaration .)
    FALSE           reduce using rule 11 (statement2 -> class_declaration .)
    LOGICAL_NOT     reduce using rule 11 (statement2 -> class_declaration .)
    RIGHT_BRACE     reduce using rule 11 (statement2 -> class_declaration .)


state 13

    (12) statement -> print_statement .

    SEMICOLON       reduce using rule 12 (statement -> print_statement .)
    RIGHT_PAREN     reduce using rule 12 (statement -> print_statement .)
    COMMA           reduce using rule 12 (statement -> print_statement .)


state 14

    (13) statement -> fscanf_statement .

    SEMICOLON       reduce using rule 13 (statement -> fscanf_statement .)
    RIGHT_PAREN     reduce using rule 13 (statement -> fscanf_statement .)
    COMMA           reduce using rule 13 (statement -> fscanf_statement .)


state 15

    (14) statement -> fgets_statement .

    SEMICOLON       reduce using rule 14 (statement -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 14 (statement -> fgets_statement .)
    COMMA           reduce using rule 14 (statement -> fgets_statement .)


state 16

    (15) statement -> assignment_statement .

    SEMICOLON       reduce using rule 15 (statement -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 15 (statement -> assignment_statement .)
    COMMA           reduce using rule 15 (statement -> assignment_statement .)


state 17

    (16) statement -> array_declaration_statement .

    SEMICOLON       reduce using rule 16 (statement -> array_declaration_statement .)
    RIGHT_PAREN     reduce using rule 16 (statement -> array_declaration_statement .)
    COMMA           reduce using rule 16 (statement -> array_declaration_statement .)


state 18

    (17) statement -> BREAK .

    SEMICOLON       reduce using rule 17 (statement -> BREAK .)
    RIGHT_PAREN     reduce using rule 17 (statement -> BREAK .)
    COMMA           reduce using rule 17 (statement -> BREAK .)


state 19

    (18) statement -> CONTINUE .

    SEMICOLON       reduce using rule 18 (statement -> CONTINUE .)
    RIGHT_PAREN     reduce using rule 18 (statement -> CONTINUE .)
    COMMA           reduce using rule 18 (statement -> CONTINUE .)


state 20

    (19) statement -> function_call .

    SEMICOLON       reduce using rule 19 (statement -> function_call .)
    RIGHT_PAREN     reduce using rule 19 (statement -> function_call .)
    COMMA           reduce using rule 19 (statement -> function_call .)


state 21

    (20) statement -> return_statement .

    SEMICOLON       reduce using rule 20 (statement -> return_statement .)
    RIGHT_PAREN     reduce using rule 20 (statement -> return_statement .)
    COMMA           reduce using rule 20 (statement -> return_statement .)


state 22

    (21) statement -> expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (110) relational_expression -> expression . relational_operator expression
    (111) relational_operator -> . EQUAL_TO
    (112) relational_operator -> . NOT_EQUAL_TO
    (113) relational_operator -> . LESS_THAN
    (114) relational_operator -> . GREATER_THAN
    (115) relational_operator -> . LESS_EQUAL
    (116) relational_operator -> . GREATER_EQUAL
    (117) relational_operator -> . IDENTICAL_TO
    (118) relational_operator -> . NOT_IDENTICAL_TO
    (119) relational_operator -> . DIFFERENT

    SEMICOLON       reduce using rule 21 (statement -> expression .)
    RIGHT_PAREN     reduce using rule 21 (statement -> expression .)
    COMMA           reduce using rule 21 (statement -> expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQUAL_TO        shift and go to state 59
    NOT_EQUAL_TO    shift and go to state 60
    LESS_THAN       shift and go to state 61
    GREATER_THAN    shift and go to state 62
    LESS_EQUAL      shift and go to state 63
    GREATER_EQUAL   shift and go to state 64
    IDENTICAL_TO    shift and go to state 65
    NOT_IDENTICAL_TO shift and go to state 66
    DIFFERENT       shift and go to state 67

    relational_operator            shift and go to state 58

state 23

    (76) if_statement -> IF . parenthesized_condition block
    (77) if_statement -> IF . parenthesized_condition block else_if_extended
    (78) if_statement -> IF . parenthesized_condition block else_if_extended if_part3
    (79) if_statement -> IF . parenthesized_condition block if_part3
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 69

    parenthesized_condition        shift and go to state 68

state 24

    (102) condition -> parenthesized_condition .

    LOGICAL_AND     reduce using rule 102 (condition -> parenthesized_condition .)
    LOGICAL_OR      reduce using rule 102 (condition -> parenthesized_condition .)
    LOGICAL_XOR     reduce using rule 102 (condition -> parenthesized_condition .)
    TIMES           reduce using rule 102 (condition -> parenthesized_condition .)
    DIVIDE          reduce using rule 102 (condition -> parenthesized_condition .)
    MOD             reduce using rule 102 (condition -> parenthesized_condition .)
    POWER           reduce using rule 102 (condition -> parenthesized_condition .)
    PLUS            reduce using rule 102 (condition -> parenthesized_condition .)
    MINUS           reduce using rule 102 (condition -> parenthesized_condition .)
    EQUAL_TO        reduce using rule 102 (condition -> parenthesized_condition .)
    NOT_EQUAL_TO    reduce using rule 102 (condition -> parenthesized_condition .)
    LESS_THAN       reduce using rule 102 (condition -> parenthesized_condition .)
    GREATER_THAN    reduce using rule 102 (condition -> parenthesized_condition .)
    LESS_EQUAL      reduce using rule 102 (condition -> parenthesized_condition .)
    GREATER_EQUAL   reduce using rule 102 (condition -> parenthesized_condition .)
    IDENTICAL_TO    reduce using rule 102 (condition -> parenthesized_condition .)
    NOT_IDENTICAL_TO reduce using rule 102 (condition -> parenthesized_condition .)
    DIFFERENT       reduce using rule 102 (condition -> parenthesized_condition .)
    SEMICOLON       reduce using rule 102 (condition -> parenthesized_condition .)
    RIGHT_PAREN     reduce using rule 102 (condition -> parenthesized_condition .)
    DOT             reduce using rule 102 (condition -> parenthesized_condition .)
    COMMA           reduce using rule 102 (condition -> parenthesized_condition .)
    RIGHT_BRACKET   reduce using rule 102 (condition -> parenthesized_condition .)


state 25

    (84) while_statement -> WHILE . parenthesized_condition block
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 69

    parenthesized_condition        shift and go to state 70

state 26

    (87) for_statement -> for_part1 . condition for_part3
    (88) for_statement -> for_part1 . for_part3
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (89) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (90) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN

    SEMICOLON       shift and go to state 73
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    ID              shift and go to state 42
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 71
    for_part3                      shift and go to state 72
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51
    expression                     shift and go to state 76
    term                           shift and go to state 38
    factor                         shift and go to state 43

state 27

    (74) factor -> condition .
    (108) complex_condition -> condition . logical_operator condition
    (120) logical_operator -> . LOGICAL_AND
    (121) logical_operator -> . LOGICAL_OR
    (122) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    TIMES           reduce using rule 74 (factor -> condition .)
    DIVIDE          reduce using rule 74 (factor -> condition .)
    MOD             reduce using rule 74 (factor -> condition .)
    POWER           reduce using rule 74 (factor -> condition .)
    PLUS            reduce using rule 74 (factor -> condition .)
    MINUS           reduce using rule 74 (factor -> condition .)
    EQUAL_TO        reduce using rule 74 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 74 (factor -> condition .)
    LESS_THAN       reduce using rule 74 (factor -> condition .)
    GREATER_THAN    reduce using rule 74 (factor -> condition .)
    LESS_EQUAL      reduce using rule 74 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 74 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 74 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 74 (factor -> condition .)
    DIFFERENT       reduce using rule 74 (factor -> condition .)
    SEMICOLON       reduce using rule 74 (factor -> condition .)
    DOT             reduce using rule 74 (factor -> condition .)
    COMMA           reduce using rule 74 (factor -> condition .)
    RIGHT_PAREN     reduce using rule 74 (factor -> condition .)
    RIGHT_BRACKET   reduce using rule 74 (factor -> condition .)
    LOGICAL_AND     shift and go to state 78
    LOGICAL_OR      shift and go to state 79
    LOGICAL_XOR     shift and go to state 80

  ! LOGICAL_AND     [ reduce using rule 74 (factor -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 74 (factor -> condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 74 (factor -> condition .) ]

    logical_operator               shift and go to state 77

state 28

    (22) function_statement -> FUNCTION . NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> FUNCTION . NAME LEFT_PAREN RIGHT_PAREN block

    NAME            shift and go to state 81


state 29

    (29) function_name -> NAME .

    LEFT_PAREN      reduce using rule 29 (function_name -> NAME .)


state 30

    (75) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (109) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression

    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 42

    expression                     shift and go to state 82
    condition                      shift and go to state 83
    term                           shift and go to state 38
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    factor                         shift and go to state 43
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 31

    (136) class_declaration -> CLASS . NAME LEFT_BRACE class_statements RIGHT_BRACE
    (137) class_declaration -> CLASS . NAME LEFT_BRACE RIGHT_BRACE

    NAME            shift and go to state 84


state 32

    (46) print_statement -> print_function . LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> print_function . arguments
    (50) arguments -> . argument
    (51) arguments -> . arguments DOT argument
    (52) arguments -> . arguments COMMA argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    LEFT_PAREN      shift and go to state 85
    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    arguments                      shift and go to state 86
    argument                       shift and go to state 87
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 33

    (32) fscanf_statement -> FSCANF . LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    LEFT_PAREN      shift and go to state 103


state 34

    (31) fgets_statement -> FGETS . LEFT_PAREN STDIN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 104


state 35

    (37) assignment_statement -> variable . assignment_operator argument
    (38) assignment_statement -> variable . PLUS_PLUS
    (39) assignment_statement -> variable . MINUS_MINUS
    (126) array_declaration_statement -> variable . EQUALS array
    (30) function_name -> variable .
    (105) simple_condition -> variable .
    (40) assignment_operator -> . EQUALS
    (41) assignment_operator -> . PLUS_EQUALS
    (42) assignment_operator -> . MINUS_EQUALS
    (43) assignment_operator -> . TIMES_EQUALS
    (44) assignment_operator -> . DIVIDE_EQUALS
    (45) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 106
    MINUS_MINUS     shift and go to state 107
    EQUALS          shift and go to state 108
    LEFT_PAREN      reduce using rule 30 (function_name -> variable .)
    LOGICAL_AND     reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 105 (simple_condition -> variable .)
    TIMES           reduce using rule 105 (simple_condition -> variable .)
    DIVIDE          reduce using rule 105 (simple_condition -> variable .)
    MOD             reduce using rule 105 (simple_condition -> variable .)
    POWER           reduce using rule 105 (simple_condition -> variable .)
    PLUS            reduce using rule 105 (simple_condition -> variable .)
    MINUS           reduce using rule 105 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 105 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 105 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 105 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 105 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 105 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 105 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 105 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 105 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 105 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 105 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 105 (simple_condition -> variable .)
    COMMA           reduce using rule 105 (simple_condition -> variable .)
    PLUS_EQUALS     shift and go to state 109
    MINUS_EQUALS    shift and go to state 110
    TIMES_EQUALS    shift and go to state 111
    DIVIDE_EQUALS   shift and go to state 112
    MOD_EQUALS      shift and go to state 113

    assignment_operator            shift and go to state 105

state 36

    (27) function_call -> function_name . LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> function_name . LEFT_PAREN RIGHT_PAREN

    LEFT_PAREN      shift and go to state 114


state 37

    (26) return_statement -> RETURN . arguments
    (50) arguments -> . argument
    (51) arguments -> . arguments DOT argument
    (52) arguments -> . arguments COMMA argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    arguments                      shift and go to state 115
    argument                       shift and go to state 87
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 38

    (66) expression -> term .
    (67) term -> term . TIMES factor
    (68) term -> term . DIVIDE factor
    (69) term -> term . MOD factor
    (70) term -> term . POWER factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    PLUS            reduce using rule 66 (expression -> term .)
    MINUS           reduce using rule 66 (expression -> term .)
    EQUAL_TO        reduce using rule 66 (expression -> term .)
    NOT_EQUAL_TO    reduce using rule 66 (expression -> term .)
    LESS_THAN       reduce using rule 66 (expression -> term .)
    GREATER_THAN    reduce using rule 66 (expression -> term .)
    LESS_EQUAL      reduce using rule 66 (expression -> term .)
    GREATER_EQUAL   reduce using rule 66 (expression -> term .)
    IDENTICAL_TO    reduce using rule 66 (expression -> term .)
    NOT_IDENTICAL_TO reduce using rule 66 (expression -> term .)
    DIFFERENT       reduce using rule 66 (expression -> term .)
    SEMICOLON       reduce using rule 66 (expression -> term .)
    RIGHT_PAREN     reduce using rule 66 (expression -> term .)
    DOT             reduce using rule 66 (expression -> term .)
    COMMA           reduce using rule 66 (expression -> term .)
    LOGICAL_AND     reduce using rule 66 (expression -> term .)
    LOGICAL_OR      reduce using rule 66 (expression -> term .)
    LOGICAL_XOR     reduce using rule 66 (expression -> term .)
    RIGHT_BRACKET   reduce using rule 66 (expression -> term .)
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    MOD             shift and go to state 119
    POWER           shift and go to state 120

  ! TIMES           [ reduce using rule 66 (expression -> term .) ]
  ! DIVIDE          [ reduce using rule 66 (expression -> term .) ]
  ! MOD             [ reduce using rule 66 (expression -> term .) ]
  ! POWER           [ reduce using rule 66 (expression -> term .) ]


state 39

    (85) for_part1 -> FOR . LEFT_PAREN assignment_list SEMICOLON
    (86) for_part1 -> FOR . LEFT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 121


state 40

    (48) print_function -> PRINT .

    LEFT_PAREN      reduce using rule 48 (print_function -> PRINT .)
    STRING          reduce using rule 48 (print_function -> PRINT .)
    ARRAY           reduce using rule 48 (print_function -> PRINT .)
    LEFT_BRACKET    reduce using rule 48 (print_function -> PRINT .)
    ID              reduce using rule 48 (print_function -> PRINT .)
    FUNCTION        reduce using rule 48 (print_function -> PRINT .)
    FGETS           reduce using rule 48 (print_function -> PRINT .)
    NEW             reduce using rule 48 (print_function -> PRINT .)
    NAME            reduce using rule 48 (print_function -> PRINT .)
    INTEGER         reduce using rule 48 (print_function -> PRINT .)
    FLOAT           reduce using rule 48 (print_function -> PRINT .)
    TRUE            reduce using rule 48 (print_function -> PRINT .)
    FALSE           reduce using rule 48 (print_function -> PRINT .)
    LOGICAL_NOT     reduce using rule 48 (print_function -> PRINT .)


state 41

    (49) print_function -> ECHO .

    LEFT_PAREN      reduce using rule 49 (print_function -> ECHO .)
    STRING          reduce using rule 49 (print_function -> ECHO .)
    ARRAY           reduce using rule 49 (print_function -> ECHO .)
    LEFT_BRACKET    reduce using rule 49 (print_function -> ECHO .)
    ID              reduce using rule 49 (print_function -> ECHO .)
    FUNCTION        reduce using rule 49 (print_function -> ECHO .)
    FGETS           reduce using rule 49 (print_function -> ECHO .)
    NEW             reduce using rule 49 (print_function -> ECHO .)
    NAME            reduce using rule 49 (print_function -> ECHO .)
    INTEGER         reduce using rule 49 (print_function -> ECHO .)
    FLOAT           reduce using rule 49 (print_function -> ECHO .)
    TRUE            reduce using rule 49 (print_function -> ECHO .)
    FALSE           reduce using rule 49 (print_function -> ECHO .)
    LOGICAL_NOT     reduce using rule 49 (print_function -> ECHO .)


state 42

    (35) variable -> ID .
    (36) variable -> ID . CALL NAME

  ! shift/reduce conflict for CALL resolved as shift
    PLUS_PLUS       reduce using rule 35 (variable -> ID .)
    MINUS_MINUS     reduce using rule 35 (variable -> ID .)
    EQUALS          reduce using rule 35 (variable -> ID .)
    PLUS_EQUALS     reduce using rule 35 (variable -> ID .)
    MINUS_EQUALS    reduce using rule 35 (variable -> ID .)
    TIMES_EQUALS    reduce using rule 35 (variable -> ID .)
    DIVIDE_EQUALS   reduce using rule 35 (variable -> ID .)
    MOD_EQUALS      reduce using rule 35 (variable -> ID .)
    LEFT_PAREN      reduce using rule 35 (variable -> ID .)
    LOGICAL_AND     reduce using rule 35 (variable -> ID .)
    LOGICAL_OR      reduce using rule 35 (variable -> ID .)
    LOGICAL_XOR     reduce using rule 35 (variable -> ID .)
    TIMES           reduce using rule 35 (variable -> ID .)
    DIVIDE          reduce using rule 35 (variable -> ID .)
    MOD             reduce using rule 35 (variable -> ID .)
    POWER           reduce using rule 35 (variable -> ID .)
    PLUS            reduce using rule 35 (variable -> ID .)
    MINUS           reduce using rule 35 (variable -> ID .)
    EQUAL_TO        reduce using rule 35 (variable -> ID .)
    NOT_EQUAL_TO    reduce using rule 35 (variable -> ID .)
    LESS_THAN       reduce using rule 35 (variable -> ID .)
    GREATER_THAN    reduce using rule 35 (variable -> ID .)
    LESS_EQUAL      reduce using rule 35 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 35 (variable -> ID .)
    IDENTICAL_TO    reduce using rule 35 (variable -> ID .)
    NOT_IDENTICAL_TO reduce using rule 35 (variable -> ID .)
    DIFFERENT       reduce using rule 35 (variable -> ID .)
    SEMICOLON       reduce using rule 35 (variable -> ID .)
    RIGHT_PAREN     reduce using rule 35 (variable -> ID .)
    LEFT_BRACKET    reduce using rule 35 (variable -> ID .)
    DOT             reduce using rule 35 (variable -> ID .)
    COMMA           reduce using rule 35 (variable -> ID .)
    RIGHT_BRACKET   reduce using rule 35 (variable -> ID .)
    CALL            shift and go to state 122

  ! CALL            [ reduce using rule 35 (variable -> ID .) ]


state 43

    (71) term -> factor .

    TIMES           reduce using rule 71 (term -> factor .)
    DIVIDE          reduce using rule 71 (term -> factor .)
    MOD             reduce using rule 71 (term -> factor .)
    POWER           reduce using rule 71 (term -> factor .)
    PLUS            reduce using rule 71 (term -> factor .)
    MINUS           reduce using rule 71 (term -> factor .)
    EQUAL_TO        reduce using rule 71 (term -> factor .)
    NOT_EQUAL_TO    reduce using rule 71 (term -> factor .)
    LESS_THAN       reduce using rule 71 (term -> factor .)
    GREATER_THAN    reduce using rule 71 (term -> factor .)
    LESS_EQUAL      reduce using rule 71 (term -> factor .)
    GREATER_EQUAL   reduce using rule 71 (term -> factor .)
    IDENTICAL_TO    reduce using rule 71 (term -> factor .)
    NOT_IDENTICAL_TO reduce using rule 71 (term -> factor .)
    DIFFERENT       reduce using rule 71 (term -> factor .)
    SEMICOLON       reduce using rule 71 (term -> factor .)
    RIGHT_PAREN     reduce using rule 71 (term -> factor .)
    DOT             reduce using rule 71 (term -> factor .)
    COMMA           reduce using rule 71 (term -> factor .)
    LOGICAL_AND     reduce using rule 71 (term -> factor .)
    LOGICAL_OR      reduce using rule 71 (term -> factor .)
    LOGICAL_XOR     reduce using rule 71 (term -> factor .)
    RIGHT_BRACKET   reduce using rule 71 (term -> factor .)


state 44

    (72) factor -> INTEGER .

    TIMES           reduce using rule 72 (factor -> INTEGER .)
    DIVIDE          reduce using rule 72 (factor -> INTEGER .)
    MOD             reduce using rule 72 (factor -> INTEGER .)
    POWER           reduce using rule 72 (factor -> INTEGER .)
    PLUS            reduce using rule 72 (factor -> INTEGER .)
    MINUS           reduce using rule 72 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 72 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 72 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 72 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 72 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 72 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 72 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 72 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 72 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 72 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 72 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 72 (factor -> INTEGER .)
    DOT             reduce using rule 72 (factor -> INTEGER .)
    COMMA           reduce using rule 72 (factor -> INTEGER .)
    LOGICAL_AND     reduce using rule 72 (factor -> INTEGER .)
    LOGICAL_OR      reduce using rule 72 (factor -> INTEGER .)
    LOGICAL_XOR     reduce using rule 72 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 72 (factor -> INTEGER .)


state 45

    (73) factor -> FLOAT .

    TIMES           reduce using rule 73 (factor -> FLOAT .)
    DIVIDE          reduce using rule 73 (factor -> FLOAT .)
    MOD             reduce using rule 73 (factor -> FLOAT .)
    POWER           reduce using rule 73 (factor -> FLOAT .)
    PLUS            reduce using rule 73 (factor -> FLOAT .)
    MINUS           reduce using rule 73 (factor -> FLOAT .)
    EQUAL_TO        reduce using rule 73 (factor -> FLOAT .)
    NOT_EQUAL_TO    reduce using rule 73 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 73 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 73 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 73 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 73 (factor -> FLOAT .)
    IDENTICAL_TO    reduce using rule 73 (factor -> FLOAT .)
    NOT_IDENTICAL_TO reduce using rule 73 (factor -> FLOAT .)
    DIFFERENT       reduce using rule 73 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 73 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 73 (factor -> FLOAT .)
    DOT             reduce using rule 73 (factor -> FLOAT .)
    COMMA           reduce using rule 73 (factor -> FLOAT .)
    LOGICAL_AND     reduce using rule 73 (factor -> FLOAT .)
    LOGICAL_OR      reduce using rule 73 (factor -> FLOAT .)
    LOGICAL_XOR     reduce using rule 73 (factor -> FLOAT .)
    RIGHT_BRACKET   reduce using rule 73 (factor -> FLOAT .)


state 46

    (99) condition -> simple_condition .

    LOGICAL_AND     reduce using rule 99 (condition -> simple_condition .)
    LOGICAL_OR      reduce using rule 99 (condition -> simple_condition .)
    LOGICAL_XOR     reduce using rule 99 (condition -> simple_condition .)
    TIMES           reduce using rule 99 (condition -> simple_condition .)
    DIVIDE          reduce using rule 99 (condition -> simple_condition .)
    MOD             reduce using rule 99 (condition -> simple_condition .)
    POWER           reduce using rule 99 (condition -> simple_condition .)
    PLUS            reduce using rule 99 (condition -> simple_condition .)
    MINUS           reduce using rule 99 (condition -> simple_condition .)
    EQUAL_TO        reduce using rule 99 (condition -> simple_condition .)
    NOT_EQUAL_TO    reduce using rule 99 (condition -> simple_condition .)
    LESS_THAN       reduce using rule 99 (condition -> simple_condition .)
    GREATER_THAN    reduce using rule 99 (condition -> simple_condition .)
    LESS_EQUAL      reduce using rule 99 (condition -> simple_condition .)
    GREATER_EQUAL   reduce using rule 99 (condition -> simple_condition .)
    IDENTICAL_TO    reduce using rule 99 (condition -> simple_condition .)
    NOT_IDENTICAL_TO reduce using rule 99 (condition -> simple_condition .)
    DIFFERENT       reduce using rule 99 (condition -> simple_condition .)
    SEMICOLON       reduce using rule 99 (condition -> simple_condition .)
    RIGHT_PAREN     reduce using rule 99 (condition -> simple_condition .)
    DOT             reduce using rule 99 (condition -> simple_condition .)
    COMMA           reduce using rule 99 (condition -> simple_condition .)
    RIGHT_BRACKET   reduce using rule 99 (condition -> simple_condition .)


state 47

    (100) condition -> negated_condition .

    LOGICAL_AND     reduce using rule 100 (condition -> negated_condition .)
    LOGICAL_OR      reduce using rule 100 (condition -> negated_condition .)
    LOGICAL_XOR     reduce using rule 100 (condition -> negated_condition .)
    TIMES           reduce using rule 100 (condition -> negated_condition .)
    DIVIDE          reduce using rule 100 (condition -> negated_condition .)
    MOD             reduce using rule 100 (condition -> negated_condition .)
    POWER           reduce using rule 100 (condition -> negated_condition .)
    PLUS            reduce using rule 100 (condition -> negated_condition .)
    MINUS           reduce using rule 100 (condition -> negated_condition .)
    EQUAL_TO        reduce using rule 100 (condition -> negated_condition .)
    NOT_EQUAL_TO    reduce using rule 100 (condition -> negated_condition .)
    LESS_THAN       reduce using rule 100 (condition -> negated_condition .)
    GREATER_THAN    reduce using rule 100 (condition -> negated_condition .)
    LESS_EQUAL      reduce using rule 100 (condition -> negated_condition .)
    GREATER_EQUAL   reduce using rule 100 (condition -> negated_condition .)
    IDENTICAL_TO    reduce using rule 100 (condition -> negated_condition .)
    NOT_IDENTICAL_TO reduce using rule 100 (condition -> negated_condition .)
    DIFFERENT       reduce using rule 100 (condition -> negated_condition .)
    SEMICOLON       reduce using rule 100 (condition -> negated_condition .)
    RIGHT_PAREN     reduce using rule 100 (condition -> negated_condition .)
    DOT             reduce using rule 100 (condition -> negated_condition .)
    COMMA           reduce using rule 100 (condition -> negated_condition .)
    RIGHT_BRACKET   reduce using rule 100 (condition -> negated_condition .)


state 48

    (101) condition -> complex_condition .

    LOGICAL_AND     reduce using rule 101 (condition -> complex_condition .)
    LOGICAL_OR      reduce using rule 101 (condition -> complex_condition .)
    LOGICAL_XOR     reduce using rule 101 (condition -> complex_condition .)
    TIMES           reduce using rule 101 (condition -> complex_condition .)
    DIVIDE          reduce using rule 101 (condition -> complex_condition .)
    MOD             reduce using rule 101 (condition -> complex_condition .)
    POWER           reduce using rule 101 (condition -> complex_condition .)
    PLUS            reduce using rule 101 (condition -> complex_condition .)
    MINUS           reduce using rule 101 (condition -> complex_condition .)
    EQUAL_TO        reduce using rule 101 (condition -> complex_condition .)
    NOT_EQUAL_TO    reduce using rule 101 (condition -> complex_condition .)
    LESS_THAN       reduce using rule 101 (condition -> complex_condition .)
    GREATER_THAN    reduce using rule 101 (condition -> complex_condition .)
    LESS_EQUAL      reduce using rule 101 (condition -> complex_condition .)
    GREATER_EQUAL   reduce using rule 101 (condition -> complex_condition .)
    IDENTICAL_TO    reduce using rule 101 (condition -> complex_condition .)
    NOT_IDENTICAL_TO reduce using rule 101 (condition -> complex_condition .)
    DIFFERENT       reduce using rule 101 (condition -> complex_condition .)
    SEMICOLON       reduce using rule 101 (condition -> complex_condition .)
    RIGHT_PAREN     reduce using rule 101 (condition -> complex_condition .)
    DOT             reduce using rule 101 (condition -> complex_condition .)
    COMMA           reduce using rule 101 (condition -> complex_condition .)
    RIGHT_BRACKET   reduce using rule 101 (condition -> complex_condition .)


state 49

    (103) simple_condition -> TRUE .

    LOGICAL_AND     reduce using rule 103 (simple_condition -> TRUE .)
    LOGICAL_OR      reduce using rule 103 (simple_condition -> TRUE .)
    LOGICAL_XOR     reduce using rule 103 (simple_condition -> TRUE .)
    TIMES           reduce using rule 103 (simple_condition -> TRUE .)
    DIVIDE          reduce using rule 103 (simple_condition -> TRUE .)
    MOD             reduce using rule 103 (simple_condition -> TRUE .)
    POWER           reduce using rule 103 (simple_condition -> TRUE .)
    PLUS            reduce using rule 103 (simple_condition -> TRUE .)
    MINUS           reduce using rule 103 (simple_condition -> TRUE .)
    EQUAL_TO        reduce using rule 103 (simple_condition -> TRUE .)
    NOT_EQUAL_TO    reduce using rule 103 (simple_condition -> TRUE .)
    LESS_THAN       reduce using rule 103 (simple_condition -> TRUE .)
    GREATER_THAN    reduce using rule 103 (simple_condition -> TRUE .)
    LESS_EQUAL      reduce using rule 103 (simple_condition -> TRUE .)
    GREATER_EQUAL   reduce using rule 103 (simple_condition -> TRUE .)
    IDENTICAL_TO    reduce using rule 103 (simple_condition -> TRUE .)
    NOT_IDENTICAL_TO reduce using rule 103 (simple_condition -> TRUE .)
    DIFFERENT       reduce using rule 103 (simple_condition -> TRUE .)
    SEMICOLON       reduce using rule 103 (simple_condition -> TRUE .)
    RIGHT_PAREN     reduce using rule 103 (simple_condition -> TRUE .)
    DOT             reduce using rule 103 (simple_condition -> TRUE .)
    COMMA           reduce using rule 103 (simple_condition -> TRUE .)
    RIGHT_BRACKET   reduce using rule 103 (simple_condition -> TRUE .)


state 50

    (104) simple_condition -> FALSE .

    LOGICAL_AND     reduce using rule 104 (simple_condition -> FALSE .)
    LOGICAL_OR      reduce using rule 104 (simple_condition -> FALSE .)
    LOGICAL_XOR     reduce using rule 104 (simple_condition -> FALSE .)
    TIMES           reduce using rule 104 (simple_condition -> FALSE .)
    DIVIDE          reduce using rule 104 (simple_condition -> FALSE .)
    MOD             reduce using rule 104 (simple_condition -> FALSE .)
    POWER           reduce using rule 104 (simple_condition -> FALSE .)
    PLUS            reduce using rule 104 (simple_condition -> FALSE .)
    MINUS           reduce using rule 104 (simple_condition -> FALSE .)
    EQUAL_TO        reduce using rule 104 (simple_condition -> FALSE .)
    NOT_EQUAL_TO    reduce using rule 104 (simple_condition -> FALSE .)
    LESS_THAN       reduce using rule 104 (simple_condition -> FALSE .)
    GREATER_THAN    reduce using rule 104 (simple_condition -> FALSE .)
    LESS_EQUAL      reduce using rule 104 (simple_condition -> FALSE .)
    GREATER_EQUAL   reduce using rule 104 (simple_condition -> FALSE .)
    IDENTICAL_TO    reduce using rule 104 (simple_condition -> FALSE .)
    NOT_IDENTICAL_TO reduce using rule 104 (simple_condition -> FALSE .)
    DIFFERENT       reduce using rule 104 (simple_condition -> FALSE .)
    SEMICOLON       reduce using rule 104 (simple_condition -> FALSE .)
    RIGHT_PAREN     reduce using rule 104 (simple_condition -> FALSE .)
    DOT             reduce using rule 104 (simple_condition -> FALSE .)
    COMMA           reduce using rule 104 (simple_condition -> FALSE .)
    RIGHT_BRACKET   reduce using rule 104 (simple_condition -> FALSE .)


state 51

    (106) simple_condition -> relational_expression .

    LOGICAL_AND     reduce using rule 106 (simple_condition -> relational_expression .)
    LOGICAL_OR      reduce using rule 106 (simple_condition -> relational_expression .)
    LOGICAL_XOR     reduce using rule 106 (simple_condition -> relational_expression .)
    TIMES           reduce using rule 106 (simple_condition -> relational_expression .)
    DIVIDE          reduce using rule 106 (simple_condition -> relational_expression .)
    MOD             reduce using rule 106 (simple_condition -> relational_expression .)
    POWER           reduce using rule 106 (simple_condition -> relational_expression .)
    PLUS            reduce using rule 106 (simple_condition -> relational_expression .)
    MINUS           reduce using rule 106 (simple_condition -> relational_expression .)
    EQUAL_TO        reduce using rule 106 (simple_condition -> relational_expression .)
    NOT_EQUAL_TO    reduce using rule 106 (simple_condition -> relational_expression .)
    LESS_THAN       reduce using rule 106 (simple_condition -> relational_expression .)
    GREATER_THAN    reduce using rule 106 (simple_condition -> relational_expression .)
    LESS_EQUAL      reduce using rule 106 (simple_condition -> relational_expression .)
    GREATER_EQUAL   reduce using rule 106 (simple_condition -> relational_expression .)
    IDENTICAL_TO    reduce using rule 106 (simple_condition -> relational_expression .)
    NOT_IDENTICAL_TO reduce using rule 106 (simple_condition -> relational_expression .)
    DIFFERENT       reduce using rule 106 (simple_condition -> relational_expression .)
    SEMICOLON       reduce using rule 106 (simple_condition -> relational_expression .)
    RIGHT_PAREN     reduce using rule 106 (simple_condition -> relational_expression .)
    DOT             reduce using rule 106 (simple_condition -> relational_expression .)
    COMMA           reduce using rule 106 (simple_condition -> relational_expression .)
    RIGHT_BRACKET   reduce using rule 106 (simple_condition -> relational_expression .)


state 52

    (107) negated_condition -> LOGICAL_NOT . condition
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    ID              shift and go to state 42
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 123
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51
    expression                     shift and go to state 76
    term                           shift and go to state 38
    factor                         shift and go to state 43

state 53

    (1) program -> OPEN_TAG statements CLOSE_TAG .

    $end            reduce using rule 1 (program -> OPEN_TAG statements CLOSE_TAG .)


state 54

    (3) statements -> statements statement2 .

    CLOSE_TAG       reduce using rule 3 (statements -> statements statement2 .)
    ONE_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    MULTI_LINE_COMMENT reduce using rule 3 (statements -> statements statement2 .)
    BREAK           reduce using rule 3 (statements -> statements statement2 .)
    CONTINUE        reduce using rule 3 (statements -> statements statement2 .)
    IF              reduce using rule 3 (statements -> statements statement2 .)
    WHILE           reduce using rule 3 (statements -> statements statement2 .)
    FUNCTION        reduce using rule 3 (statements -> statements statement2 .)
    CLASS           reduce using rule 3 (statements -> statements statement2 .)
    FSCANF          reduce using rule 3 (statements -> statements statement2 .)
    FGETS           reduce using rule 3 (statements -> statements statement2 .)
    RETURN          reduce using rule 3 (statements -> statements statement2 .)
    FOR             reduce using rule 3 (statements -> statements statement2 .)
    PRINT           reduce using rule 3 (statements -> statements statement2 .)
    ECHO            reduce using rule 3 (statements -> statements statement2 .)
    ID              reduce using rule 3 (statements -> statements statement2 .)
    NAME            reduce using rule 3 (statements -> statements statement2 .)
    INTEGER         reduce using rule 3 (statements -> statements statement2 .)
    FLOAT           reduce using rule 3 (statements -> statements statement2 .)
    LEFT_PAREN      reduce using rule 3 (statements -> statements statement2 .)
    TRUE            reduce using rule 3 (statements -> statements statement2 .)
    FALSE           reduce using rule 3 (statements -> statements statement2 .)
    LOGICAL_NOT     reduce using rule 3 (statements -> statements statement2 .)
    RIGHT_BRACE     reduce using rule 3 (statements -> statements statement2 .)


state 55

    (4) statement2 -> statement SEMICOLON .

    CLOSE_TAG       reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 4 (statement2 -> statement SEMICOLON .)
    BREAK           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    IF              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement2 -> statement SEMICOLON .)
    CLASS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FSCANF          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FGETS           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RETURN          reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FOR             reduce using rule 4 (statement2 -> statement SEMICOLON .)
    PRINT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ECHO            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    ID              reduce using rule 4 (statement2 -> statement SEMICOLON .)
    NAME            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    INTEGER         reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FLOAT           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    LEFT_PAREN      reduce using rule 4 (statement2 -> statement SEMICOLON .)
    TRUE            reduce using rule 4 (statement2 -> statement SEMICOLON .)
    FALSE           reduce using rule 4 (statement2 -> statement SEMICOLON .)
    LOGICAL_NOT     reduce using rule 4 (statement2 -> statement SEMICOLON .)
    RIGHT_BRACE     reduce using rule 4 (statement2 -> statement SEMICOLON .)


state 56

    (64) expression -> expression PLUS . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    expression                     shift and go to state 76
    term                           shift and go to state 124
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 57

    (65) expression -> expression MINUS . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    expression                     shift and go to state 76
    term                           shift and go to state 125
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 58

    (110) relational_expression -> expression relational_operator . expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    expression                     shift and go to state 126
    term                           shift and go to state 38
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 59

    (111) relational_operator -> EQUAL_TO .

    INTEGER         reduce using rule 111 (relational_operator -> EQUAL_TO .)
    FLOAT           reduce using rule 111 (relational_operator -> EQUAL_TO .)
    LEFT_PAREN      reduce using rule 111 (relational_operator -> EQUAL_TO .)
    TRUE            reduce using rule 111 (relational_operator -> EQUAL_TO .)
    FALSE           reduce using rule 111 (relational_operator -> EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 111 (relational_operator -> EQUAL_TO .)
    ID              reduce using rule 111 (relational_operator -> EQUAL_TO .)


state 60

    (112) relational_operator -> NOT_EQUAL_TO .

    INTEGER         reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)
    FLOAT           reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)
    LEFT_PAREN      reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)
    TRUE            reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)
    FALSE           reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)
    LOGICAL_NOT     reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)
    ID              reduce using rule 112 (relational_operator -> NOT_EQUAL_TO .)


state 61

    (113) relational_operator -> LESS_THAN .

    INTEGER         reduce using rule 113 (relational_operator -> LESS_THAN .)
    FLOAT           reduce using rule 113 (relational_operator -> LESS_THAN .)
    LEFT_PAREN      reduce using rule 113 (relational_operator -> LESS_THAN .)
    TRUE            reduce using rule 113 (relational_operator -> LESS_THAN .)
    FALSE           reduce using rule 113 (relational_operator -> LESS_THAN .)
    LOGICAL_NOT     reduce using rule 113 (relational_operator -> LESS_THAN .)
    ID              reduce using rule 113 (relational_operator -> LESS_THAN .)


state 62

    (114) relational_operator -> GREATER_THAN .

    INTEGER         reduce using rule 114 (relational_operator -> GREATER_THAN .)
    FLOAT           reduce using rule 114 (relational_operator -> GREATER_THAN .)
    LEFT_PAREN      reduce using rule 114 (relational_operator -> GREATER_THAN .)
    TRUE            reduce using rule 114 (relational_operator -> GREATER_THAN .)
    FALSE           reduce using rule 114 (relational_operator -> GREATER_THAN .)
    LOGICAL_NOT     reduce using rule 114 (relational_operator -> GREATER_THAN .)
    ID              reduce using rule 114 (relational_operator -> GREATER_THAN .)


state 63

    (115) relational_operator -> LESS_EQUAL .

    INTEGER         reduce using rule 115 (relational_operator -> LESS_EQUAL .)
    FLOAT           reduce using rule 115 (relational_operator -> LESS_EQUAL .)
    LEFT_PAREN      reduce using rule 115 (relational_operator -> LESS_EQUAL .)
    TRUE            reduce using rule 115 (relational_operator -> LESS_EQUAL .)
    FALSE           reduce using rule 115 (relational_operator -> LESS_EQUAL .)
    LOGICAL_NOT     reduce using rule 115 (relational_operator -> LESS_EQUAL .)
    ID              reduce using rule 115 (relational_operator -> LESS_EQUAL .)


state 64

    (116) relational_operator -> GREATER_EQUAL .

    INTEGER         reduce using rule 116 (relational_operator -> GREATER_EQUAL .)
    FLOAT           reduce using rule 116 (relational_operator -> GREATER_EQUAL .)
    LEFT_PAREN      reduce using rule 116 (relational_operator -> GREATER_EQUAL .)
    TRUE            reduce using rule 116 (relational_operator -> GREATER_EQUAL .)
    FALSE           reduce using rule 116 (relational_operator -> GREATER_EQUAL .)
    LOGICAL_NOT     reduce using rule 116 (relational_operator -> GREATER_EQUAL .)
    ID              reduce using rule 116 (relational_operator -> GREATER_EQUAL .)


state 65

    (117) relational_operator -> IDENTICAL_TO .

    INTEGER         reduce using rule 117 (relational_operator -> IDENTICAL_TO .)
    FLOAT           reduce using rule 117 (relational_operator -> IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 117 (relational_operator -> IDENTICAL_TO .)
    TRUE            reduce using rule 117 (relational_operator -> IDENTICAL_TO .)
    FALSE           reduce using rule 117 (relational_operator -> IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 117 (relational_operator -> IDENTICAL_TO .)
    ID              reduce using rule 117 (relational_operator -> IDENTICAL_TO .)


state 66

    (118) relational_operator -> NOT_IDENTICAL_TO .

    INTEGER         reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)
    FLOAT           reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)
    LEFT_PAREN      reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)
    TRUE            reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)
    FALSE           reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)
    LOGICAL_NOT     reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)
    ID              reduce using rule 118 (relational_operator -> NOT_IDENTICAL_TO .)


state 67

    (119) relational_operator -> DIFFERENT .

    INTEGER         reduce using rule 119 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 119 (relational_operator -> DIFFERENT .)
    LEFT_PAREN      reduce using rule 119 (relational_operator -> DIFFERENT .)
    TRUE            reduce using rule 119 (relational_operator -> DIFFERENT .)
    FALSE           reduce using rule 119 (relational_operator -> DIFFERENT .)
    LOGICAL_NOT     reduce using rule 119 (relational_operator -> DIFFERENT .)
    ID              reduce using rule 119 (relational_operator -> DIFFERENT .)


state 68

    (76) if_statement -> IF parenthesized_condition . block
    (77) if_statement -> IF parenthesized_condition . block else_if_extended
    (78) if_statement -> IF parenthesized_condition . block else_if_extended if_part3
    (79) if_statement -> IF parenthesized_condition . block if_part3
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 127

state 69

    (109) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    ID              shift and go to state 42
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 83
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51
    expression                     shift and go to state 76
    term                           shift and go to state 38
    factor                         shift and go to state 43

state 70

    (84) while_statement -> WHILE parenthesized_condition . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 129

state 71

    (87) for_statement -> for_part1 condition . for_part3
    (108) complex_condition -> condition . logical_operator condition
    (74) factor -> condition .
    (89) for_part3 -> . SEMICOLON statement_list RIGHT_PAREN for_part4
    (90) for_part3 -> . SEMICOLON RIGHT_PAREN for_part4
    (120) logical_operator -> . LOGICAL_AND
    (121) logical_operator -> . LOGICAL_OR
    (122) logical_operator -> . LOGICAL_XOR

    TIMES           reduce using rule 74 (factor -> condition .)
    DIVIDE          reduce using rule 74 (factor -> condition .)
    MOD             reduce using rule 74 (factor -> condition .)
    POWER           reduce using rule 74 (factor -> condition .)
    PLUS            reduce using rule 74 (factor -> condition .)
    MINUS           reduce using rule 74 (factor -> condition .)
    EQUAL_TO        reduce using rule 74 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 74 (factor -> condition .)
    LESS_THAN       reduce using rule 74 (factor -> condition .)
    GREATER_THAN    reduce using rule 74 (factor -> condition .)
    LESS_EQUAL      reduce using rule 74 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 74 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 74 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 74 (factor -> condition .)
    DIFFERENT       reduce using rule 74 (factor -> condition .)
    SEMICOLON       shift and go to state 73
    LOGICAL_AND     shift and go to state 78
    LOGICAL_OR      shift and go to state 79
    LOGICAL_XOR     shift and go to state 80

    for_part3                      shift and go to state 130
    logical_operator               shift and go to state 77

state 72

    (88) for_statement -> for_part1 for_part3 .

    CLOSE_TAG       reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    ONE_LINE_COMMENT reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    BREAK           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    CONTINUE        reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    IF              reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    WHILE           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    FUNCTION        reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    CLASS           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    FSCANF          reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    FGETS           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    RETURN          reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    FOR             reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    PRINT           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    ECHO            reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    ID              reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    NAME            reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    INTEGER         reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    FLOAT           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    LEFT_PAREN      reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    TRUE            reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    FALSE           reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    LOGICAL_NOT     reduce using rule 88 (for_statement -> for_part1 for_part3 .)
    RIGHT_BRACE     reduce using rule 88 (for_statement -> for_part1 for_part3 .)


state 73

    (89) for_part3 -> SEMICOLON . statement_list RIGHT_PAREN for_part4
    (90) for_part3 -> SEMICOLON . RIGHT_PAREN for_part4
    (95) statement_list -> . statement
    (96) statement_list -> . statement_list COMMA statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . expression
    (46) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> . print_function arguments
    (32) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (126) array_declaration_statement -> . variable EQUALS array
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (26) return_statement -> . RETURN arguments
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (48) print_function -> . PRINT
    (49) print_function -> . ECHO
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 132
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    RETURN          shift and go to state 37
    PRINT           shift and go to state 40
    ECHO            shift and go to state 41
    ID              shift and go to state 42
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    statement_list                 shift and go to state 131
    statement                      shift and go to state 133
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    expression                     shift and go to state 22
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    function_name                  shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 74

    (105) simple_condition -> variable .

    SEMICOLON       reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 105 (simple_condition -> variable .)
    TIMES           reduce using rule 105 (simple_condition -> variable .)
    DIVIDE          reduce using rule 105 (simple_condition -> variable .)
    MOD             reduce using rule 105 (simple_condition -> variable .)
    POWER           reduce using rule 105 (simple_condition -> variable .)
    PLUS            reduce using rule 105 (simple_condition -> variable .)
    MINUS           reduce using rule 105 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 105 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 105 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 105 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 105 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 105 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 105 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 105 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 105 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 105 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 105 (simple_condition -> variable .)
    DOT             reduce using rule 105 (simple_condition -> variable .)
    COMMA           reduce using rule 105 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 105 (simple_condition -> variable .)


state 75

    (109) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (75) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    ID              shift and go to state 42
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 83
    expression                     shift and go to state 82
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    term                           shift and go to state 38
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51
    factor                         shift and go to state 43

state 76

    (110) relational_expression -> expression . relational_operator expression
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (111) relational_operator -> . EQUAL_TO
    (112) relational_operator -> . NOT_EQUAL_TO
    (113) relational_operator -> . LESS_THAN
    (114) relational_operator -> . GREATER_THAN
    (115) relational_operator -> . LESS_EQUAL
    (116) relational_operator -> . GREATER_EQUAL
    (117) relational_operator -> . IDENTICAL_TO
    (118) relational_operator -> . NOT_IDENTICAL_TO
    (119) relational_operator -> . DIFFERENT

    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQUAL_TO        shift and go to state 59
    NOT_EQUAL_TO    shift and go to state 60
    LESS_THAN       shift and go to state 61
    GREATER_THAN    shift and go to state 62
    LESS_EQUAL      shift and go to state 63
    GREATER_EQUAL   shift and go to state 64
    IDENTICAL_TO    shift and go to state 65
    NOT_IDENTICAL_TO shift and go to state 66
    DIFFERENT       shift and go to state 67

    relational_operator            shift and go to state 58

state 77

    (108) complex_condition -> condition logical_operator . condition
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN

    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    ID              shift and go to state 42
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 134
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51
    expression                     shift and go to state 76
    term                           shift and go to state 38
    factor                         shift and go to state 43

state 78

    (120) logical_operator -> LOGICAL_AND .

    TRUE            reduce using rule 120 (logical_operator -> LOGICAL_AND .)
    FALSE           reduce using rule 120 (logical_operator -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 120 (logical_operator -> LOGICAL_AND .)
    LEFT_PAREN      reduce using rule 120 (logical_operator -> LOGICAL_AND .)
    ID              reduce using rule 120 (logical_operator -> LOGICAL_AND .)
    INTEGER         reduce using rule 120 (logical_operator -> LOGICAL_AND .)
    FLOAT           reduce using rule 120 (logical_operator -> LOGICAL_AND .)


state 79

    (121) logical_operator -> LOGICAL_OR .

    TRUE            reduce using rule 121 (logical_operator -> LOGICAL_OR .)
    FALSE           reduce using rule 121 (logical_operator -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 121 (logical_operator -> LOGICAL_OR .)
    LEFT_PAREN      reduce using rule 121 (logical_operator -> LOGICAL_OR .)
    ID              reduce using rule 121 (logical_operator -> LOGICAL_OR .)
    INTEGER         reduce using rule 121 (logical_operator -> LOGICAL_OR .)
    FLOAT           reduce using rule 121 (logical_operator -> LOGICAL_OR .)


state 80

    (122) logical_operator -> LOGICAL_XOR .

    TRUE            reduce using rule 122 (logical_operator -> LOGICAL_XOR .)
    FALSE           reduce using rule 122 (logical_operator -> LOGICAL_XOR .)
    LOGICAL_NOT     reduce using rule 122 (logical_operator -> LOGICAL_XOR .)
    LEFT_PAREN      reduce using rule 122 (logical_operator -> LOGICAL_XOR .)
    ID              reduce using rule 122 (logical_operator -> LOGICAL_XOR .)
    INTEGER         reduce using rule 122 (logical_operator -> LOGICAL_XOR .)
    FLOAT           reduce using rule 122 (logical_operator -> LOGICAL_XOR .)


state 81

    (22) function_statement -> FUNCTION NAME . LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> FUNCTION NAME . LEFT_PAREN RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 135


state 82

    (75) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (110) relational_expression -> expression . relational_operator expression
    (111) relational_operator -> . EQUAL_TO
    (112) relational_operator -> . NOT_EQUAL_TO
    (113) relational_operator -> . LESS_THAN
    (114) relational_operator -> . GREATER_THAN
    (115) relational_operator -> . LESS_EQUAL
    (116) relational_operator -> . GREATER_EQUAL
    (117) relational_operator -> . IDENTICAL_TO
    (118) relational_operator -> . NOT_IDENTICAL_TO
    (119) relational_operator -> . DIFFERENT

    RIGHT_PAREN     shift and go to state 136
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQUAL_TO        shift and go to state 59
    NOT_EQUAL_TO    shift and go to state 60
    LESS_THAN       shift and go to state 61
    GREATER_THAN    shift and go to state 62
    LESS_EQUAL      shift and go to state 63
    GREATER_EQUAL   shift and go to state 64
    IDENTICAL_TO    shift and go to state 65
    NOT_IDENTICAL_TO shift and go to state 66
    DIFFERENT       shift and go to state 67

    relational_operator            shift and go to state 58

state 83

    (109) parenthesized_condition -> LEFT_PAREN condition . RIGHT_PAREN
    (108) complex_condition -> condition . logical_operator condition
    (74) factor -> condition .
    (120) logical_operator -> . LOGICAL_AND
    (121) logical_operator -> . LOGICAL_OR
    (122) logical_operator -> . LOGICAL_XOR

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 137
    TIMES           reduce using rule 74 (factor -> condition .)
    DIVIDE          reduce using rule 74 (factor -> condition .)
    MOD             reduce using rule 74 (factor -> condition .)
    POWER           reduce using rule 74 (factor -> condition .)
    PLUS            reduce using rule 74 (factor -> condition .)
    MINUS           reduce using rule 74 (factor -> condition .)
    EQUAL_TO        reduce using rule 74 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 74 (factor -> condition .)
    LESS_THAN       reduce using rule 74 (factor -> condition .)
    GREATER_THAN    reduce using rule 74 (factor -> condition .)
    LESS_EQUAL      reduce using rule 74 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 74 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 74 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 74 (factor -> condition .)
    DIFFERENT       reduce using rule 74 (factor -> condition .)
    DOT             reduce using rule 74 (factor -> condition .)
    COMMA           reduce using rule 74 (factor -> condition .)
    LOGICAL_AND     shift and go to state 78
    LOGICAL_OR      shift and go to state 79
    LOGICAL_XOR     shift and go to state 80

  ! RIGHT_PAREN     [ reduce using rule 74 (factor -> condition .) ]

    logical_operator               shift and go to state 77

state 84

    (136) class_declaration -> CLASS NAME . LEFT_BRACE class_statements RIGHT_BRACE
    (137) class_declaration -> CLASS NAME . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 138


state 85

    (46) print_statement -> print_function LEFT_PAREN . arguments RIGHT_PAREN
    (123) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (75) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (109) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (50) arguments -> . argument
    (51) arguments -> . arguments DOT argument
    (52) arguments -> . arguments COMMA argument
    (124) casting_type -> . INT_TYPE
    (125) casting_type -> . FLOAT_TYPE
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression
    (29) function_name -> . NAME
    (30) function_name -> . variable

    INT_TYPE        shift and go to state 143
    FLOAT_TYPE      shift and go to state 144
    STRING          shift and go to state 88
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 139
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    NAME            shift and go to state 29

    arguments                      shift and go to state 140
    casting_type                   shift and go to state 141
    expression                     shift and go to state 142
    condition                      shift and go to state 83
    argument                       shift and go to state 87
    term                           shift and go to state 38
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 145
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    factor                         shift and go to state 43
    relational_expression          shift and go to state 51
    function_name                  shift and go to state 36

state 86

    (47) print_statement -> print_function arguments .
    (51) arguments -> arguments . DOT argument
    (52) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 47 (print_statement -> print_function arguments .)
    RIGHT_PAREN     reduce using rule 47 (print_statement -> print_function arguments .)
    DOT             shift and go to state 146
    COMMA           shift and go to state 147

  ! COMMA           [ reduce using rule 47 (print_statement -> print_function arguments .) ]


state 87

    (50) arguments -> argument .

    DOT             reduce using rule 50 (arguments -> argument .)
    COMMA           reduce using rule 50 (arguments -> argument .)
    SEMICOLON       reduce using rule 50 (arguments -> argument .)
    RIGHT_PAREN     reduce using rule 50 (arguments -> argument .)


state 88

    (53) argument -> STRING .

    DOT             reduce using rule 53 (argument -> STRING .)
    COMMA           reduce using rule 53 (argument -> STRING .)
    SEMICOLON       reduce using rule 53 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 53 (argument -> STRING .)
    RIGHT_BRACKET   reduce using rule 53 (argument -> STRING .)


state 89

    (54) argument -> expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (110) relational_expression -> expression . relational_operator expression
    (111) relational_operator -> . EQUAL_TO
    (112) relational_operator -> . NOT_EQUAL_TO
    (113) relational_operator -> . LESS_THAN
    (114) relational_operator -> . GREATER_THAN
    (115) relational_operator -> . LESS_EQUAL
    (116) relational_operator -> . GREATER_EQUAL
    (117) relational_operator -> . IDENTICAL_TO
    (118) relational_operator -> . NOT_IDENTICAL_TO
    (119) relational_operator -> . DIFFERENT

    DOT             reduce using rule 54 (argument -> expression .)
    COMMA           reduce using rule 54 (argument -> expression .)
    SEMICOLON       reduce using rule 54 (argument -> expression .)
    RIGHT_PAREN     reduce using rule 54 (argument -> expression .)
    RIGHT_BRACKET   reduce using rule 54 (argument -> expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQUAL_TO        shift and go to state 59
    NOT_EQUAL_TO    shift and go to state 60
    LESS_THAN       shift and go to state 61
    GREATER_THAN    shift and go to state 62
    LESS_EQUAL      shift and go to state 63
    GREATER_EQUAL   shift and go to state 64
    IDENTICAL_TO    shift and go to state 65
    NOT_IDENTICAL_TO shift and go to state 66
    DIFFERENT       shift and go to state 67

    relational_operator            shift and go to state 58

state 90

    (55) argument -> array .

    DOT             reduce using rule 55 (argument -> array .)
    COMMA           reduce using rule 55 (argument -> array .)
    SEMICOLON       reduce using rule 55 (argument -> array .)
    RIGHT_PAREN     reduce using rule 55 (argument -> array .)
    RIGHT_BRACKET   reduce using rule 55 (argument -> array .)


state 91

    (56) argument -> array_indexing .

    DOT             reduce using rule 56 (argument -> array_indexing .)
    COMMA           reduce using rule 56 (argument -> array_indexing .)
    SEMICOLON       reduce using rule 56 (argument -> array_indexing .)
    RIGHT_PAREN     reduce using rule 56 (argument -> array_indexing .)
    RIGHT_BRACKET   reduce using rule 56 (argument -> array_indexing .)


state 92

    (57) argument -> function_call .

    DOT             reduce using rule 57 (argument -> function_call .)
    COMMA           reduce using rule 57 (argument -> function_call .)
    SEMICOLON       reduce using rule 57 (argument -> function_call .)
    RIGHT_PAREN     reduce using rule 57 (argument -> function_call .)
    RIGHT_BRACKET   reduce using rule 57 (argument -> function_call .)


state 93

    (58) argument -> variable . CALL function_call
    (135) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (37) assignment_statement -> variable . assignment_operator argument
    (38) assignment_statement -> variable . PLUS_PLUS
    (39) assignment_statement -> variable . MINUS_MINUS
    (30) function_name -> variable .
    (105) simple_condition -> variable .
    (40) assignment_operator -> . EQUALS
    (41) assignment_operator -> . PLUS_EQUALS
    (42) assignment_operator -> . MINUS_EQUALS
    (43) assignment_operator -> . TIMES_EQUALS
    (44) assignment_operator -> . DIVIDE_EQUALS
    (45) assignment_operator -> . MOD_EQUALS

    CALL            shift and go to state 148
    LEFT_BRACKET    shift and go to state 149
    PLUS_PLUS       shift and go to state 106
    MINUS_MINUS     shift and go to state 107
    LEFT_PAREN      reduce using rule 30 (function_name -> variable .)
    LOGICAL_AND     reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 105 (simple_condition -> variable .)
    TIMES           reduce using rule 105 (simple_condition -> variable .)
    DIVIDE          reduce using rule 105 (simple_condition -> variable .)
    MOD             reduce using rule 105 (simple_condition -> variable .)
    POWER           reduce using rule 105 (simple_condition -> variable .)
    PLUS            reduce using rule 105 (simple_condition -> variable .)
    MINUS           reduce using rule 105 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 105 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 105 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 105 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 105 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 105 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 105 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 105 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 105 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 105 (simple_condition -> variable .)
    DOT             reduce using rule 105 (simple_condition -> variable .)
    COMMA           reduce using rule 105 (simple_condition -> variable .)
    SEMICOLON       reduce using rule 105 (simple_condition -> variable .)
    RIGHT_PAREN     reduce using rule 105 (simple_condition -> variable .)
    RIGHT_BRACKET   reduce using rule 105 (simple_condition -> variable .)
    EQUALS          shift and go to state 150
    PLUS_EQUALS     shift and go to state 109
    MINUS_EQUALS    shift and go to state 110
    TIMES_EQUALS    shift and go to state 111
    DIVIDE_EQUALS   shift and go to state 112
    MOD_EQUALS      shift and go to state 113

    assignment_operator            shift and go to state 105

state 94

    (59) argument -> anonymous_function .

    DOT             reduce using rule 59 (argument -> anonymous_function .)
    COMMA           reduce using rule 59 (argument -> anonymous_function .)
    SEMICOLON       reduce using rule 59 (argument -> anonymous_function .)
    RIGHT_PAREN     reduce using rule 59 (argument -> anonymous_function .)
    RIGHT_BRACKET   reduce using rule 59 (argument -> anonymous_function .)


state 95

    (60) argument -> assignment_statement .

    DOT             reduce using rule 60 (argument -> assignment_statement .)
    COMMA           reduce using rule 60 (argument -> assignment_statement .)
    SEMICOLON       reduce using rule 60 (argument -> assignment_statement .)
    RIGHT_PAREN     reduce using rule 60 (argument -> assignment_statement .)
    RIGHT_BRACKET   reduce using rule 60 (argument -> assignment_statement .)


state 96

    (61) argument -> fgets_statement .

    DOT             reduce using rule 61 (argument -> fgets_statement .)
    COMMA           reduce using rule 61 (argument -> fgets_statement .)
    SEMICOLON       reduce using rule 61 (argument -> fgets_statement .)
    RIGHT_PAREN     reduce using rule 61 (argument -> fgets_statement .)
    RIGHT_BRACKET   reduce using rule 61 (argument -> fgets_statement .)


state 97

    (62) argument -> object_creation .

    DOT             reduce using rule 62 (argument -> object_creation .)
    COMMA           reduce using rule 62 (argument -> object_creation .)
    SEMICOLON       reduce using rule 62 (argument -> object_creation .)
    RIGHT_PAREN     reduce using rule 62 (argument -> object_creation .)
    RIGHT_BRACKET   reduce using rule 62 (argument -> object_creation .)


state 98

    (63) argument -> casting . argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    casting                        shift and go to state 98
    argument                       shift and go to state 151
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 99

    (127) array -> ARRAY . LEFT_PAREN array_elements RIGHT_PAREN

    LEFT_PAREN      shift and go to state 152


state 100

    (128) array -> LEFT_BRACKET . array_elements RIGHT_BRACKET
    (129) array_elements -> . array_argument
    (130) array_elements -> . array_elements COMMA array_argument
    (131) array_argument -> . argument
    (132) array_argument -> . clave KEY_VALUE argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (133) clave -> . STRING
    (134) clave -> . INTEGER
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 157
    INTEGER         shift and go to state 158
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    array_elements                 shift and go to state 153
    array_argument                 shift and go to state 154
    argument                       shift and go to state 155
    clave                          shift and go to state 156
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 101

    (24) anonymous_function -> FUNCTION . LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> FUNCTION . LEFT_PAREN RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 159


state 102

    (149) object_creation -> NEW . NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> NEW . NAME LEFT_PAREN arguments RIGHT_PAREN

    NAME            shift and go to state 160


state 103

    (32) fscanf_statement -> FSCANF LEFT_PAREN . STDIN COMMA STRING COMMA variable_list RIGHT_PAREN

    STDIN           shift and go to state 161


state 104

    (31) fgets_statement -> FGETS LEFT_PAREN . STDIN RIGHT_PAREN

    STDIN           shift and go to state 162


state 105

    (37) assignment_statement -> variable assignment_operator . argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    variable                       shift and go to state 93
    argument                       shift and go to state 163
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 106

    (38) assignment_statement -> variable PLUS_PLUS .

    SEMICOLON       reduce using rule 38 (assignment_statement -> variable PLUS_PLUS .)
    DOT             reduce using rule 38 (assignment_statement -> variable PLUS_PLUS .)
    COMMA           reduce using rule 38 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_PAREN     reduce using rule 38 (assignment_statement -> variable PLUS_PLUS .)
    RIGHT_BRACKET   reduce using rule 38 (assignment_statement -> variable PLUS_PLUS .)


state 107

    (39) assignment_statement -> variable MINUS_MINUS .

    SEMICOLON       reduce using rule 39 (assignment_statement -> variable MINUS_MINUS .)
    DOT             reduce using rule 39 (assignment_statement -> variable MINUS_MINUS .)
    COMMA           reduce using rule 39 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_PAREN     reduce using rule 39 (assignment_statement -> variable MINUS_MINUS .)
    RIGHT_BRACKET   reduce using rule 39 (assignment_statement -> variable MINUS_MINUS .)


state 108

    (126) array_declaration_statement -> variable EQUALS . array
    (40) assignment_operator -> EQUALS .
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET

  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for LEFT_BRACKET resolved as shift
    STRING          reduce using rule 40 (assignment_operator -> EQUALS .)
    ID              reduce using rule 40 (assignment_operator -> EQUALS .)
    FUNCTION        reduce using rule 40 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 40 (assignment_operator -> EQUALS .)
    NEW             reduce using rule 40 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 40 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 40 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 40 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 40 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 40 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 40 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 40 (assignment_operator -> EQUALS .)
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100

  ! ARRAY           [ reduce using rule 40 (assignment_operator -> EQUALS .) ]
  ! LEFT_BRACKET    [ reduce using rule 40 (assignment_operator -> EQUALS .) ]

    array                          shift and go to state 164

state 109

    (41) assignment_operator -> PLUS_EQUALS .

    STRING          reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    ARRAY           reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    LEFT_BRACKET    reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    ID              reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    FUNCTION        reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    FGETS           reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    NEW             reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    LEFT_PAREN      reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    NAME            reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    INTEGER         reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    FLOAT           reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    TRUE            reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    FALSE           reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 41 (assignment_operator -> PLUS_EQUALS .)


state 110

    (42) assignment_operator -> MINUS_EQUALS .

    STRING          reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    ARRAY           reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    LEFT_BRACKET    reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    ID              reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    FUNCTION        reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    FGETS           reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    NEW             reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    LEFT_PAREN      reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    NAME            reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    INTEGER         reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    FLOAT           reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    TRUE            reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    FALSE           reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)
    LOGICAL_NOT     reduce using rule 42 (assignment_operator -> MINUS_EQUALS .)


state 111

    (43) assignment_operator -> TIMES_EQUALS .

    STRING          reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    ARRAY           reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    LEFT_BRACKET    reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    ID              reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    FUNCTION        reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    FGETS           reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    NEW             reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    LEFT_PAREN      reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    NAME            reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    INTEGER         reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    FLOAT           reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    TRUE            reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    FALSE           reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)
    LOGICAL_NOT     reduce using rule 43 (assignment_operator -> TIMES_EQUALS .)


state 112

    (44) assignment_operator -> DIVIDE_EQUALS .

    STRING          reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    ARRAY           reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_BRACKET    reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    ID              reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    FUNCTION        reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    FGETS           reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    NEW             reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    LEFT_PAREN      reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    NAME            reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    INTEGER         reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    FLOAT           reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    TRUE            reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    FALSE           reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)
    LOGICAL_NOT     reduce using rule 44 (assignment_operator -> DIVIDE_EQUALS .)


state 113

    (45) assignment_operator -> MOD_EQUALS .

    STRING          reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    ARRAY           reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    LEFT_BRACKET    reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    ID              reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    FUNCTION        reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    FGETS           reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    NEW             reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    LEFT_PAREN      reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    NAME            reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    INTEGER         reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    FLOAT           reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    TRUE            reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    FALSE           reduce using rule 45 (assignment_operator -> MOD_EQUALS .)
    LOGICAL_NOT     reduce using rule 45 (assignment_operator -> MOD_EQUALS .)


state 114

    (27) function_call -> function_name LEFT_PAREN . arguments RIGHT_PAREN
    (28) function_call -> function_name LEFT_PAREN . RIGHT_PAREN
    (50) arguments -> . argument
    (51) arguments -> . arguments DOT argument
    (52) arguments -> . arguments COMMA argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 166
    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    function_name                  shift and go to state 36
    arguments                      shift and go to state 165
    argument                       shift and go to state 87
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 115

    (26) return_statement -> RETURN arguments .
    (51) arguments -> arguments . DOT argument
    (52) arguments -> arguments . COMMA argument

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 26 (return_statement -> RETURN arguments .)
    RIGHT_PAREN     reduce using rule 26 (return_statement -> RETURN arguments .)
    DOT             shift and go to state 146
    COMMA           shift and go to state 147

  ! COMMA           [ reduce using rule 26 (return_statement -> RETURN arguments .) ]


state 116

    (123) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (75) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (109) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (124) casting_type -> . INT_TYPE
    (125) casting_type -> . FLOAT_TYPE
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression

    INT_TYPE        shift and go to state 143
    FLOAT_TYPE      shift and go to state 144
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    ID              shift and go to state 42

    casting_type                   shift and go to state 141
    expression                     shift and go to state 82
    condition                      shift and go to state 83
    term                           shift and go to state 38
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    factor                         shift and go to state 43
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 117

    (67) term -> term TIMES . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    term                           shift and go to state 38
    factor                         shift and go to state 167
    condition                      shift and go to state 27
    expression                     shift and go to state 76
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 118

    (68) term -> term DIVIDE . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    term                           shift and go to state 38
    factor                         shift and go to state 168
    condition                      shift and go to state 27
    expression                     shift and go to state 76
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 119

    (69) term -> term MOD . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    term                           shift and go to state 38
    factor                         shift and go to state 169
    condition                      shift and go to state 27
    expression                     shift and go to state 76
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 120

    (70) term -> term POWER . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    ID              shift and go to state 42

    term                           shift and go to state 38
    factor                         shift and go to state 170
    condition                      shift and go to state 27
    expression                     shift and go to state 76
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51

state 121

    (85) for_part1 -> FOR LEFT_PAREN . assignment_list SEMICOLON
    (86) for_part1 -> FOR LEFT_PAREN . SEMICOLON
    (93) assignment_list -> . assignment_statement
    (94) assignment_list -> . assignment_list COMMA assignment_statement
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME

    SEMICOLON       shift and go to state 172
    ID              shift and go to state 42

    assignment_list                shift and go to state 171
    assignment_statement           shift and go to state 173
    variable                       shift and go to state 174

state 122

    (36) variable -> ID CALL . NAME

    NAME            shift and go to state 175


state 123

    (107) negated_condition -> LOGICAL_NOT condition .
    (108) complex_condition -> condition . logical_operator condition
    (74) factor -> condition .
    (120) logical_operator -> . LOGICAL_AND
    (121) logical_operator -> . LOGICAL_OR
    (122) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for MOD resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 74 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_PAREN     reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .)
    DOT             reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .)
    COMMA           reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .)
    RIGHT_BRACKET   reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .)
    TIMES           reduce using rule 74 (factor -> condition .)
    DIVIDE          reduce using rule 74 (factor -> condition .)
    MOD             reduce using rule 74 (factor -> condition .)
    POWER           reduce using rule 74 (factor -> condition .)
    PLUS            reduce using rule 74 (factor -> condition .)
    MINUS           reduce using rule 74 (factor -> condition .)
    EQUAL_TO        reduce using rule 74 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 74 (factor -> condition .)
    LESS_THAN       reduce using rule 74 (factor -> condition .)
    GREATER_THAN    reduce using rule 74 (factor -> condition .)
    LESS_EQUAL      reduce using rule 74 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 74 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 74 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 74 (factor -> condition .)
    DIFFERENT       reduce using rule 74 (factor -> condition .)
    LOGICAL_AND     shift and go to state 78
    LOGICAL_OR      shift and go to state 79
    LOGICAL_XOR     shift and go to state 80

  ! LOGICAL_AND     [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! TIMES           [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIVIDE          [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MOD             [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! POWER           [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! PLUS            [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! MINUS           [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! EQUAL_TO        [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_THAN       [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_THAN    [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]
  ! DIFFERENT       [ reduce using rule 107 (negated_condition -> LOGICAL_NOT condition .) ]

    logical_operator               shift and go to state 77

state 124

    (64) expression -> expression PLUS term .
    (67) term -> term . TIMES factor
    (68) term -> term . DIVIDE factor
    (69) term -> term . MOD factor
    (70) term -> term . POWER factor
    (66) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 64 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 64 (expression -> expression PLUS term .)
    PLUS            reduce using rule 64 (expression -> expression PLUS term .)
    MINUS           reduce using rule 64 (expression -> expression PLUS term .)
    EQUAL_TO        reduce using rule 64 (expression -> expression PLUS term .)
    NOT_EQUAL_TO    reduce using rule 64 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 64 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 64 (expression -> expression PLUS term .)
    LESS_EQUAL      reduce using rule 64 (expression -> expression PLUS term .)
    GREATER_EQUAL   reduce using rule 64 (expression -> expression PLUS term .)
    IDENTICAL_TO    reduce using rule 64 (expression -> expression PLUS term .)
    NOT_IDENTICAL_TO reduce using rule 64 (expression -> expression PLUS term .)
    DIFFERENT       reduce using rule 64 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 64 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 64 (expression -> expression PLUS term .)
    DOT             reduce using rule 64 (expression -> expression PLUS term .)
    COMMA           reduce using rule 64 (expression -> expression PLUS term .)
    LOGICAL_AND     reduce using rule 64 (expression -> expression PLUS term .)
    LOGICAL_OR      reduce using rule 64 (expression -> expression PLUS term .)
    LOGICAL_XOR     reduce using rule 64 (expression -> expression PLUS term .)
    RIGHT_BRACKET   reduce using rule 64 (expression -> expression PLUS term .)
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    MOD             shift and go to state 119
    POWER           shift and go to state 120

  ! TIMES           [ reduce using rule 64 (expression -> expression PLUS term .) ]
  ! DIVIDE          [ reduce using rule 64 (expression -> expression PLUS term .) ]
  ! MOD             [ reduce using rule 64 (expression -> expression PLUS term .) ]
  ! POWER           [ reduce using rule 64 (expression -> expression PLUS term .) ]
  ! PLUS            [ reduce using rule 66 (expression -> term .) ]
  ! MINUS           [ reduce using rule 66 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 66 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 66 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 66 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 66 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 66 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 66 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 66 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 66 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 66 (expression -> term .) ]


state 125

    (65) expression -> expression MINUS term .
    (67) term -> term . TIMES factor
    (68) term -> term . DIVIDE factor
    (69) term -> term . MOD factor
    (70) term -> term . POWER factor
    (66) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 65 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 65 (expression -> expression MINUS term .)
    PLUS            reduce using rule 65 (expression -> expression MINUS term .)
    MINUS           reduce using rule 65 (expression -> expression MINUS term .)
    EQUAL_TO        reduce using rule 65 (expression -> expression MINUS term .)
    NOT_EQUAL_TO    reduce using rule 65 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 65 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 65 (expression -> expression MINUS term .)
    LESS_EQUAL      reduce using rule 65 (expression -> expression MINUS term .)
    GREATER_EQUAL   reduce using rule 65 (expression -> expression MINUS term .)
    IDENTICAL_TO    reduce using rule 65 (expression -> expression MINUS term .)
    NOT_IDENTICAL_TO reduce using rule 65 (expression -> expression MINUS term .)
    DIFFERENT       reduce using rule 65 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 65 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 65 (expression -> expression MINUS term .)
    DOT             reduce using rule 65 (expression -> expression MINUS term .)
    COMMA           reduce using rule 65 (expression -> expression MINUS term .)
    LOGICAL_AND     reduce using rule 65 (expression -> expression MINUS term .)
    LOGICAL_OR      reduce using rule 65 (expression -> expression MINUS term .)
    LOGICAL_XOR     reduce using rule 65 (expression -> expression MINUS term .)
    RIGHT_BRACKET   reduce using rule 65 (expression -> expression MINUS term .)
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    MOD             shift and go to state 119
    POWER           shift and go to state 120

  ! TIMES           [ reduce using rule 65 (expression -> expression MINUS term .) ]
  ! DIVIDE          [ reduce using rule 65 (expression -> expression MINUS term .) ]
  ! MOD             [ reduce using rule 65 (expression -> expression MINUS term .) ]
  ! POWER           [ reduce using rule 65 (expression -> expression MINUS term .) ]
  ! PLUS            [ reduce using rule 66 (expression -> term .) ]
  ! MINUS           [ reduce using rule 66 (expression -> term .) ]
  ! EQUAL_TO        [ reduce using rule 66 (expression -> term .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 66 (expression -> term .) ]
  ! LESS_THAN       [ reduce using rule 66 (expression -> term .) ]
  ! GREATER_THAN    [ reduce using rule 66 (expression -> term .) ]
  ! LESS_EQUAL      [ reduce using rule 66 (expression -> term .) ]
  ! GREATER_EQUAL   [ reduce using rule 66 (expression -> term .) ]
  ! IDENTICAL_TO    [ reduce using rule 66 (expression -> term .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 66 (expression -> term .) ]
  ! DIFFERENT       [ reduce using rule 66 (expression -> term .) ]


state 126

    (110) relational_expression -> expression relational_operator expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (110) relational_expression -> expression . relational_operator expression
    (111) relational_operator -> . EQUAL_TO
    (112) relational_operator -> . NOT_EQUAL_TO
    (113) relational_operator -> . LESS_THAN
    (114) relational_operator -> . GREATER_THAN
    (115) relational_operator -> . LESS_EQUAL
    (116) relational_operator -> . GREATER_EQUAL
    (117) relational_operator -> . IDENTICAL_TO
    (118) relational_operator -> . NOT_IDENTICAL_TO
    (119) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL_TO resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for NOT_IDENTICAL_TO resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    LOGICAL_AND     reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    LOGICAL_OR      reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    LOGICAL_XOR     reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    TIMES           reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    DIVIDE          reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    MOD             reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    POWER           reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    SEMICOLON       reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    RIGHT_PAREN     reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    DOT             reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    COMMA           reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    RIGHT_BRACKET   reduce using rule 110 (relational_expression -> expression relational_operator expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQUAL_TO        shift and go to state 59
    NOT_EQUAL_TO    shift and go to state 60
    LESS_THAN       shift and go to state 61
    GREATER_THAN    shift and go to state 62
    LESS_EQUAL      shift and go to state 63
    GREATER_EQUAL   shift and go to state 64
    IDENTICAL_TO    shift and go to state 65
    NOT_IDENTICAL_TO shift and go to state 66
    DIFFERENT       shift and go to state 67

  ! PLUS            [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! MINUS           [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! EQUAL_TO        [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_THAN       [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_THAN    [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! IDENTICAL_TO    [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]
  ! DIFFERENT       [ reduce using rule 110 (relational_expression -> expression relational_operator expression .) ]

    relational_operator            shift and go to state 58

state 127

    (76) if_statement -> IF parenthesized_condition block .
    (77) if_statement -> IF parenthesized_condition block . else_if_extended
    (78) if_statement -> IF parenthesized_condition block . else_if_extended if_part3
    (79) if_statement -> IF parenthesized_condition block . if_part3
    (80) else_if_extended -> . if_part2
    (81) else_if_extended -> . else_if_extended if_part2
    (83) if_part3 -> . ELSE block
    (82) if_part2 -> . ELSEIF parenthesized_condition block

    CLOSE_TAG       reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    BREAK           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    CONTINUE        reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    IF              reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    WHILE           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    FUNCTION        reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    CLASS           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    FSCANF          reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    FGETS           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    RETURN          reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    FOR             reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    PRINT           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    ECHO            reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    ID              reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    NAME            reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    INTEGER         reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    FLOAT           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    TRUE            reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    FALSE           reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 76 (if_statement -> IF parenthesized_condition block .)
    ELSE            shift and go to state 179
    ELSEIF          shift and go to state 180

    else_if_extended               shift and go to state 176
    if_part3                       shift and go to state 177
    if_part2                       shift and go to state 178

state 128

    (97) block -> LEFT_BRACE . statements RIGHT_BRACE
    (98) block -> LEFT_BRACE . RIGHT_BRACE
    (2) statements -> . statement2
    (3) statements -> . statements statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . expression
    (76) if_statement -> . IF parenthesized_condition block
    (77) if_statement -> . IF parenthesized_condition block else_if_extended
    (78) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (79) if_statement -> . IF parenthesized_condition block if_part3
    (84) while_statement -> . WHILE parenthesized_condition block
    (87) for_statement -> . for_part1 condition for_part3
    (88) for_statement -> . for_part1 for_part3
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (136) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (137) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (46) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> . print_function arguments
    (32) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (126) array_declaration_statement -> . variable EQUALS array
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (26) return_statement -> . RETURN arguments
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (85) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (86) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (48) print_function -> . PRINT
    (49) print_function -> . ECHO
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_BRACE     shift and go to state 182
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 23
    WHILE           shift and go to state 25
    FUNCTION        shift and go to state 28
    CLASS           shift and go to state 31
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    RETURN          shift and go to state 37
    FOR             shift and go to state 39
    PRINT           shift and go to state 40
    ECHO            shift and go to state 41
    ID              shift and go to state 42
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    statements                     shift and go to state 181
    statement2                     shift and go to state 4
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    expression                     shift and go to state 22
    parenthesized_condition        shift and go to state 24
    for_part1                      shift and go to state 26
    condition                      shift and go to state 27
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    function_name                  shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 43
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    relational_expression          shift and go to state 51

state 129

    (84) while_statement -> WHILE parenthesized_condition block .

    CLOSE_TAG       reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    BREAK           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    CONTINUE        reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    IF              reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    WHILE           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    FUNCTION        reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    CLASS           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    FSCANF          reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    FGETS           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    RETURN          reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    FOR             reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    PRINT           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    ECHO            reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    ID              reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    NAME            reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    INTEGER         reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    FLOAT           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    TRUE            reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    FALSE           reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 84 (while_statement -> WHILE parenthesized_condition block .)


state 130

    (87) for_statement -> for_part1 condition for_part3 .

    CLOSE_TAG       reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    ONE_LINE_COMMENT reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    MULTI_LINE_COMMENT reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    BREAK           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    CONTINUE        reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    IF              reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    WHILE           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    FUNCTION        reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    CLASS           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    FSCANF          reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    FGETS           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    RETURN          reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    FOR             reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    PRINT           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    ECHO            reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    ID              reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    NAME            reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    INTEGER         reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    FLOAT           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    LEFT_PAREN      reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    TRUE            reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    FALSE           reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    LOGICAL_NOT     reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)
    RIGHT_BRACE     reduce using rule 87 (for_statement -> for_part1 condition for_part3 .)


state 131

    (89) for_part3 -> SEMICOLON statement_list . RIGHT_PAREN for_part4
    (96) statement_list -> statement_list . COMMA statement

    RIGHT_PAREN     shift and go to state 183
    COMMA           shift and go to state 184


state 132

    (90) for_part3 -> SEMICOLON RIGHT_PAREN . for_part4
    (91) for_part4 -> . block
    (92) for_part4 -> . SEMICOLON
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 185
    LEFT_BRACE      shift and go to state 128

    for_part4                      shift and go to state 186
    block                          shift and go to state 187

state 133

    (95) statement_list -> statement .

    RIGHT_PAREN     reduce using rule 95 (statement_list -> statement .)
    COMMA           reduce using rule 95 (statement_list -> statement .)


state 134

    (108) complex_condition -> condition logical_operator condition .
    (108) complex_condition -> condition . logical_operator condition
    (74) factor -> condition .
    (120) logical_operator -> . LOGICAL_AND
    (121) logical_operator -> . LOGICAL_OR
    (122) logical_operator -> . LOGICAL_XOR

  ! reduce/reduce conflict for TIMES resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for MOD resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 74 (factor -> condition .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 74 (factor -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_XOR resolved as shift
    SEMICOLON       reduce using rule 108 (complex_condition -> condition logical_operator condition .)
    RIGHT_PAREN     reduce using rule 108 (complex_condition -> condition logical_operator condition .)
    DOT             reduce using rule 108 (complex_condition -> condition logical_operator condition .)
    COMMA           reduce using rule 108 (complex_condition -> condition logical_operator condition .)
    RIGHT_BRACKET   reduce using rule 108 (complex_condition -> condition logical_operator condition .)
    TIMES           reduce using rule 74 (factor -> condition .)
    DIVIDE          reduce using rule 74 (factor -> condition .)
    MOD             reduce using rule 74 (factor -> condition .)
    POWER           reduce using rule 74 (factor -> condition .)
    PLUS            reduce using rule 74 (factor -> condition .)
    MINUS           reduce using rule 74 (factor -> condition .)
    EQUAL_TO        reduce using rule 74 (factor -> condition .)
    NOT_EQUAL_TO    reduce using rule 74 (factor -> condition .)
    LESS_THAN       reduce using rule 74 (factor -> condition .)
    GREATER_THAN    reduce using rule 74 (factor -> condition .)
    LESS_EQUAL      reduce using rule 74 (factor -> condition .)
    GREATER_EQUAL   reduce using rule 74 (factor -> condition .)
    IDENTICAL_TO    reduce using rule 74 (factor -> condition .)
    NOT_IDENTICAL_TO reduce using rule 74 (factor -> condition .)
    DIFFERENT       reduce using rule 74 (factor -> condition .)
    LOGICAL_AND     shift and go to state 78
    LOGICAL_OR      shift and go to state 79
    LOGICAL_XOR     shift and go to state 80

  ! LOGICAL_AND     [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_OR      [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! LOGICAL_XOR     [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! TIMES           [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! DIVIDE          [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! MOD             [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! POWER           [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! PLUS            [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! MINUS           [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! EQUAL_TO        [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_THAN       [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_THAN    [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! LESS_EQUAL      [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! IDENTICAL_TO    [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]
  ! DIFFERENT       [ reduce using rule 108 (complex_condition -> condition logical_operator condition .) ]

    logical_operator               shift and go to state 77

state 135

    (22) function_statement -> FUNCTION NAME LEFT_PAREN . array_elements RIGHT_PAREN block
    (23) function_statement -> FUNCTION NAME LEFT_PAREN . RIGHT_PAREN block
    (129) array_elements -> . array_argument
    (130) array_elements -> . array_elements COMMA array_argument
    (131) array_argument -> . argument
    (132) array_argument -> . clave KEY_VALUE argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (133) clave -> . STRING
    (134) clave -> . INTEGER
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 189
    STRING          shift and go to state 157
    INTEGER         shift and go to state 158
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    array_elements                 shift and go to state 188
    array_argument                 shift and go to state 154
    argument                       shift and go to state 155
    clave                          shift and go to state 156
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 136

    (75) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MOD             reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    POWER           reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_THAN       reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIFFERENT       reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOT             reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_AND     reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 75 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 137

    (109) parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .

    LOGICAL_AND     reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_OR      reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LOGICAL_XOR     reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    TIMES           reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIVIDE          reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MOD             reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    POWER           reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    PLUS            reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    MINUS           reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    EQUAL_TO        reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_EQUAL_TO    reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_THAN       reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    IDENTICAL_TO    reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    NOT_IDENTICAL_TO reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DIFFERENT       reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    SEMICOLON       reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    DOT             reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    COMMA           reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 109 (parenthesized_condition -> LEFT_PAREN condition RIGHT_PAREN .)


state 138

    (136) class_declaration -> CLASS NAME LEFT_BRACE . class_statements RIGHT_BRACE
    (137) class_declaration -> CLASS NAME LEFT_BRACE . RIGHT_BRACE
    (138) class_statements -> . class_statement
    (139) class_statements -> . class_statements class_statement
    (140) class_statement -> . method_declaration
    (141) class_statement -> . property_declaration
    (142) class_statement -> . ONE_LINE_COMMENT
    (143) class_statement -> . MULTI_LINE_COMMENT
    (144) method_declaration -> . visibility_operator function_statement
    (145) property_declaration -> . visibility_operator variable SEMICOLON
    (146) visibility_operator -> . PUBLIC
    (147) visibility_operator -> . PRIVATE
    (148) visibility_operator -> . PROTECTED

    RIGHT_BRACE     shift and go to state 191
    ONE_LINE_COMMENT shift and go to state 195
    MULTI_LINE_COMMENT shift and go to state 196
    PUBLIC          shift and go to state 198
    PRIVATE         shift and go to state 199
    PROTECTED       shift and go to state 200

    class_statements               shift and go to state 190
    class_statement                shift and go to state 192
    method_declaration             shift and go to state 193
    property_declaration           shift and go to state 194
    visibility_operator            shift and go to state 197

state 139

    (109) parenthesized_condition -> LEFT_PAREN . condition RIGHT_PAREN
    (123) casting -> LEFT_PAREN . casting_type RIGHT_PAREN
    (75) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (124) casting_type -> . INT_TYPE
    (125) casting_type -> . FLOAT_TYPE
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (110) relational_expression -> . expression relational_operator expression
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN

    INT_TYPE        shift and go to state 143
    FLOAT_TYPE      shift and go to state 144
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52
    LEFT_PAREN      shift and go to state 75
    ID              shift and go to state 42
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 83
    casting_type                   shift and go to state 141
    expression                     shift and go to state 82
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    term                           shift and go to state 38
    variable                       shift and go to state 74
    relational_expression          shift and go to state 51
    factor                         shift and go to state 43

state 140

    (46) print_statement -> print_function LEFT_PAREN arguments . RIGHT_PAREN
    (51) arguments -> arguments . DOT argument
    (52) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 201
    DOT             shift and go to state 146
    COMMA           shift and go to state 147


state 141

    (123) casting -> LEFT_PAREN casting_type . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 202


state 142

    (75) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (54) argument -> expression .
    (110) relational_expression -> expression . relational_operator expression
    (111) relational_operator -> . EQUAL_TO
    (112) relational_operator -> . NOT_EQUAL_TO
    (113) relational_operator -> . LESS_THAN
    (114) relational_operator -> . GREATER_THAN
    (115) relational_operator -> . LESS_EQUAL
    (116) relational_operator -> . GREATER_EQUAL
    (117) relational_operator -> . IDENTICAL_TO
    (118) relational_operator -> . NOT_IDENTICAL_TO
    (119) relational_operator -> . DIFFERENT

  ! shift/reduce conflict for RIGHT_PAREN resolved as shift
    RIGHT_PAREN     shift and go to state 136
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DOT             reduce using rule 54 (argument -> expression .)
    COMMA           reduce using rule 54 (argument -> expression .)
    EQUAL_TO        shift and go to state 59
    NOT_EQUAL_TO    shift and go to state 60
    LESS_THAN       shift and go to state 61
    GREATER_THAN    shift and go to state 62
    LESS_EQUAL      shift and go to state 63
    GREATER_EQUAL   shift and go to state 64
    IDENTICAL_TO    shift and go to state 65
    NOT_IDENTICAL_TO shift and go to state 66
    DIFFERENT       shift and go to state 67

  ! RIGHT_PAREN     [ reduce using rule 54 (argument -> expression .) ]

    relational_operator            shift and go to state 58

state 143

    (124) casting_type -> INT_TYPE .

    RIGHT_PAREN     reduce using rule 124 (casting_type -> INT_TYPE .)


state 144

    (125) casting_type -> FLOAT_TYPE .

    RIGHT_PAREN     reduce using rule 125 (casting_type -> FLOAT_TYPE .)


state 145

    (58) argument -> variable . CALL function_call
    (105) simple_condition -> variable .
    (135) array_indexing -> variable . LEFT_BRACKET INTEGER RIGHT_BRACKET
    (37) assignment_statement -> variable . assignment_operator argument
    (38) assignment_statement -> variable . PLUS_PLUS
    (39) assignment_statement -> variable . MINUS_MINUS
    (30) function_name -> variable .
    (40) assignment_operator -> . EQUALS
    (41) assignment_operator -> . PLUS_EQUALS
    (42) assignment_operator -> . MINUS_EQUALS
    (43) assignment_operator -> . TIMES_EQUALS
    (44) assignment_operator -> . DIVIDE_EQUALS
    (45) assignment_operator -> . MOD_EQUALS

    CALL            shift and go to state 148
    RIGHT_PAREN     reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_AND     reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_OR      reduce using rule 105 (simple_condition -> variable .)
    LOGICAL_XOR     reduce using rule 105 (simple_condition -> variable .)
    TIMES           reduce using rule 105 (simple_condition -> variable .)
    DIVIDE          reduce using rule 105 (simple_condition -> variable .)
    MOD             reduce using rule 105 (simple_condition -> variable .)
    POWER           reduce using rule 105 (simple_condition -> variable .)
    PLUS            reduce using rule 105 (simple_condition -> variable .)
    MINUS           reduce using rule 105 (simple_condition -> variable .)
    EQUAL_TO        reduce using rule 105 (simple_condition -> variable .)
    NOT_EQUAL_TO    reduce using rule 105 (simple_condition -> variable .)
    LESS_THAN       reduce using rule 105 (simple_condition -> variable .)
    GREATER_THAN    reduce using rule 105 (simple_condition -> variable .)
    LESS_EQUAL      reduce using rule 105 (simple_condition -> variable .)
    GREATER_EQUAL   reduce using rule 105 (simple_condition -> variable .)
    IDENTICAL_TO    reduce using rule 105 (simple_condition -> variable .)
    NOT_IDENTICAL_TO reduce using rule 105 (simple_condition -> variable .)
    DIFFERENT       reduce using rule 105 (simple_condition -> variable .)
    DOT             reduce using rule 105 (simple_condition -> variable .)
    COMMA           reduce using rule 105 (simple_condition -> variable .)
    LEFT_BRACKET    shift and go to state 149
    PLUS_PLUS       shift and go to state 106
    MINUS_MINUS     shift and go to state 107
    LEFT_PAREN      reduce using rule 30 (function_name -> variable .)
    EQUALS          shift and go to state 150
    PLUS_EQUALS     shift and go to state 109
    MINUS_EQUALS    shift and go to state 110
    TIMES_EQUALS    shift and go to state 111
    DIVIDE_EQUALS   shift and go to state 112
    MOD_EQUALS      shift and go to state 113

    assignment_operator            shift and go to state 105

state 146

    (51) arguments -> arguments DOT . argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    argument                       shift and go to state 203
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 147

    (52) arguments -> arguments COMMA . argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    argument                       shift and go to state 204
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 148

    (58) argument -> variable CALL . function_call
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME

    NAME            shift and go to state 29
    ID              shift and go to state 42

    variable                       shift and go to state 205
    function_call                  shift and go to state 206
    function_name                  shift and go to state 36

state 149

    (135) array_indexing -> variable LEFT_BRACKET . INTEGER RIGHT_BRACKET

    INTEGER         shift and go to state 207


state 150

    (40) assignment_operator -> EQUALS .

    STRING          reduce using rule 40 (assignment_operator -> EQUALS .)
    ARRAY           reduce using rule 40 (assignment_operator -> EQUALS .)
    LEFT_BRACKET    reduce using rule 40 (assignment_operator -> EQUALS .)
    ID              reduce using rule 40 (assignment_operator -> EQUALS .)
    FUNCTION        reduce using rule 40 (assignment_operator -> EQUALS .)
    FGETS           reduce using rule 40 (assignment_operator -> EQUALS .)
    NEW             reduce using rule 40 (assignment_operator -> EQUALS .)
    LEFT_PAREN      reduce using rule 40 (assignment_operator -> EQUALS .)
    NAME            reduce using rule 40 (assignment_operator -> EQUALS .)
    INTEGER         reduce using rule 40 (assignment_operator -> EQUALS .)
    FLOAT           reduce using rule 40 (assignment_operator -> EQUALS .)
    TRUE            reduce using rule 40 (assignment_operator -> EQUALS .)
    FALSE           reduce using rule 40 (assignment_operator -> EQUALS .)
    LOGICAL_NOT     reduce using rule 40 (assignment_operator -> EQUALS .)


state 151

    (63) argument -> casting argument .

    DOT             reduce using rule 63 (argument -> casting argument .)
    COMMA           reduce using rule 63 (argument -> casting argument .)
    SEMICOLON       reduce using rule 63 (argument -> casting argument .)
    RIGHT_PAREN     reduce using rule 63 (argument -> casting argument .)
    RIGHT_BRACKET   reduce using rule 63 (argument -> casting argument .)


state 152

    (127) array -> ARRAY LEFT_PAREN . array_elements RIGHT_PAREN
    (129) array_elements -> . array_argument
    (130) array_elements -> . array_elements COMMA array_argument
    (131) array_argument -> . argument
    (132) array_argument -> . clave KEY_VALUE argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (133) clave -> . STRING
    (134) clave -> . INTEGER
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 157
    INTEGER         shift and go to state 158
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    array_elements                 shift and go to state 208
    array_argument                 shift and go to state 154
    argument                       shift and go to state 155
    clave                          shift and go to state 156
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 153

    (128) array -> LEFT_BRACKET array_elements . RIGHT_BRACKET
    (130) array_elements -> array_elements . COMMA array_argument

    RIGHT_BRACKET   shift and go to state 209
    COMMA           shift and go to state 210


state 154

    (129) array_elements -> array_argument .

    RIGHT_BRACKET   reduce using rule 129 (array_elements -> array_argument .)
    COMMA           reduce using rule 129 (array_elements -> array_argument .)
    RIGHT_PAREN     reduce using rule 129 (array_elements -> array_argument .)


state 155

    (131) array_argument -> argument .

    RIGHT_BRACKET   reduce using rule 131 (array_argument -> argument .)
    COMMA           reduce using rule 131 (array_argument -> argument .)
    RIGHT_PAREN     reduce using rule 131 (array_argument -> argument .)


state 156

    (132) array_argument -> clave . KEY_VALUE argument

    KEY_VALUE       shift and go to state 211


state 157

    (53) argument -> STRING .
    (133) clave -> STRING .

    RIGHT_BRACKET   reduce using rule 53 (argument -> STRING .)
    COMMA           reduce using rule 53 (argument -> STRING .)
    RIGHT_PAREN     reduce using rule 53 (argument -> STRING .)
    KEY_VALUE       reduce using rule 133 (clave -> STRING .)


state 158

    (134) clave -> INTEGER .
    (72) factor -> INTEGER .

    KEY_VALUE       reduce using rule 134 (clave -> INTEGER .)
    TIMES           reduce using rule 72 (factor -> INTEGER .)
    DIVIDE          reduce using rule 72 (factor -> INTEGER .)
    MOD             reduce using rule 72 (factor -> INTEGER .)
    POWER           reduce using rule 72 (factor -> INTEGER .)
    PLUS            reduce using rule 72 (factor -> INTEGER .)
    MINUS           reduce using rule 72 (factor -> INTEGER .)
    EQUAL_TO        reduce using rule 72 (factor -> INTEGER .)
    NOT_EQUAL_TO    reduce using rule 72 (factor -> INTEGER .)
    LESS_THAN       reduce using rule 72 (factor -> INTEGER .)
    GREATER_THAN    reduce using rule 72 (factor -> INTEGER .)
    LESS_EQUAL      reduce using rule 72 (factor -> INTEGER .)
    GREATER_EQUAL   reduce using rule 72 (factor -> INTEGER .)
    IDENTICAL_TO    reduce using rule 72 (factor -> INTEGER .)
    NOT_IDENTICAL_TO reduce using rule 72 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 72 (factor -> INTEGER .)
    RIGHT_BRACKET   reduce using rule 72 (factor -> INTEGER .)
    COMMA           reduce using rule 72 (factor -> INTEGER .)
    RIGHT_PAREN     reduce using rule 72 (factor -> INTEGER .)


state 159

    (24) anonymous_function -> FUNCTION LEFT_PAREN . array_elements RIGHT_PAREN block
    (25) anonymous_function -> FUNCTION LEFT_PAREN . RIGHT_PAREN block
    (129) array_elements -> . array_argument
    (130) array_elements -> . array_elements COMMA array_argument
    (131) array_argument -> . argument
    (132) array_argument -> . clave KEY_VALUE argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (133) clave -> . STRING
    (134) clave -> . INTEGER
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 213
    STRING          shift and go to state 157
    INTEGER         shift and go to state 158
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    array_elements                 shift and go to state 212
    array_argument                 shift and go to state 154
    argument                       shift and go to state 155
    clave                          shift and go to state 156
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 160

    (149) object_creation -> NEW NAME . LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> NEW NAME . LEFT_PAREN arguments RIGHT_PAREN

    LEFT_PAREN      shift and go to state 214


state 161

    (32) fscanf_statement -> FSCANF LEFT_PAREN STDIN . COMMA STRING COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 215


state 162

    (31) fgets_statement -> FGETS LEFT_PAREN STDIN . RIGHT_PAREN

    RIGHT_PAREN     shift and go to state 216


state 163

    (37) assignment_statement -> variable assignment_operator argument .

    SEMICOLON       reduce using rule 37 (assignment_statement -> variable assignment_operator argument .)
    DOT             reduce using rule 37 (assignment_statement -> variable assignment_operator argument .)
    COMMA           reduce using rule 37 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_PAREN     reduce using rule 37 (assignment_statement -> variable assignment_operator argument .)
    RIGHT_BRACKET   reduce using rule 37 (assignment_statement -> variable assignment_operator argument .)


state 164

    (126) array_declaration_statement -> variable EQUALS array .

    SEMICOLON       reduce using rule 126 (array_declaration_statement -> variable EQUALS array .)
    RIGHT_PAREN     reduce using rule 126 (array_declaration_statement -> variable EQUALS array .)
    COMMA           reduce using rule 126 (array_declaration_statement -> variable EQUALS array .)


state 165

    (27) function_call -> function_name LEFT_PAREN arguments . RIGHT_PAREN
    (51) arguments -> arguments . DOT argument
    (52) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 217
    DOT             shift and go to state 146
    COMMA           shift and go to state 147


state 166

    (28) function_call -> function_name LEFT_PAREN RIGHT_PAREN .

    SEMICOLON       reduce using rule 28 (function_call -> function_name LEFT_PAREN RIGHT_PAREN .)
    DOT             reduce using rule 28 (function_call -> function_name LEFT_PAREN RIGHT_PAREN .)
    COMMA           reduce using rule 28 (function_call -> function_name LEFT_PAREN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 28 (function_call -> function_name LEFT_PAREN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 28 (function_call -> function_name LEFT_PAREN RIGHT_PAREN .)


state 167

    (67) term -> term TIMES factor .
    (71) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MOD resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for POWER resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 67 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 67 (term -> term TIMES factor .)
    TIMES           reduce using rule 67 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 67 (term -> term TIMES factor .)
    MOD             reduce using rule 67 (term -> term TIMES factor .)
    POWER           reduce using rule 67 (term -> term TIMES factor .)
    PLUS            reduce using rule 67 (term -> term TIMES factor .)
    MINUS           reduce using rule 67 (term -> term TIMES factor .)
    EQUAL_TO        reduce using rule 67 (term -> term TIMES factor .)
    NOT_EQUAL_TO    reduce using rule 67 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 67 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 67 (term -> term TIMES factor .)
    LESS_EQUAL      reduce using rule 67 (term -> term TIMES factor .)
    GREATER_EQUAL   reduce using rule 67 (term -> term TIMES factor .)
    IDENTICAL_TO    reduce using rule 67 (term -> term TIMES factor .)
    NOT_IDENTICAL_TO reduce using rule 67 (term -> term TIMES factor .)
    DIFFERENT       reduce using rule 67 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 67 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 67 (term -> term TIMES factor .)
    DOT             reduce using rule 67 (term -> term TIMES factor .)
    COMMA           reduce using rule 67 (term -> term TIMES factor .)
    LOGICAL_AND     reduce using rule 67 (term -> term TIMES factor .)
    LOGICAL_OR      reduce using rule 67 (term -> term TIMES factor .)
    LOGICAL_XOR     reduce using rule 67 (term -> term TIMES factor .)
    RIGHT_BRACKET   reduce using rule 67 (term -> term TIMES factor .)

  ! TIMES           [ reduce using rule 71 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 71 (term -> factor .) ]
  ! MOD             [ reduce using rule 71 (term -> factor .) ]
  ! POWER           [ reduce using rule 71 (term -> factor .) ]
  ! PLUS            [ reduce using rule 71 (term -> factor .) ]
  ! MINUS           [ reduce using rule 71 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 71 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 71 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 71 (term -> factor .) ]


state 168

    (68) term -> term DIVIDE factor .
    (71) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MOD resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for POWER resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 68 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 68 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 68 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 68 (term -> term DIVIDE factor .)
    MOD             reduce using rule 68 (term -> term DIVIDE factor .)
    POWER           reduce using rule 68 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 68 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 68 (term -> term DIVIDE factor .)
    EQUAL_TO        reduce using rule 68 (term -> term DIVIDE factor .)
    NOT_EQUAL_TO    reduce using rule 68 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 68 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 68 (term -> term DIVIDE factor .)
    LESS_EQUAL      reduce using rule 68 (term -> term DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 68 (term -> term DIVIDE factor .)
    IDENTICAL_TO    reduce using rule 68 (term -> term DIVIDE factor .)
    NOT_IDENTICAL_TO reduce using rule 68 (term -> term DIVIDE factor .)
    DIFFERENT       reduce using rule 68 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 68 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 68 (term -> term DIVIDE factor .)
    DOT             reduce using rule 68 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 68 (term -> term DIVIDE factor .)
    LOGICAL_AND     reduce using rule 68 (term -> term DIVIDE factor .)
    LOGICAL_OR      reduce using rule 68 (term -> term DIVIDE factor .)
    LOGICAL_XOR     reduce using rule 68 (term -> term DIVIDE factor .)
    RIGHT_BRACKET   reduce using rule 68 (term -> term DIVIDE factor .)

  ! TIMES           [ reduce using rule 71 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 71 (term -> factor .) ]
  ! MOD             [ reduce using rule 71 (term -> factor .) ]
  ! POWER           [ reduce using rule 71 (term -> factor .) ]
  ! PLUS            [ reduce using rule 71 (term -> factor .) ]
  ! MINUS           [ reduce using rule 71 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 71 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 71 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 71 (term -> factor .) ]


state 169

    (69) term -> term MOD factor .
    (71) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for MOD resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for POWER resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 69 (term -> term MOD factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 69 (term -> term MOD factor .)
    TIMES           reduce using rule 69 (term -> term MOD factor .)
    DIVIDE          reduce using rule 69 (term -> term MOD factor .)
    MOD             reduce using rule 69 (term -> term MOD factor .)
    POWER           reduce using rule 69 (term -> term MOD factor .)
    PLUS            reduce using rule 69 (term -> term MOD factor .)
    MINUS           reduce using rule 69 (term -> term MOD factor .)
    EQUAL_TO        reduce using rule 69 (term -> term MOD factor .)
    NOT_EQUAL_TO    reduce using rule 69 (term -> term MOD factor .)
    LESS_THAN       reduce using rule 69 (term -> term MOD factor .)
    GREATER_THAN    reduce using rule 69 (term -> term MOD factor .)
    LESS_EQUAL      reduce using rule 69 (term -> term MOD factor .)
    GREATER_EQUAL   reduce using rule 69 (term -> term MOD factor .)
    IDENTICAL_TO    reduce using rule 69 (term -> term MOD factor .)
    NOT_IDENTICAL_TO reduce using rule 69 (term -> term MOD factor .)
    DIFFERENT       reduce using rule 69 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 69 (term -> term MOD factor .)
    RIGHT_PAREN     reduce using rule 69 (term -> term MOD factor .)
    DOT             reduce using rule 69 (term -> term MOD factor .)
    COMMA           reduce using rule 69 (term -> term MOD factor .)
    LOGICAL_AND     reduce using rule 69 (term -> term MOD factor .)
    LOGICAL_OR      reduce using rule 69 (term -> term MOD factor .)
    LOGICAL_XOR     reduce using rule 69 (term -> term MOD factor .)
    RIGHT_BRACKET   reduce using rule 69 (term -> term MOD factor .)

  ! TIMES           [ reduce using rule 71 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 71 (term -> factor .) ]
  ! MOD             [ reduce using rule 71 (term -> factor .) ]
  ! POWER           [ reduce using rule 71 (term -> factor .) ]
  ! PLUS            [ reduce using rule 71 (term -> factor .) ]
  ! MINUS           [ reduce using rule 71 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 71 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 71 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 71 (term -> factor .) ]


state 170

    (70) term -> term POWER factor .
    (71) term -> factor .

  ! reduce/reduce conflict for TIMES resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for MOD resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for POWER resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for IDENTICAL_TO resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for NOT_IDENTICAL_TO resolved using rule 70 (term -> term POWER factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 70 (term -> term POWER factor .)
    TIMES           reduce using rule 70 (term -> term POWER factor .)
    DIVIDE          reduce using rule 70 (term -> term POWER factor .)
    MOD             reduce using rule 70 (term -> term POWER factor .)
    POWER           reduce using rule 70 (term -> term POWER factor .)
    PLUS            reduce using rule 70 (term -> term POWER factor .)
    MINUS           reduce using rule 70 (term -> term POWER factor .)
    EQUAL_TO        reduce using rule 70 (term -> term POWER factor .)
    NOT_EQUAL_TO    reduce using rule 70 (term -> term POWER factor .)
    LESS_THAN       reduce using rule 70 (term -> term POWER factor .)
    GREATER_THAN    reduce using rule 70 (term -> term POWER factor .)
    LESS_EQUAL      reduce using rule 70 (term -> term POWER factor .)
    GREATER_EQUAL   reduce using rule 70 (term -> term POWER factor .)
    IDENTICAL_TO    reduce using rule 70 (term -> term POWER factor .)
    NOT_IDENTICAL_TO reduce using rule 70 (term -> term POWER factor .)
    DIFFERENT       reduce using rule 70 (term -> term POWER factor .)
    SEMICOLON       reduce using rule 70 (term -> term POWER factor .)
    RIGHT_PAREN     reduce using rule 70 (term -> term POWER factor .)
    DOT             reduce using rule 70 (term -> term POWER factor .)
    COMMA           reduce using rule 70 (term -> term POWER factor .)
    LOGICAL_AND     reduce using rule 70 (term -> term POWER factor .)
    LOGICAL_OR      reduce using rule 70 (term -> term POWER factor .)
    LOGICAL_XOR     reduce using rule 70 (term -> term POWER factor .)
    RIGHT_BRACKET   reduce using rule 70 (term -> term POWER factor .)

  ! TIMES           [ reduce using rule 71 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 71 (term -> factor .) ]
  ! MOD             [ reduce using rule 71 (term -> factor .) ]
  ! POWER           [ reduce using rule 71 (term -> factor .) ]
  ! PLUS            [ reduce using rule 71 (term -> factor .) ]
  ! MINUS           [ reduce using rule 71 (term -> factor .) ]
  ! EQUAL_TO        [ reduce using rule 71 (term -> factor .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_THAN       [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 71 (term -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (term -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (term -> factor .) ]
  ! IDENTICAL_TO    [ reduce using rule 71 (term -> factor .) ]
  ! NOT_IDENTICAL_TO [ reduce using rule 71 (term -> factor .) ]
  ! DIFFERENT       [ reduce using rule 71 (term -> factor .) ]


state 171

    (85) for_part1 -> FOR LEFT_PAREN assignment_list . SEMICOLON
    (94) assignment_list -> assignment_list . COMMA assignment_statement

    SEMICOLON       shift and go to state 218
    COMMA           shift and go to state 219


state 172

    (86) for_part1 -> FOR LEFT_PAREN SEMICOLON .

    SEMICOLON       reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    TRUE            reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FALSE           reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    ID              reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)
    FLOAT           reduce using rule 86 (for_part1 -> FOR LEFT_PAREN SEMICOLON .)


state 173

    (93) assignment_list -> assignment_statement .

    SEMICOLON       reduce using rule 93 (assignment_list -> assignment_statement .)
    COMMA           reduce using rule 93 (assignment_list -> assignment_statement .)


state 174

    (37) assignment_statement -> variable . assignment_operator argument
    (38) assignment_statement -> variable . PLUS_PLUS
    (39) assignment_statement -> variable . MINUS_MINUS
    (40) assignment_operator -> . EQUALS
    (41) assignment_operator -> . PLUS_EQUALS
    (42) assignment_operator -> . MINUS_EQUALS
    (43) assignment_operator -> . TIMES_EQUALS
    (44) assignment_operator -> . DIVIDE_EQUALS
    (45) assignment_operator -> . MOD_EQUALS

    PLUS_PLUS       shift and go to state 106
    MINUS_MINUS     shift and go to state 107
    EQUALS          shift and go to state 150
    PLUS_EQUALS     shift and go to state 109
    MINUS_EQUALS    shift and go to state 110
    TIMES_EQUALS    shift and go to state 111
    DIVIDE_EQUALS   shift and go to state 112
    MOD_EQUALS      shift and go to state 113

    assignment_operator            shift and go to state 105

state 175

    (36) variable -> ID CALL NAME .

    PLUS_PLUS       reduce using rule 36 (variable -> ID CALL NAME .)
    MINUS_MINUS     reduce using rule 36 (variable -> ID CALL NAME .)
    EQUALS          reduce using rule 36 (variable -> ID CALL NAME .)
    PLUS_EQUALS     reduce using rule 36 (variable -> ID CALL NAME .)
    MINUS_EQUALS    reduce using rule 36 (variable -> ID CALL NAME .)
    TIMES_EQUALS    reduce using rule 36 (variable -> ID CALL NAME .)
    DIVIDE_EQUALS   reduce using rule 36 (variable -> ID CALL NAME .)
    MOD_EQUALS      reduce using rule 36 (variable -> ID CALL NAME .)
    LEFT_PAREN      reduce using rule 36 (variable -> ID CALL NAME .)
    LOGICAL_AND     reduce using rule 36 (variable -> ID CALL NAME .)
    LOGICAL_OR      reduce using rule 36 (variable -> ID CALL NAME .)
    LOGICAL_XOR     reduce using rule 36 (variable -> ID CALL NAME .)
    TIMES           reduce using rule 36 (variable -> ID CALL NAME .)
    DIVIDE          reduce using rule 36 (variable -> ID CALL NAME .)
    MOD             reduce using rule 36 (variable -> ID CALL NAME .)
    POWER           reduce using rule 36 (variable -> ID CALL NAME .)
    PLUS            reduce using rule 36 (variable -> ID CALL NAME .)
    MINUS           reduce using rule 36 (variable -> ID CALL NAME .)
    EQUAL_TO        reduce using rule 36 (variable -> ID CALL NAME .)
    NOT_EQUAL_TO    reduce using rule 36 (variable -> ID CALL NAME .)
    LESS_THAN       reduce using rule 36 (variable -> ID CALL NAME .)
    GREATER_THAN    reduce using rule 36 (variable -> ID CALL NAME .)
    LESS_EQUAL      reduce using rule 36 (variable -> ID CALL NAME .)
    GREATER_EQUAL   reduce using rule 36 (variable -> ID CALL NAME .)
    IDENTICAL_TO    reduce using rule 36 (variable -> ID CALL NAME .)
    NOT_IDENTICAL_TO reduce using rule 36 (variable -> ID CALL NAME .)
    DIFFERENT       reduce using rule 36 (variable -> ID CALL NAME .)
    SEMICOLON       reduce using rule 36 (variable -> ID CALL NAME .)
    RIGHT_PAREN     reduce using rule 36 (variable -> ID CALL NAME .)
    CALL            reduce using rule 36 (variable -> ID CALL NAME .)
    LEFT_BRACKET    reduce using rule 36 (variable -> ID CALL NAME .)
    DOT             reduce using rule 36 (variable -> ID CALL NAME .)
    COMMA           reduce using rule 36 (variable -> ID CALL NAME .)
    RIGHT_BRACKET   reduce using rule 36 (variable -> ID CALL NAME .)


state 176

    (77) if_statement -> IF parenthesized_condition block else_if_extended .
    (78) if_statement -> IF parenthesized_condition block else_if_extended . if_part3
    (81) else_if_extended -> else_if_extended . if_part2
    (83) if_part3 -> . ELSE block
    (82) if_part2 -> . ELSEIF parenthesized_condition block

    CLOSE_TAG       reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ONE_LINE_COMMENT reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    MULTI_LINE_COMMENT reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    BREAK           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    CONTINUE        reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    IF              reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    WHILE           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FUNCTION        reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    CLASS           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FSCANF          reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FGETS           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    RETURN          reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FOR             reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    PRINT           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ECHO            reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ID              reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    NAME            reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    INTEGER         reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FLOAT           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    LEFT_PAREN      reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    TRUE            reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    FALSE           reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    LOGICAL_NOT     reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    RIGHT_BRACE     reduce using rule 77 (if_statement -> IF parenthesized_condition block else_if_extended .)
    ELSE            shift and go to state 179
    ELSEIF          shift and go to state 180

    if_part3                       shift and go to state 220
    if_part2                       shift and go to state 221

state 177

    (79) if_statement -> IF parenthesized_condition block if_part3 .

    CLOSE_TAG       reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    ONE_LINE_COMMENT reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    BREAK           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    CONTINUE        reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    IF              reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    WHILE           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    FUNCTION        reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    CLASS           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    FSCANF          reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    FGETS           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    RETURN          reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    FOR             reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    PRINT           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    ECHO            reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    ID              reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    NAME            reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    INTEGER         reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    FLOAT           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    LEFT_PAREN      reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    TRUE            reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    FALSE           reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    LOGICAL_NOT     reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)
    RIGHT_BRACE     reduce using rule 79 (if_statement -> IF parenthesized_condition block if_part3 .)


state 178

    (80) else_if_extended -> if_part2 .

    ELSE            reduce using rule 80 (else_if_extended -> if_part2 .)
    ELSEIF          reduce using rule 80 (else_if_extended -> if_part2 .)
    CLOSE_TAG       reduce using rule 80 (else_if_extended -> if_part2 .)
    ONE_LINE_COMMENT reduce using rule 80 (else_if_extended -> if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 80 (else_if_extended -> if_part2 .)
    BREAK           reduce using rule 80 (else_if_extended -> if_part2 .)
    CONTINUE        reduce using rule 80 (else_if_extended -> if_part2 .)
    IF              reduce using rule 80 (else_if_extended -> if_part2 .)
    WHILE           reduce using rule 80 (else_if_extended -> if_part2 .)
    FUNCTION        reduce using rule 80 (else_if_extended -> if_part2 .)
    CLASS           reduce using rule 80 (else_if_extended -> if_part2 .)
    FSCANF          reduce using rule 80 (else_if_extended -> if_part2 .)
    FGETS           reduce using rule 80 (else_if_extended -> if_part2 .)
    RETURN          reduce using rule 80 (else_if_extended -> if_part2 .)
    FOR             reduce using rule 80 (else_if_extended -> if_part2 .)
    PRINT           reduce using rule 80 (else_if_extended -> if_part2 .)
    ECHO            reduce using rule 80 (else_if_extended -> if_part2 .)
    ID              reduce using rule 80 (else_if_extended -> if_part2 .)
    NAME            reduce using rule 80 (else_if_extended -> if_part2 .)
    INTEGER         reduce using rule 80 (else_if_extended -> if_part2 .)
    FLOAT           reduce using rule 80 (else_if_extended -> if_part2 .)
    LEFT_PAREN      reduce using rule 80 (else_if_extended -> if_part2 .)
    TRUE            reduce using rule 80 (else_if_extended -> if_part2 .)
    FALSE           reduce using rule 80 (else_if_extended -> if_part2 .)
    LOGICAL_NOT     reduce using rule 80 (else_if_extended -> if_part2 .)
    RIGHT_BRACE     reduce using rule 80 (else_if_extended -> if_part2 .)


state 179

    (83) if_part3 -> ELSE . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 222

state 180

    (82) if_part2 -> ELSEIF . parenthesized_condition block
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN

    LEFT_PAREN      shift and go to state 69

    parenthesized_condition        shift and go to state 223

state 181

    (97) block -> LEFT_BRACE statements . RIGHT_BRACE
    (3) statements -> statements . statement2
    (4) statement2 -> . statement SEMICOLON
    (5) statement2 -> . if_statement
    (6) statement2 -> . while_statement
    (7) statement2 -> . for_statement
    (8) statement2 -> . function_statement
    (9) statement2 -> . ONE_LINE_COMMENT
    (10) statement2 -> . MULTI_LINE_COMMENT
    (11) statement2 -> . class_declaration
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . expression
    (76) if_statement -> . IF parenthesized_condition block
    (77) if_statement -> . IF parenthesized_condition block else_if_extended
    (78) if_statement -> . IF parenthesized_condition block else_if_extended if_part3
    (79) if_statement -> . IF parenthesized_condition block if_part3
    (84) while_statement -> . WHILE parenthesized_condition block
    (87) for_statement -> . for_part1 condition for_part3
    (88) for_statement -> . for_part1 for_part3
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (136) class_declaration -> . CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE
    (137) class_declaration -> . CLASS NAME LEFT_BRACE RIGHT_BRACE
    (46) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> . print_function arguments
    (32) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (126) array_declaration_statement -> . variable EQUALS array
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (26) return_statement -> . RETURN arguments
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (85) for_part1 -> . FOR LEFT_PAREN assignment_list SEMICOLON
    (86) for_part1 -> . FOR LEFT_PAREN SEMICOLON
    (48) print_function -> . PRINT
    (49) print_function -> . ECHO
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_BRACE     shift and go to state 224
    ONE_LINE_COMMENT shift and go to state 10
    MULTI_LINE_COMMENT shift and go to state 11
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 23
    WHILE           shift and go to state 25
    FUNCTION        shift and go to state 28
    CLASS           shift and go to state 31
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    RETURN          shift and go to state 37
    FOR             shift and go to state 39
    PRINT           shift and go to state 40
    ECHO            shift and go to state 41
    ID              shift and go to state 42
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    statement2                     shift and go to state 54
    statement                      shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    function_statement             shift and go to state 9
    class_declaration              shift and go to state 12
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    expression                     shift and go to state 22
    parenthesized_condition        shift and go to state 24
    for_part1                      shift and go to state 26
    condition                      shift and go to state 27
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    function_name                  shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 43
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    relational_expression          shift and go to state 51

state 182

    (98) block -> LEFT_BRACE RIGHT_BRACE .

    ELSE            reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    ELSEIF          reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    CLASS           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    INTEGER         reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    FLOAT           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    TRUE            reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    FALSE           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    PUBLIC          reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    PRIVATE         reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    PROTECTED       reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    DOT             reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    COMMA           reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    SEMICOLON       reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_PAREN     reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACKET   reduce using rule 98 (block -> LEFT_BRACE RIGHT_BRACE .)


state 183

    (89) for_part3 -> SEMICOLON statement_list RIGHT_PAREN . for_part4
    (91) for_part4 -> . block
    (92) for_part4 -> . SEMICOLON
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    SEMICOLON       shift and go to state 185
    LEFT_BRACE      shift and go to state 128

    for_part4                      shift and go to state 225
    block                          shift and go to state 187

state 184

    (96) statement_list -> statement_list COMMA . statement
    (12) statement -> . print_statement
    (13) statement -> . fscanf_statement
    (14) statement -> . fgets_statement
    (15) statement -> . assignment_statement
    (16) statement -> . array_declaration_statement
    (17) statement -> . BREAK
    (18) statement -> . CONTINUE
    (19) statement -> . function_call
    (20) statement -> . return_statement
    (21) statement -> . expression
    (46) print_statement -> . print_function LEFT_PAREN arguments RIGHT_PAREN
    (47) print_statement -> . print_function arguments
    (32) fscanf_statement -> . FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (126) array_declaration_statement -> . variable EQUALS array
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (26) return_statement -> . RETURN arguments
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (48) print_function -> . PRINT
    (49) print_function -> . ECHO
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    FSCANF          shift and go to state 33
    FGETS           shift and go to state 34
    RETURN          shift and go to state 37
    PRINT           shift and go to state 40
    ECHO            shift and go to state 41
    ID              shift and go to state 42
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    LEFT_PAREN      shift and go to state 30
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    statement                      shift and go to state 226
    print_statement                shift and go to state 13
    fscanf_statement               shift and go to state 14
    fgets_statement                shift and go to state 15
    assignment_statement           shift and go to state 16
    array_declaration_statement    shift and go to state 17
    function_call                  shift and go to state 20
    return_statement               shift and go to state 21
    expression                     shift and go to state 22
    print_function                 shift and go to state 32
    variable                       shift and go to state 35
    function_name                  shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 185

    (92) for_part4 -> SEMICOLON .

    CLOSE_TAG       reduce using rule 92 (for_part4 -> SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 92 (for_part4 -> SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 92 (for_part4 -> SEMICOLON .)
    BREAK           reduce using rule 92 (for_part4 -> SEMICOLON .)
    CONTINUE        reduce using rule 92 (for_part4 -> SEMICOLON .)
    IF              reduce using rule 92 (for_part4 -> SEMICOLON .)
    WHILE           reduce using rule 92 (for_part4 -> SEMICOLON .)
    FUNCTION        reduce using rule 92 (for_part4 -> SEMICOLON .)
    CLASS           reduce using rule 92 (for_part4 -> SEMICOLON .)
    FSCANF          reduce using rule 92 (for_part4 -> SEMICOLON .)
    FGETS           reduce using rule 92 (for_part4 -> SEMICOLON .)
    RETURN          reduce using rule 92 (for_part4 -> SEMICOLON .)
    FOR             reduce using rule 92 (for_part4 -> SEMICOLON .)
    PRINT           reduce using rule 92 (for_part4 -> SEMICOLON .)
    ECHO            reduce using rule 92 (for_part4 -> SEMICOLON .)
    ID              reduce using rule 92 (for_part4 -> SEMICOLON .)
    NAME            reduce using rule 92 (for_part4 -> SEMICOLON .)
    INTEGER         reduce using rule 92 (for_part4 -> SEMICOLON .)
    FLOAT           reduce using rule 92 (for_part4 -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 92 (for_part4 -> SEMICOLON .)
    TRUE            reduce using rule 92 (for_part4 -> SEMICOLON .)
    FALSE           reduce using rule 92 (for_part4 -> SEMICOLON .)
    LOGICAL_NOT     reduce using rule 92 (for_part4 -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 92 (for_part4 -> SEMICOLON .)


state 186

    (90) for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    IF              reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    CLASS           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    ID              reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    INTEGER         reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FLOAT           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    LEFT_PAREN      reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    TRUE            reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    FALSE           reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    LOGICAL_NOT     reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 90 (for_part3 -> SEMICOLON RIGHT_PAREN for_part4 .)


state 187

    (91) for_part4 -> block .

    CLOSE_TAG       reduce using rule 91 (for_part4 -> block .)
    ONE_LINE_COMMENT reduce using rule 91 (for_part4 -> block .)
    MULTI_LINE_COMMENT reduce using rule 91 (for_part4 -> block .)
    BREAK           reduce using rule 91 (for_part4 -> block .)
    CONTINUE        reduce using rule 91 (for_part4 -> block .)
    IF              reduce using rule 91 (for_part4 -> block .)
    WHILE           reduce using rule 91 (for_part4 -> block .)
    FUNCTION        reduce using rule 91 (for_part4 -> block .)
    CLASS           reduce using rule 91 (for_part4 -> block .)
    FSCANF          reduce using rule 91 (for_part4 -> block .)
    FGETS           reduce using rule 91 (for_part4 -> block .)
    RETURN          reduce using rule 91 (for_part4 -> block .)
    FOR             reduce using rule 91 (for_part4 -> block .)
    PRINT           reduce using rule 91 (for_part4 -> block .)
    ECHO            reduce using rule 91 (for_part4 -> block .)
    ID              reduce using rule 91 (for_part4 -> block .)
    NAME            reduce using rule 91 (for_part4 -> block .)
    INTEGER         reduce using rule 91 (for_part4 -> block .)
    FLOAT           reduce using rule 91 (for_part4 -> block .)
    LEFT_PAREN      reduce using rule 91 (for_part4 -> block .)
    TRUE            reduce using rule 91 (for_part4 -> block .)
    FALSE           reduce using rule 91 (for_part4 -> block .)
    LOGICAL_NOT     reduce using rule 91 (for_part4 -> block .)
    RIGHT_BRACE     reduce using rule 91 (for_part4 -> block .)


state 188

    (22) function_statement -> FUNCTION NAME LEFT_PAREN array_elements . RIGHT_PAREN block
    (130) array_elements -> array_elements . COMMA array_argument

    RIGHT_PAREN     shift and go to state 227
    COMMA           shift and go to state 210


state 189

    (23) function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 228

state 190

    (136) class_declaration -> CLASS NAME LEFT_BRACE class_statements . RIGHT_BRACE
    (139) class_statements -> class_statements . class_statement
    (140) class_statement -> . method_declaration
    (141) class_statement -> . property_declaration
    (142) class_statement -> . ONE_LINE_COMMENT
    (143) class_statement -> . MULTI_LINE_COMMENT
    (144) method_declaration -> . visibility_operator function_statement
    (145) property_declaration -> . visibility_operator variable SEMICOLON
    (146) visibility_operator -> . PUBLIC
    (147) visibility_operator -> . PRIVATE
    (148) visibility_operator -> . PROTECTED

    RIGHT_BRACE     shift and go to state 229
    ONE_LINE_COMMENT shift and go to state 195
    MULTI_LINE_COMMENT shift and go to state 196
    PUBLIC          shift and go to state 198
    PRIVATE         shift and go to state 199
    PROTECTED       shift and go to state 200

    class_statement                shift and go to state 230
    method_declaration             shift and go to state 193
    property_declaration           shift and go to state 194
    visibility_operator            shift and go to state 197

state 191

    (137) class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    BREAK           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    CONTINUE        reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    IF              reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    WHILE           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FUNCTION        reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    CLASS           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FSCANF          reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FGETS           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    RETURN          reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FOR             reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    PRINT           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ECHO            reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    ID              reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    NAME            reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    INTEGER         reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FLOAT           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    TRUE            reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    FALSE           reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 137 (class_declaration -> CLASS NAME LEFT_BRACE RIGHT_BRACE .)


state 192

    (138) class_statements -> class_statement .

    RIGHT_BRACE     reduce using rule 138 (class_statements -> class_statement .)
    ONE_LINE_COMMENT reduce using rule 138 (class_statements -> class_statement .)
    MULTI_LINE_COMMENT reduce using rule 138 (class_statements -> class_statement .)
    PUBLIC          reduce using rule 138 (class_statements -> class_statement .)
    PRIVATE         reduce using rule 138 (class_statements -> class_statement .)
    PROTECTED       reduce using rule 138 (class_statements -> class_statement .)


state 193

    (140) class_statement -> method_declaration .

    RIGHT_BRACE     reduce using rule 140 (class_statement -> method_declaration .)
    ONE_LINE_COMMENT reduce using rule 140 (class_statement -> method_declaration .)
    MULTI_LINE_COMMENT reduce using rule 140 (class_statement -> method_declaration .)
    PUBLIC          reduce using rule 140 (class_statement -> method_declaration .)
    PRIVATE         reduce using rule 140 (class_statement -> method_declaration .)
    PROTECTED       reduce using rule 140 (class_statement -> method_declaration .)


state 194

    (141) class_statement -> property_declaration .

    RIGHT_BRACE     reduce using rule 141 (class_statement -> property_declaration .)
    ONE_LINE_COMMENT reduce using rule 141 (class_statement -> property_declaration .)
    MULTI_LINE_COMMENT reduce using rule 141 (class_statement -> property_declaration .)
    PUBLIC          reduce using rule 141 (class_statement -> property_declaration .)
    PRIVATE         reduce using rule 141 (class_statement -> property_declaration .)
    PROTECTED       reduce using rule 141 (class_statement -> property_declaration .)


state 195

    (142) class_statement -> ONE_LINE_COMMENT .

    RIGHT_BRACE     reduce using rule 142 (class_statement -> ONE_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 142 (class_statement -> ONE_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 142 (class_statement -> ONE_LINE_COMMENT .)
    PUBLIC          reduce using rule 142 (class_statement -> ONE_LINE_COMMENT .)
    PRIVATE         reduce using rule 142 (class_statement -> ONE_LINE_COMMENT .)
    PROTECTED       reduce using rule 142 (class_statement -> ONE_LINE_COMMENT .)


state 196

    (143) class_statement -> MULTI_LINE_COMMENT .

    RIGHT_BRACE     reduce using rule 143 (class_statement -> MULTI_LINE_COMMENT .)
    ONE_LINE_COMMENT reduce using rule 143 (class_statement -> MULTI_LINE_COMMENT .)
    MULTI_LINE_COMMENT reduce using rule 143 (class_statement -> MULTI_LINE_COMMENT .)
    PUBLIC          reduce using rule 143 (class_statement -> MULTI_LINE_COMMENT .)
    PRIVATE         reduce using rule 143 (class_statement -> MULTI_LINE_COMMENT .)
    PROTECTED       reduce using rule 143 (class_statement -> MULTI_LINE_COMMENT .)


state 197

    (144) method_declaration -> visibility_operator . function_statement
    (145) property_declaration -> visibility_operator . variable SEMICOLON
    (22) function_statement -> . FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block
    (23) function_statement -> . FUNCTION NAME LEFT_PAREN RIGHT_PAREN block
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME

    FUNCTION        shift and go to state 28
    ID              shift and go to state 42

    function_statement             shift and go to state 231
    variable                       shift and go to state 232

state 198

    (146) visibility_operator -> PUBLIC .

    FUNCTION        reduce using rule 146 (visibility_operator -> PUBLIC .)
    ID              reduce using rule 146 (visibility_operator -> PUBLIC .)


state 199

    (147) visibility_operator -> PRIVATE .

    FUNCTION        reduce using rule 147 (visibility_operator -> PRIVATE .)
    ID              reduce using rule 147 (visibility_operator -> PRIVATE .)


state 200

    (148) visibility_operator -> PROTECTED .

    FUNCTION        reduce using rule 148 (visibility_operator -> PROTECTED .)
    ID              reduce using rule 148 (visibility_operator -> PROTECTED .)


state 201

    (46) print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 46 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 46 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 46 (print_statement -> print_function LEFT_PAREN arguments RIGHT_PAREN .)


state 202

    (123) casting -> LEFT_PAREN casting_type RIGHT_PAREN .

    STRING          reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ARRAY           reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_BRACKET    reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    ID              reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FUNCTION        reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FGETS           reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NEW             reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    NAME            reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    INTEGER         reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FLOAT           reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    TRUE            reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    FALSE           reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)
    LOGICAL_NOT     reduce using rule 123 (casting -> LEFT_PAREN casting_type RIGHT_PAREN .)


state 203

    (51) arguments -> arguments DOT argument .

    DOT             reduce using rule 51 (arguments -> arguments DOT argument .)
    COMMA           reduce using rule 51 (arguments -> arguments DOT argument .)
    SEMICOLON       reduce using rule 51 (arguments -> arguments DOT argument .)
    RIGHT_PAREN     reduce using rule 51 (arguments -> arguments DOT argument .)


state 204

    (52) arguments -> arguments COMMA argument .

    DOT             reduce using rule 52 (arguments -> arguments COMMA argument .)
    COMMA           reduce using rule 52 (arguments -> arguments COMMA argument .)
    SEMICOLON       reduce using rule 52 (arguments -> arguments COMMA argument .)
    RIGHT_PAREN     reduce using rule 52 (arguments -> arguments COMMA argument .)


state 205

    (30) function_name -> variable .

    LEFT_PAREN      reduce using rule 30 (function_name -> variable .)


state 206

    (58) argument -> variable CALL function_call .

    DOT             reduce using rule 58 (argument -> variable CALL function_call .)
    COMMA           reduce using rule 58 (argument -> variable CALL function_call .)
    SEMICOLON       reduce using rule 58 (argument -> variable CALL function_call .)
    RIGHT_PAREN     reduce using rule 58 (argument -> variable CALL function_call .)
    RIGHT_BRACKET   reduce using rule 58 (argument -> variable CALL function_call .)


state 207

    (135) array_indexing -> variable LEFT_BRACKET INTEGER . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 233


state 208

    (127) array -> ARRAY LEFT_PAREN array_elements . RIGHT_PAREN
    (130) array_elements -> array_elements . COMMA array_argument

    RIGHT_PAREN     shift and go to state 234
    COMMA           shift and go to state 210


state 209

    (128) array -> LEFT_BRACKET array_elements RIGHT_BRACKET .

    DOT             reduce using rule 128 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    COMMA           reduce using rule 128 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 128 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 128 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 128 (array -> LEFT_BRACKET array_elements RIGHT_BRACKET .)


state 210

    (130) array_elements -> array_elements COMMA . array_argument
    (131) array_argument -> . argument
    (132) array_argument -> . clave KEY_VALUE argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (133) clave -> . STRING
    (134) clave -> . INTEGER
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 157
    INTEGER         shift and go to state 158
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    array_argument                 shift and go to state 235
    argument                       shift and go to state 155
    clave                          shift and go to state 156
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 211

    (132) array_argument -> clave KEY_VALUE . argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    argument                       shift and go to state 236
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 212

    (24) anonymous_function -> FUNCTION LEFT_PAREN array_elements . RIGHT_PAREN block
    (130) array_elements -> array_elements . COMMA array_argument

    RIGHT_PAREN     shift and go to state 237
    COMMA           shift and go to state 210


state 213

    (25) anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 238

state 214

    (149) object_creation -> NEW NAME LEFT_PAREN . RIGHT_PAREN
    (150) object_creation -> NEW NAME LEFT_PAREN . arguments RIGHT_PAREN
    (50) arguments -> . argument
    (51) arguments -> . arguments DOT argument
    (52) arguments -> . arguments COMMA argument
    (53) argument -> . STRING
    (54) argument -> . expression
    (55) argument -> . array
    (56) argument -> . array_indexing
    (57) argument -> . function_call
    (58) argument -> . variable CALL function_call
    (59) argument -> . anonymous_function
    (60) argument -> . assignment_statement
    (61) argument -> . fgets_statement
    (62) argument -> . object_creation
    (63) argument -> . casting argument
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (127) array -> . ARRAY LEFT_PAREN array_elements RIGHT_PAREN
    (128) array -> . LEFT_BRACKET array_elements RIGHT_BRACKET
    (135) array_indexing -> . variable LEFT_BRACKET INTEGER RIGHT_BRACKET
    (27) function_call -> . function_name LEFT_PAREN arguments RIGHT_PAREN
    (28) function_call -> . function_name LEFT_PAREN RIGHT_PAREN
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME
    (24) anonymous_function -> . FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block
    (25) anonymous_function -> . FUNCTION LEFT_PAREN RIGHT_PAREN block
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (31) fgets_statement -> . FGETS LEFT_PAREN STDIN RIGHT_PAREN
    (149) object_creation -> . NEW NAME LEFT_PAREN RIGHT_PAREN
    (150) object_creation -> . NEW NAME LEFT_PAREN arguments RIGHT_PAREN
    (123) casting -> . LEFT_PAREN casting_type RIGHT_PAREN
    (67) term -> . term TIMES factor
    (68) term -> . term DIVIDE factor
    (69) term -> . term MOD factor
    (70) term -> . term POWER factor
    (71) term -> . factor
    (29) function_name -> . NAME
    (30) function_name -> . variable
    (72) factor -> . INTEGER
    (73) factor -> . FLOAT
    (74) factor -> . condition
    (75) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (99) condition -> . simple_condition
    (100) condition -> . negated_condition
    (101) condition -> . complex_condition
    (102) condition -> . parenthesized_condition
    (103) simple_condition -> . TRUE
    (104) simple_condition -> . FALSE
    (105) simple_condition -> . variable
    (106) simple_condition -> . relational_expression
    (107) negated_condition -> . LOGICAL_NOT condition
    (108) complex_condition -> . condition logical_operator condition
    (109) parenthesized_condition -> . LEFT_PAREN condition RIGHT_PAREN
    (110) relational_expression -> . expression relational_operator expression

    RIGHT_PAREN     shift and go to state 239
    STRING          shift and go to state 88
    ARRAY           shift and go to state 99
    LEFT_BRACKET    shift and go to state 100
    ID              shift and go to state 42
    FUNCTION        shift and go to state 101
    FGETS           shift and go to state 34
    NEW             shift and go to state 102
    LEFT_PAREN      shift and go to state 116
    NAME            shift and go to state 29
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    LOGICAL_NOT     shift and go to state 52

    arguments                      shift and go to state 240
    argument                       shift and go to state 87
    expression                     shift and go to state 89
    array                          shift and go to state 90
    array_indexing                 shift and go to state 91
    function_call                  shift and go to state 92
    variable                       shift and go to state 93
    anonymous_function             shift and go to state 94
    assignment_statement           shift and go to state 95
    fgets_statement                shift and go to state 96
    object_creation                shift and go to state 97
    casting                        shift and go to state 98
    term                           shift and go to state 38
    function_name                  shift and go to state 36
    factor                         shift and go to state 43
    condition                      shift and go to state 27
    simple_condition               shift and go to state 46
    negated_condition              shift and go to state 47
    complex_condition              shift and go to state 48
    parenthesized_condition        shift and go to state 24
    relational_expression          shift and go to state 51

state 215

    (32) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA . STRING COMMA variable_list RIGHT_PAREN

    STRING          shift and go to state 241


state 216

    (31) fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .

    SEMICOLON       reduce using rule 31 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    DOT             reduce using rule 31 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    COMMA           reduce using rule 31 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 31 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 31 (fgets_statement -> FGETS LEFT_PAREN STDIN RIGHT_PAREN .)


state 217

    (27) function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN .

    SEMICOLON       reduce using rule 27 (function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN .)
    DOT             reduce using rule 27 (function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 27 (function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 27 (function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 27 (function_call -> function_name LEFT_PAREN arguments RIGHT_PAREN .)


state 218

    (85) for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .

    SEMICOLON       reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    TRUE            reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FALSE           reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    LEFT_PAREN      reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    ID              reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    INTEGER         reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)
    FLOAT           reduce using rule 85 (for_part1 -> FOR LEFT_PAREN assignment_list SEMICOLON .)


state 219

    (94) assignment_list -> assignment_list COMMA . assignment_statement
    (37) assignment_statement -> . variable assignment_operator argument
    (38) assignment_statement -> . variable PLUS_PLUS
    (39) assignment_statement -> . variable MINUS_MINUS
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME

    ID              shift and go to state 42

    assignment_statement           shift and go to state 242
    variable                       shift and go to state 174

state 220

    (78) if_statement -> IF parenthesized_condition block else_if_extended if_part3 .

    CLOSE_TAG       reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ONE_LINE_COMMENT reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    MULTI_LINE_COMMENT reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    BREAK           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CONTINUE        reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    IF              reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    WHILE           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FUNCTION        reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    CLASS           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FSCANF          reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FGETS           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RETURN          reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FOR             reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    PRINT           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ECHO            reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    ID              reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    NAME            reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    INTEGER         reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FLOAT           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    LEFT_PAREN      reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    TRUE            reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    FALSE           reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    LOGICAL_NOT     reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)
    RIGHT_BRACE     reduce using rule 78 (if_statement -> IF parenthesized_condition block else_if_extended if_part3 .)


state 221

    (81) else_if_extended -> else_if_extended if_part2 .

    ELSE            reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    ELSEIF          reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    CLOSE_TAG       reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    ONE_LINE_COMMENT reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    MULTI_LINE_COMMENT reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    BREAK           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    CONTINUE        reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    IF              reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    WHILE           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    FUNCTION        reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    CLASS           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    FSCANF          reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    FGETS           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    RETURN          reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    FOR             reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    PRINT           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    ECHO            reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    ID              reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    NAME            reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    INTEGER         reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    FLOAT           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    LEFT_PAREN      reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    TRUE            reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    FALSE           reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    LOGICAL_NOT     reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)
    RIGHT_BRACE     reduce using rule 81 (else_if_extended -> else_if_extended if_part2 .)


state 222

    (83) if_part3 -> ELSE block .

    CLOSE_TAG       reduce using rule 83 (if_part3 -> ELSE block .)
    ONE_LINE_COMMENT reduce using rule 83 (if_part3 -> ELSE block .)
    MULTI_LINE_COMMENT reduce using rule 83 (if_part3 -> ELSE block .)
    BREAK           reduce using rule 83 (if_part3 -> ELSE block .)
    CONTINUE        reduce using rule 83 (if_part3 -> ELSE block .)
    IF              reduce using rule 83 (if_part3 -> ELSE block .)
    WHILE           reduce using rule 83 (if_part3 -> ELSE block .)
    FUNCTION        reduce using rule 83 (if_part3 -> ELSE block .)
    CLASS           reduce using rule 83 (if_part3 -> ELSE block .)
    FSCANF          reduce using rule 83 (if_part3 -> ELSE block .)
    FGETS           reduce using rule 83 (if_part3 -> ELSE block .)
    RETURN          reduce using rule 83 (if_part3 -> ELSE block .)
    FOR             reduce using rule 83 (if_part3 -> ELSE block .)
    PRINT           reduce using rule 83 (if_part3 -> ELSE block .)
    ECHO            reduce using rule 83 (if_part3 -> ELSE block .)
    ID              reduce using rule 83 (if_part3 -> ELSE block .)
    NAME            reduce using rule 83 (if_part3 -> ELSE block .)
    INTEGER         reduce using rule 83 (if_part3 -> ELSE block .)
    FLOAT           reduce using rule 83 (if_part3 -> ELSE block .)
    LEFT_PAREN      reduce using rule 83 (if_part3 -> ELSE block .)
    TRUE            reduce using rule 83 (if_part3 -> ELSE block .)
    FALSE           reduce using rule 83 (if_part3 -> ELSE block .)
    LOGICAL_NOT     reduce using rule 83 (if_part3 -> ELSE block .)
    RIGHT_BRACE     reduce using rule 83 (if_part3 -> ELSE block .)


state 223

    (82) if_part2 -> ELSEIF parenthesized_condition . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 243

state 224

    (97) block -> LEFT_BRACE statements RIGHT_BRACE .

    ELSE            reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ELSEIF          reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLOSE_TAG       reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    BREAK           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    IF              reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    WHILE           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    CLASS           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FSCANF          reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FGETS           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RETURN          reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FOR             reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRINT           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ECHO            reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    ID              reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    NAME            reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    INTEGER         reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FLOAT           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    TRUE            reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    FALSE           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PUBLIC          reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PRIVATE         reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    PROTECTED       reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    DOT             reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    COMMA           reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    SEMICOLON       reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_PAREN     reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)
    RIGHT_BRACKET   reduce using rule 97 (block -> LEFT_BRACE statements RIGHT_BRACE .)


state 225

    (89) for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .

    CLOSE_TAG       reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ONE_LINE_COMMENT reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    MULTI_LINE_COMMENT reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    BREAK           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CONTINUE        reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    IF              reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    WHILE           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FUNCTION        reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    CLASS           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FSCANF          reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FGETS           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RETURN          reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FOR             reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    PRINT           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ECHO            reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    ID              reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    NAME            reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    INTEGER         reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FLOAT           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    LEFT_PAREN      reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    TRUE            reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    FALSE           reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    LOGICAL_NOT     reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)
    RIGHT_BRACE     reduce using rule 89 (for_part3 -> SEMICOLON statement_list RIGHT_PAREN for_part4 .)


state 226

    (96) statement_list -> statement_list COMMA statement .

    RIGHT_PAREN     reduce using rule 96 (statement_list -> statement_list COMMA statement .)
    COMMA           reduce using rule 96 (statement_list -> statement_list COMMA statement .)


state 227

    (22) function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 244

state 228

    (23) function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    BREAK           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    CONTINUE        reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    IF              reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    WHILE           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FUNCTION        reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    CLASS           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FSCANF          reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FGETS           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    RETURN          reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FOR             reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PRINT           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ECHO            reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    ID              reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    NAME            reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    INTEGER         reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FLOAT           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    TRUE            reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    FALSE           reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    LOGICAL_NOT     reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PUBLIC          reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PRIVATE         reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)
    PROTECTED       reduce using rule 23 (function_statement -> FUNCTION NAME LEFT_PAREN RIGHT_PAREN block .)


state 229

    (136) class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .

    CLOSE_TAG       reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ONE_LINE_COMMENT reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    MULTI_LINE_COMMENT reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    BREAK           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    CONTINUE        reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    IF              reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    WHILE           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FUNCTION        reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    CLASS           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FSCANF          reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FGETS           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    RETURN          reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FOR             reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    PRINT           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ECHO            reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    ID              reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    NAME            reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    INTEGER         reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FLOAT           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    TRUE            reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    FALSE           reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    LOGICAL_NOT     reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 136 (class_declaration -> CLASS NAME LEFT_BRACE class_statements RIGHT_BRACE .)


state 230

    (139) class_statements -> class_statements class_statement .

    RIGHT_BRACE     reduce using rule 139 (class_statements -> class_statements class_statement .)
    ONE_LINE_COMMENT reduce using rule 139 (class_statements -> class_statements class_statement .)
    MULTI_LINE_COMMENT reduce using rule 139 (class_statements -> class_statements class_statement .)
    PUBLIC          reduce using rule 139 (class_statements -> class_statements class_statement .)
    PRIVATE         reduce using rule 139 (class_statements -> class_statements class_statement .)
    PROTECTED       reduce using rule 139 (class_statements -> class_statements class_statement .)


state 231

    (144) method_declaration -> visibility_operator function_statement .

    RIGHT_BRACE     reduce using rule 144 (method_declaration -> visibility_operator function_statement .)
    ONE_LINE_COMMENT reduce using rule 144 (method_declaration -> visibility_operator function_statement .)
    MULTI_LINE_COMMENT reduce using rule 144 (method_declaration -> visibility_operator function_statement .)
    PUBLIC          reduce using rule 144 (method_declaration -> visibility_operator function_statement .)
    PRIVATE         reduce using rule 144 (method_declaration -> visibility_operator function_statement .)
    PROTECTED       reduce using rule 144 (method_declaration -> visibility_operator function_statement .)


state 232

    (145) property_declaration -> visibility_operator variable . SEMICOLON

    SEMICOLON       shift and go to state 245


state 233

    (135) array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .

    DOT             reduce using rule 135 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    COMMA           reduce using rule 135 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 135 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 135 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 135 (array_indexing -> variable LEFT_BRACKET INTEGER RIGHT_BRACKET .)


state 234

    (127) array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .

    DOT             reduce using rule 127 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    COMMA           reduce using rule 127 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    SEMICOLON       reduce using rule 127 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 127 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 127 (array -> ARRAY LEFT_PAREN array_elements RIGHT_PAREN .)


state 235

    (130) array_elements -> array_elements COMMA array_argument .

    RIGHT_BRACKET   reduce using rule 130 (array_elements -> array_elements COMMA array_argument .)
    COMMA           reduce using rule 130 (array_elements -> array_elements COMMA array_argument .)
    RIGHT_PAREN     reduce using rule 130 (array_elements -> array_elements COMMA array_argument .)


state 236

    (132) array_argument -> clave KEY_VALUE argument .

    RIGHT_BRACKET   reduce using rule 132 (array_argument -> clave KEY_VALUE argument .)
    COMMA           reduce using rule 132 (array_argument -> clave KEY_VALUE argument .)
    RIGHT_PAREN     reduce using rule 132 (array_argument -> clave KEY_VALUE argument .)


state 237

    (24) anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN . block
    (97) block -> . LEFT_BRACE statements RIGHT_BRACE
    (98) block -> . LEFT_BRACE RIGHT_BRACE

    LEFT_BRACE      shift and go to state 128

    block                          shift and go to state 246

state 238

    (25) anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .

    DOT             reduce using rule 25 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    COMMA           reduce using rule 25 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    SEMICOLON       reduce using rule 25 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_PAREN     reduce using rule 25 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)
    RIGHT_BRACKET   reduce using rule 25 (anonymous_function -> FUNCTION LEFT_PAREN RIGHT_PAREN block .)


state 239

    (149) object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .

    DOT             reduce using rule 149 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    COMMA           reduce using rule 149 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    SEMICOLON       reduce using rule 149 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 149 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 149 (object_creation -> NEW NAME LEFT_PAREN RIGHT_PAREN .)


state 240

    (150) object_creation -> NEW NAME LEFT_PAREN arguments . RIGHT_PAREN
    (51) arguments -> arguments . DOT argument
    (52) arguments -> arguments . COMMA argument

    RIGHT_PAREN     shift and go to state 247
    DOT             shift and go to state 146
    COMMA           shift and go to state 147


state 241

    (32) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING . COMMA variable_list RIGHT_PAREN

    COMMA           shift and go to state 248


state 242

    (94) assignment_list -> assignment_list COMMA assignment_statement .

    SEMICOLON       reduce using rule 94 (assignment_list -> assignment_list COMMA assignment_statement .)
    COMMA           reduce using rule 94 (assignment_list -> assignment_list COMMA assignment_statement .)


state 243

    (82) if_part2 -> ELSEIF parenthesized_condition block .

    ELSE            reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    ELSEIF          reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLOSE_TAG       reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    ONE_LINE_COMMENT reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    MULTI_LINE_COMMENT reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    BREAK           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    CONTINUE        reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    IF              reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    WHILE           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    FUNCTION        reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    CLASS           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    FSCANF          reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    FGETS           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    RETURN          reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    FOR             reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    PRINT           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    ECHO            reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    ID              reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    NAME            reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    INTEGER         reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    FLOAT           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    LEFT_PAREN      reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    TRUE            reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    FALSE           reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    LOGICAL_NOT     reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)
    RIGHT_BRACE     reduce using rule 82 (if_part2 -> ELSEIF parenthesized_condition block .)


state 244

    (22) function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .

    CLOSE_TAG       reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    ONE_LINE_COMMENT reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    MULTI_LINE_COMMENT reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    BREAK           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    CONTINUE        reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    IF              reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    WHILE           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FUNCTION        reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    CLASS           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FSCANF          reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FGETS           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    RETURN          reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FOR             reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PRINT           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    ECHO            reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    ID              reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    NAME            reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    INTEGER         reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FLOAT           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    TRUE            reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    FALSE           reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    LOGICAL_NOT     reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PUBLIC          reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PRIVATE         reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)
    PROTECTED       reduce using rule 22 (function_statement -> FUNCTION NAME LEFT_PAREN array_elements RIGHT_PAREN block .)


state 245

    (145) property_declaration -> visibility_operator variable SEMICOLON .

    RIGHT_BRACE     reduce using rule 145 (property_declaration -> visibility_operator variable SEMICOLON .)
    ONE_LINE_COMMENT reduce using rule 145 (property_declaration -> visibility_operator variable SEMICOLON .)
    MULTI_LINE_COMMENT reduce using rule 145 (property_declaration -> visibility_operator variable SEMICOLON .)
    PUBLIC          reduce using rule 145 (property_declaration -> visibility_operator variable SEMICOLON .)
    PRIVATE         reduce using rule 145 (property_declaration -> visibility_operator variable SEMICOLON .)
    PROTECTED       reduce using rule 145 (property_declaration -> visibility_operator variable SEMICOLON .)


state 246

    (24) anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block .

    DOT             reduce using rule 24 (anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block .)
    COMMA           reduce using rule 24 (anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block .)
    SEMICOLON       reduce using rule 24 (anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block .)
    RIGHT_PAREN     reduce using rule 24 (anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block .)
    RIGHT_BRACKET   reduce using rule 24 (anonymous_function -> FUNCTION LEFT_PAREN array_elements RIGHT_PAREN block .)


state 247

    (150) object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .

    DOT             reduce using rule 150 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    COMMA           reduce using rule 150 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    SEMICOLON       reduce using rule 150 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 150 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 150 (object_creation -> NEW NAME LEFT_PAREN arguments RIGHT_PAREN .)


state 248

    (32) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA . variable_list RIGHT_PAREN
    (33) variable_list -> . variable
    (34) variable_list -> . variable_list COMMA variable
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME

    ID              shift and go to state 42

    variable_list                  shift and go to state 249
    variable                       shift and go to state 250

state 249

    (32) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list . RIGHT_PAREN
    (34) variable_list -> variable_list . COMMA variable

    RIGHT_PAREN     shift and go to state 252
    COMMA           shift and go to state 251


state 250

    (33) variable_list -> variable .

    RIGHT_PAREN     reduce using rule 33 (variable_list -> variable .)
    COMMA           reduce using rule 33 (variable_list -> variable .)


state 251

    (34) variable_list -> variable_list COMMA . variable
    (35) variable -> . ID
    (36) variable -> . ID CALL NAME

    ID              shift and go to state 42

    variable                       shift and go to state 253

state 252

    (32) fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .

    SEMICOLON       reduce using rule 32 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 32 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)
    COMMA           reduce using rule 32 (fscanf_statement -> FSCANF LEFT_PAREN STDIN COMMA STRING COMMA variable_list RIGHT_PAREN .)


state 253

    (34) variable_list -> variable_list COMMA variable .

    RIGHT_PAREN     reduce using rule 34 (variable_list -> variable_list COMMA variable .)
    COMMA           reduce using rule 34 (variable_list -> variable_list COMMA variable .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 27 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 27 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 27 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 38 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 38 resolved as shift
WARNING: shift/reduce conflict for MOD in state 38 resolved as shift
WARNING: shift/reduce conflict for POWER in state 38 resolved as shift
WARNING: shift/reduce conflict for CALL in state 42 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 83 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 86 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 108 resolved as shift
WARNING: shift/reduce conflict for LEFT_BRACKET in state 108 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 123 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 123 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 123 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 124 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 124 resolved as shift
WARNING: shift/reduce conflict for MOD in state 124 resolved as shift
WARNING: shift/reduce conflict for POWER in state 124 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 125 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 125 resolved as shift
WARNING: shift/reduce conflict for MOD in state 125 resolved as shift
WARNING: shift/reduce conflict for POWER in state 125 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 126 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL_TO in state 126 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 126 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 126 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 126 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 126 resolved as shift
WARNING: shift/reduce conflict for IDENTICAL_TO in state 126 resolved as shift
WARNING: shift/reduce conflict for NOT_IDENTICAL_TO in state 126 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 126 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_XOR in state 134 resolved as shift
WARNING: shift/reduce conflict for RIGHT_PAREN in state 142 resolved as shift
WARNING: reduce/reduce conflict in state 123 resolved using rule (factor -> condition)
WARNING: rejected rule (negated_condition -> LOGICAL_NOT condition) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (expression -> expression PLUS term)
WARNING: rejected rule (expression -> term) in state 124
WARNING: reduce/reduce conflict in state 125 resolved using rule (expression -> expression MINUS term)
WARNING: rejected rule (expression -> term) in state 125
WARNING: reduce/reduce conflict in state 134 resolved using rule (factor -> condition)
WARNING: rejected rule (complex_condition -> condition logical_operator condition) in state 134
WARNING: reduce/reduce conflict in state 167 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 167
WARNING: reduce/reduce conflict in state 168 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 168
WARNING: reduce/reduce conflict in state 169 resolved using rule (term -> term MOD factor)
WARNING: rejected rule (term -> factor) in state 169
WARNING: reduce/reduce conflict in state 170 resolved using rule (term -> term POWER factor)
WARNING: rejected rule (term -> factor) in state 170
